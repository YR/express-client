/* generated by Buddy */
if ('undefined' === typeof self) var self = this;
if ('undefined' === typeof global) var global = self;
if (self._m_ == null) self._m_ = {};
if (self.require == null) {
  self.require = function require (id) {
    if (!_m_[id]) return;
    return (_m_[id].boot) ? _m_[id]() : _m_[id];
  };
}
var global = window.global = window;

(function (global) {
  var babelHelpers = global.babelHelpers = {};

  babelHelpers.classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  babelHelpers.createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  babelHelpers.defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  babelHelpers.get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  babelHelpers.inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  babelHelpers.possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  babelHelpers.taggedTemplateLiteral = function (strings, raw) {
    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  };
})(typeof global === "undefined" ? self : global);
_m_['@yr/runtime/index.js#1.2.0']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  /**
   * Determine if the current runtime is server or browser
   * https://github.com/yr/runtime
   * @copyright Yr
   * @license MIT
   */
  
  var isNode = (typeof process !== 'undefined'
    && {}.toString.call(process) === '[object process]');
  
  exports.isServer = isNode;
  exports.isBrowser = !isNode;

  return module.exports;
}).call({exports:{}});
_m_['@yr/url-utils/index.js#2.3.1']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  /**
   * URL/path utilities
   * https://github.com/yr/url-utils
   * @copyright Yr
   * @license MIT
   */
  
  var isServer = _m_['@yr/runtime/index.js#1.2.0'].isServer;
  
  var RE_TEMPLATE = /\{([0-9a-zA-Z]+)\}/g;
  var RE_URL = /([^:])(\/{2,})/g;
  
  /**
   * Join url segments
   * Handles strings or arrays of strings
   * @returns {String}
   */
  exports.join = function () {
    var leading = '';
    var path = [];
  
    function add(seg) {
      if (seg) {
        // Handle leading slash
        if (seg.charAt(0) == '/') {
          // Keep if first segment
          if (!path.length) leading = '/';
          seg = seg.slice(1);
        }
        if (seg.length) path.push(exports.sanitize(seg));
      }
    }
  
    for (var _len = arguments.length, segments = Array(_len), _key = 0; _key < _len; _key++) {
      segments[_key] = arguments[_key];
    }
  
    if (segments.length) {
      segments.forEach(function (segment) {
        // Handle array
        if (Array.isArray(segment)) {
          segment.forEach(add);
        } else {
          add(segment);
        }
      });
  
      return leading + path.join('/');
    }
  
    return '';
  };
  
  /**
   * Add query parameters to url in alphabetical order
   * Handles undefined query parameters
   * @param {String} url
   * @param {Object} query
   * @returns {String}
   */
  exports.query = function (url, query) {
    var delimit = '?';
    var sorted = [];
  
    function append(q) {
      if (url.charAt(url.length - 1) != delimit) url += '&';
      url += q + '=' + query[q];
    }
  
    if (url && query) {
      url = exports.sanitize(url);
      sorted = Object.keys(query).sort();
      if (!sorted.length) return '';
      // Add delimiter
      url += delimit;
      // Append queries
      sorted.forEach(function (q) {
        if (query[q] != null) append(q);
      });
  
      return exports.encode(url);
    }
  
    return '';
  };
  
  /**
   * Remove trailing '/' from 'url'
   * @param {String} url
   * @returns {String}
   */
  exports.sanitize = function (url) {
    if (url && url != '/') {
      url = url.replace(RE_URL, '$1/');
      if (url.charAt(url.length - 1) == '/') url = url.slice(0, -1);
    }
  
    return url || '';
  };
  
  /**
   * Decode 'url'
   * @param {String} url
   * @returns {String}
   */
  exports.decode = function (url) {
    if ('string' == typeof url) {
      try {
        url = decodeURI(url);
      } catch (err) {
        url = '';
      }
    }
  
    return url;
  };
  
  /**
   * Encode 'url'
   * @param {String} url
   * @returns {String}
   */
  exports.encode = function (url) {
    if ('string' == typeof url) {
      try {
        // Try to decode first in-case url is encoded
        try {
          url = decodeURI(url);
        } catch (err) {
          // Do nothing
        }
        url = encodeURI(url);
      } catch (err) {
        url = '';
      }
    }
  
    return url;
  };
  
  /**
   * Retrieve current browser path
   * @returns {String}
   */
  exports.getCurrent = function () {
    return !isServer ? exports.encode(window.location.pathname + window.location.search + window.location.hash) : '';
  };
  
  /**
   * Substitute 'data' values in 'str' template
   * @param {String} str
   * @param {Object} data
   * @param {Object} [options]
   * @returns {String}
   */
  exports.template = function (str, data) {
    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  
    str = String(str).replace(RE_TEMPLATE, function (match, prop, idx) {
      return data && data[prop] != null ? data[prop] : options.loose ? match : '';
    });
  
    return exports.sanitize(str);
  };

  return module.exports;
}).call({exports:{}});
_m_['isarray/index.js#0.0.1']=(function(module,exports){
  module=this;exports=module.exports;

  module.exports = Array.isArray || function (arr) {
    return Object.prototype.toString.call(arr) == '[object Array]';
  };
  

  return module.exports;
}).call({exports:{}});
_m_['path-to-regexp/index.js#1.5.3']=(function(module,exports){
  module=this;exports=module.exports;

  var isarray = _m_['isarray/index.js#0.0.1']
  
  /**
   * Expose `pathToRegexp`.
   */
  module.exports = pathToRegexp
  module.exports.parse = parse
  module.exports.compile = compile
  module.exports.tokensToFunction = tokensToFunction
  module.exports.tokensToRegExp = tokensToRegExp
  
  /**
   * The main path matching regexp utility.
   *
   * @type {RegExp}
   */
  var PATH_REGEXP = new RegExp([
    // Match escaped characters that would otherwise appear in future matches.
    // This allows the user to escape special characters that won't transform.
    '(\\\\.)',
    // Match Express-style parameters and un-named parameters with a prefix
    // and optional suffixes. Matches appear as:
    //
    // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
    // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
    // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
    '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
  ].join('|'), 'g')
  
  /**
   * Parse a string for the raw tokens.
   *
   * @param  {string} str
   * @return {!Array}
   */
  function parse (str) {
    var tokens = []
    var key = 0
    var index = 0
    var path = ''
    var res
  
    while ((res = PATH_REGEXP.exec(str)) != null) {
      var m = res[0]
      var escaped = res[1]
      var offset = res.index
      path += str.slice(index, offset)
      index = offset + m.length
  
      // Ignore already escaped sequences.
      if (escaped) {
        path += escaped[1]
        continue
      }
  
      var next = str[index]
      var prefix = res[2]
      var name = res[3]
      var capture = res[4]
      var group = res[5]
      var modifier = res[6]
      var asterisk = res[7]
  
      // Push the current path onto the tokens.
      if (path) {
        tokens.push(path)
        path = ''
      }
  
      var partial = prefix != null && next != null && next !== prefix
      var repeat = modifier === '+' || modifier === '*'
      var optional = modifier === '?' || modifier === '*'
      var delimiter = res[2] || '/'
      var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')
  
      tokens.push({
        name: name || key++,
        prefix: prefix || '',
        delimiter: delimiter,
        optional: optional,
        repeat: repeat,
        partial: partial,
        asterisk: !!asterisk,
        pattern: escapeGroup(pattern)
      })
    }
  
    // Match any characters still remaining.
    if (index < str.length) {
      path += str.substr(index)
    }
  
    // If the path exists, push it onto the end.
    if (path) {
      tokens.push(path)
    }
  
    return tokens
  }
  
  /**
   * Compile a string to a template function for the path.
   *
   * @param  {string}             str
   * @return {!function(Object=, Object=)}
   */
  function compile (str) {
    return tokensToFunction(parse(str))
  }
  
  /**
   * Prettier encoding of URI path segments.
   *
   * @param  {string}
   * @return {string}
   */
  function encodeURIComponentPretty (str) {
    return encodeURI(str).replace(/[\/?#]/g, function (c) {
      return '%' + c.charCodeAt(0).toString(16).toUpperCase()
    })
  }
  
  /**
   * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
   *
   * @param  {string}
   * @return {string}
   */
  function encodeAsterisk (str) {
    return encodeURI(str).replace(/[?#]/g, function (c) {
      return '%' + c.charCodeAt(0).toString(16).toUpperCase()
    })
  }
  
  /**
   * Expose a method for transforming tokens into the path function.
   */
  function tokensToFunction (tokens) {
    // Compile all the tokens into regexps.
    var matches = new Array(tokens.length)
  
    // Compile all the patterns before compilation.
    for (var i = 0; i < tokens.length; i++) {
      if (typeof tokens[i] === 'object') {
        matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')
      }
    }
  
    return function (obj, opts) {
      var path = ''
      var data = obj || {}
      var options = opts || {}
      var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent
  
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i]
  
        if (typeof token === 'string') {
          path += token
  
          continue
        }
  
        var value = data[token.name]
        var segment
  
        if (value == null) {
          if (token.optional) {
            // Prepend partial segment prefixes.
            if (token.partial) {
              path += token.prefix
            }
  
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to be defined')
          }
        }
  
        if (isarray(value)) {
          if (!token.repeat) {
            throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
          }
  
          if (value.length === 0) {
            if (token.optional) {
              continue
            } else {
              throw new TypeError('Expected "' + token.name + '" to not be empty')
            }
          }
  
          for (var j = 0; j < value.length; j++) {
            segment = encode(value[j])
  
            if (!matches[i].test(segment)) {
              throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
            }
  
            path += (j === 0 ? token.prefix : token.delimiter) + segment
          }
  
          continue
        }
  
        segment = token.asterisk ? encodeAsterisk(value) : encode(value)
  
        if (!matches[i].test(segment)) {
          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
        }
  
        path += token.prefix + segment
      }
  
      return path
    }
  }
  
  /**
   * Escape a regular expression string.
   *
   * @param  {string} str
   * @return {string}
   */
  function escapeString (str) {
    return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
  }
  
  /**
   * Escape the capturing group by escaping special characters and meaning.
   *
   * @param  {string} group
   * @return {string}
   */
  function escapeGroup (group) {
    return group.replace(/([=!:$\/()])/g, '\\$1')
  }
  
  /**
   * Attach the keys as a property of the regexp.
   *
   * @param  {!RegExp} re
   * @param  {Array}   keys
   * @return {!RegExp}
   */
  function attachKeys (re, keys) {
    re.keys = keys
    return re
  }
  
  /**
   * Get the flags for a regexp from the options.
   *
   * @param  {Object} options
   * @return {string}
   */
  function flags (options) {
    return options.sensitive ? '' : 'i'
  }
  
  /**
   * Pull out keys from a regexp.
   *
   * @param  {!RegExp} path
   * @param  {!Array}  keys
   * @return {!RegExp}
   */
  function regexpToRegexp (path, keys) {
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g)
  
    if (groups) {
      for (var i = 0; i < groups.length; i++) {
        keys.push({
          name: i,
          prefix: null,
          delimiter: null,
          optional: false,
          repeat: false,
          partial: false,
          asterisk: false,
          pattern: null
        })
      }
    }
  
    return attachKeys(path, keys)
  }
  
  /**
   * Transform an array into a regexp.
   *
   * @param  {!Array}  path
   * @param  {Array}   keys
   * @param  {!Object} options
   * @return {!RegExp}
   */
  function arrayToRegexp (path, keys, options) {
    var parts = []
  
    for (var i = 0; i < path.length; i++) {
      parts.push(pathToRegexp(path[i], keys, options).source)
    }
  
    var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))
  
    return attachKeys(regexp, keys)
  }
  
  /**
   * Create a path regexp from string input.
   *
   * @param  {string}  path
   * @param  {!Array}  keys
   * @param  {!Object} options
   * @return {!RegExp}
   */
  function stringToRegexp (path, keys, options) {
    var tokens = parse(path)
    var re = tokensToRegExp(tokens, options)
  
    // Attach keys back to the regexp.
    for (var i = 0; i < tokens.length; i++) {
      if (typeof tokens[i] !== 'string') {
        keys.push(tokens[i])
      }
    }
  
    return attachKeys(re, keys)
  }
  
  /**
   * Expose a function for taking tokens and returning a RegExp.
   *
   * @param  {!Array}  tokens
   * @param  {Object=} options
   * @return {!RegExp}
   */
  function tokensToRegExp (tokens, options) {
    options = options || {}
  
    var strict = options.strict
    var end = options.end !== false
    var route = ''
    var lastToken = tokens[tokens.length - 1]
    var endsWithSlash = typeof lastToken === 'string' && /\/$/.test(lastToken)
  
    // Iterate over the tokens and create our regexp string.
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]
  
      if (typeof token === 'string') {
        route += escapeString(token)
      } else {
        var prefix = escapeString(token.prefix)
        var capture = '(?:' + token.pattern + ')'
  
        if (token.repeat) {
          capture += '(?:' + prefix + capture + ')*'
        }
  
        if (token.optional) {
          if (!token.partial) {
            capture = '(?:' + prefix + '(' + capture + '))?'
          } else {
            capture = prefix + '(' + capture + ')?'
          }
        } else {
          capture = prefix + '(' + capture + ')'
        }
  
        route += capture
      }
    }
  
    // In non-strict mode we allow a slash at the end of match. If the path to
    // match already ends with a slash, we remove it for consistency. The slash
    // is valid at the end of a path match, not in the middle. This is important
    // in non-ending mode, where "/test/" shouldn't match "/test//route".
    if (!strict) {
      route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?'
    }
  
    if (end) {
      route += '$'
    } else {
      // In non-ending mode, we need the capturing groups to match as much as
      // possible by using a positive lookahead to the end or next path segment.
      route += strict && endsWithSlash ? '' : '(?=\\/|$)'
    }
  
    return new RegExp('^' + route, flags(options))
  }
  
  /**
   * Normalize the given path string, returning a regular expression.
   *
   * An empty array can be passed in for the keys, which will hold the
   * placeholder key descriptions. For example, using `/user/:id`, `keys` will
   * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
   *
   * @param  {(string|RegExp|Array)} path
   * @param  {(Array|Object)=}       keys
   * @param  {Object=}               options
   * @return {!RegExp}
   */
  function pathToRegexp (path, keys, options) {
    keys = keys || []
  
    if (!isarray(keys)) {
      options = /** @type {!Object} */ (keys)
      keys = []
    } else if (!options) {
      options = {}
    }
  
    if (path instanceof RegExp) {
      return regexpToRegexp(path, /** @type {!Array} */ (keys))
    }
  
    if (isarray(path)) {
      return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
    }
  
    return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
  }
  

  return module.exports;
}).call({exports:{}});
_m_['src/lib/layer.js']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  /**
   * Router layer object
   */
  
  var matcher = _m_['path-to-regexp/index.js#1.5.3'];
  var urlUtils = _m_['@yr/url-utils/index.js#2.3.1'];
  
  /**
   * Instance Factory
   * @param {String} path
   * @param {Function} fn
   * @param {Object} options
   * @returns {Layer}
   */
  module.exports = function (path, fn, options) {
    return new Layer(path, fn, options);
  };
  
  var Layer = function () {
    /**
     * Constructor
     * @param {String} path
     * @param {Function} fn
     * @param {Object} options
     */
  
    function Layer(path, fn, options) {
      babelHelpers.classCallCheck(this, Layer);
  
      // To be filled by matcher
      this.keys = [];
      this.path = null;
      this.params = null;
      this.fn = fn;
      this.name = fn.name ? '<' + fn.name + '>' : '<anonymous>';
      this.fastmatch = path == '/' && !options.end;
      this.regexp = matcher(path, this.keys, options);
    }
  
    /**
     * Determine if this route matches 'path'
     * @param {String} path
     * @returns {Boolean}
     */
  
  
    Layer.prototype.match = function match(path) {
      if (this.fastmatch) {
        this.params = {};
        this.path = '';
        return true;
      }
  
      var mtch = this.regexp.exec(path);
  
      if (!mtch) {
        this.params = null;
        this.path = null;
        return false;
      }
  
      this.params = {};
      this.path = mtch[0];
  
      var n = 0;
      var key = void 0,
          val = void 0;
  
      for (var i = 1, len = mtch.length; i < len; ++i) {
        key = this.keys[i - 1];
        val = urlUtils.decode(mtch[i]);
  
        if (key) {
          this.params[key.name] = val;
        } else {
          this.params[n++] = val;
        }
      }
  
      return true;
    };
  
    /**
     * Handle error
     * @param {Error} err
     * @param {Request} req
     * @param {Response} res
     * @param {Function} next
     * @returns {null}
     */
  
  
    Layer.prototype.handleError = function handleError(err, req, res, next) {
      // Only call if it handles errors
      if (this.fn.length !== 4) return next(err);
  
      try {
        this.fn(err, req, res, next);
      } catch (err) {
        next(err);
      }
    };
  
    /**
     * Handle
     * @param {Request} req
     * @param {Response} res
     * @param {Function} next
     * @returns {null}
     */
  
  
    Layer.prototype.handleRequest = function handleRequest(req, res, next) {
      // Skip if error handler
      if (this.fn.length > 3) return next();
  
      try {
        this.fn(req, res, next);
      } catch (err) {
        next(err);
      }
    };
  
    return Layer;
  }();

  return module.exports;
}).call({exports:{}});
_m_['ms/index.js#0.7.1']=(function(module,exports){
  module=this;exports=module.exports;

  /**
   * Helpers.
   */
  
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  
  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} options
   * @return {String|Number}
   * @api public
   */
  
  module.exports = function(val, options){
    options = options || {};
    if ('string' == typeof val) return parse(val);
    return options.long
      ? long(val)
      : short(val);
  };
  
  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */
  
  function parse(str) {
    str = '' + str;
    if (str.length > 10000) return;
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) return;
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
    }
  }
  
  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */
  
  function short(ms) {
    if (ms >= d) return Math.round(ms / d) + 'd';
    if (ms >= h) return Math.round(ms / h) + 'h';
    if (ms >= m) return Math.round(ms / m) + 'm';
    if (ms >= s) return Math.round(ms / s) + 's';
    return ms + 'ms';
  }
  
  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */
  
  function long(ms) {
    return plural(ms, d, 'day')
      || plural(ms, h, 'hour')
      || plural(ms, m, 'minute')
      || plural(ms, s, 'second')
      || ms + ' ms';
  }
  
  /**
   * Pluralization helper.
   */
  
  function plural(ms, n, name) {
    if (ms < n) return;
    if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
    return Math.ceil(ms / n) + ' ' + name + 's';
  }
  

  return module.exports;
}).call({exports:{}});
_m_['debug/debug.js#2.2.0']=(function(module,exports){
  module=this;exports=module.exports;

  
  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   *
   * Expose `debug()` as the module.
   */
  
  exports = module.exports = debug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = _m_['ms/index.js#0.7.1'];
  
  /**
   * The currently active debug mode names, and names to skip.
   */
  
  exports.names = [];
  exports.skips = [];
  
  /**
   * Map of special "%n" handling functions, for the debug "format" argument.
   *
   * Valid key names are a single, lowercased letter, i.e. "n".
   */
  
  exports.formatters = {};
  
  /**
   * Previously assigned color.
   */
  
  var prevColor = 0;
  
  /**
   * Previous log timestamp.
   */
  
  var prevTime;
  
  /**
   * Select a color.
   *
   * @return {Number}
   * @api private
   */
  
  function selectColor() {
    return exports.colors[prevColor++ % exports.colors.length];
  }
  
  /**
   * Create a debugger with the given `namespace`.
   *
   * @param {String} namespace
   * @return {Function}
   * @api public
   */
  
  function debug(namespace) {
  
    // define the `disabled` version
    function disabled() {
    }
    disabled.enabled = false;
  
    // define the `enabled` version
    function enabled() {
  
      var self = enabled;
  
      // set `diff` timestamp
      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
  
      // add the `color` if not set
      if (null == self.useColors) self.useColors = exports.useColors();
      if (null == self.color && self.useColors) self.color = selectColor();
  
      var args = Array.prototype.slice.call(arguments);
  
      args[0] = exports.coerce(args[0]);
  
      if ('string' !== typeof args[0]) {
        // anything else let's inspect with %o
        args = ['%o'].concat(args);
      }
  
      // apply any `formatters` transformations
      var index = 0;
      args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
        // if we encounter an escaped % then don't increase the array index
        if (match === '%%') return match;
        index++;
        var formatter = exports.formatters[format];
        if ('function' === typeof formatter) {
          var val = args[index];
          match = formatter.call(self, val);
  
          // now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });
  
      if ('function' === typeof exports.formatArgs) {
        args = exports.formatArgs.apply(self, args);
      }
      var logFn = enabled.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }
    enabled.enabled = true;
  
    var fn = exports.enabled(namespace) ? enabled : disabled;
  
    fn.namespace = namespace;
  
    return fn;
  }
  
  /**
   * Enables a debug mode by namespaces. This can include modes
   * separated by a colon and wildcards.
   *
   * @param {String} namespaces
   * @api public
   */
  
  function enable(namespaces) {
    exports.save(namespaces);
  
    var split = (namespaces || '').split(/[\s,]+/);
    var len = split.length;
  
    for (var i = 0; i < len; i++) {
      if (!split[i]) continue; // ignore empty strings
      namespaces = split[i].replace(/\*/g, '.*?');
      if (namespaces[0] === '-') {
        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        exports.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  
  /**
   * Disable debug output.
   *
   * @api public
   */
  
  function disable() {
    exports.enable('');
  }
  
  /**
   * Returns true if the given mode name is enabled, false otherwise.
   *
   * @param {String} name
   * @return {Boolean}
   * @api public
   */
  
  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length; i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length; i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  
  /**
   * Coerce `val`.
   *
   * @param {Mixed} val
   * @return {Mixed}
   * @api private
   */
  
  function coerce(val) {
    if (val instanceof Error) return val.stack || val.message;
    return val;
  }
  

  return module.exports;
}).call({exports:{}});
_m_['debug/browser.js#2.2.0']=(function(module,exports){
  module=this;exports=module.exports;

  
  /**
   * This is the web browser implementation of `debug()`.
   *
   * Expose `debug()` as the module.
   */
  
  exports = module.exports = _m_['debug/debug.js#2.2.0'];
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = 'undefined' != typeof chrome
                 && 'undefined' != typeof chrome.storage
                    ? chrome.storage.local
                    : localstorage();
  
  /**
   * Colors.
   */
  
  exports.colors = [
    'lightseagreen',
    'forestgreen',
    'goldenrod',
    'dodgerblue',
    'darkorchid',
    'crimson'
  ];
  
  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */
  
  function useColors() {
    // is webkit? http://stackoverflow.com/a/16459606/376773
    return ('WebkitAppearance' in document.documentElement.style) ||
      // is firebug? http://stackoverflow.com/a/398120/376773
      (window.console && (console.firebug || (console.exception && console.table))) ||
      // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
  }
  
  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */
  
  exports.formatters.j = function(v) {
    return JSON.stringify(v);
  };
  
  
  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */
  
  function formatArgs() {
    var args = arguments;
    var useColors = this.useColors;
  
    args[0] = (useColors ? '%c' : '')
      + this.namespace
      + (useColors ? ' %c' : ' ')
      + args[0]
      + (useColors ? '%c ' : ' ')
      + '+' + exports.humanize(this.diff);
  
    if (!useColors) return args;
  
    var c = 'color: ' + this.color;
    args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
  
    // the final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-z%]/g, function(match) {
      if ('%%' === match) return;
      index++;
      if ('%c' === match) {
        // we only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });
  
    args.splice(lastC, 0, c);
    return args;
  }
  
  /**
   * Invokes `console.log()` when available.
   * No-op when `console.log` is not a "function".
   *
   * @api public
   */
  
  function log() {
    // this hackery is required for IE8/9, where
    // the `console.log` function doesn't have 'apply'
    return 'object' === typeof console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }
  
  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */
  
  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports.storage.removeItem('debug');
      } else {
        exports.storage.debug = namespaces;
      }
    } catch(e) {}
  }
  
  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */
  
  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch(e) {}
    return r;
  }
  
  /**
   * Enable namespaces listed in `localStorage.debug` initially.
   */
  
  exports.enable(load());
  
  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */
  
  function localstorage(){
    try {
      return window.localStorage;
    } catch (e) {}
  }
  

  return module.exports;
}).call({exports:{}});
_m_['object-assign/index.js#4.1.0']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  /* eslint-disable no-unused-vars */
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  
  function toObject(val) {
  	if (val === null || val === undefined) {
  		throw new TypeError('Object.assign cannot be called with null or undefined');
  	}
  
  	return Object(val);
  }
  
  function shouldUseNative() {
  	try {
  		if (!Object.assign) {
  			return false;
  		}
  
  		// Detect buggy property enumeration order in older V8 versions.
  
  		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
  		var test1 = new String('abc');  // eslint-disable-line
  		test1[5] = 'de';
  		if (Object.getOwnPropertyNames(test1)[0] === '5') {
  			return false;
  		}
  
  		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
  		var test2 = {};
  		for (var i = 0; i < 10; i++) {
  			test2['_' + String.fromCharCode(i)] = i;
  		}
  		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
  			return test2[n];
  		});
  		if (order2.join('') !== '0123456789') {
  			return false;
  		}
  
  		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
  		var test3 = {};
  		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
  			test3[letter] = letter;
  		});
  		if (Object.keys(Object.assign({}, test3)).join('') !==
  				'abcdefghijklmnopqrst') {
  			return false;
  		}
  
  		return true;
  	} catch (e) {
  		// We don't expect any of the above to throw, but better to be safe.
  		return false;
  	}
  }
  
  module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  	var from;
  	var to = toObject(target);
  	var symbols;
  
  	for (var s = 1; s < arguments.length; s++) {
  		from = Object(arguments[s]);
  
  		for (var key in from) {
  			if (hasOwnProperty.call(from, key)) {
  				to[key] = from[key];
  			}
  		}
  
  		if (Object.getOwnPropertySymbols) {
  			symbols = Object.getOwnPropertySymbols(from);
  			for (var i = 0; i < symbols.length; i++) {
  				if (propIsEnumerable.call(from, symbols[i])) {
  					to[symbols[i]] = from[symbols[i]];
  				}
  			}
  		}
  	}
  
  	return to;
  };
  

  return module.exports;
}).call({exports:{}});
_m_['src/lib/router.js']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  /**
   * Router for handling middleware pipeline.
   * Can be isolated under a specific mount path.
   */
  
  var assign = _m_['object-assign/index.js#4.1.0'];
  var Debug = _m_['debug/browser.js#2.2.0'];
  var layer = _m_['src/lib/layer.js'];
  var urlUtils = _m_['@yr/url-utils/index.js#2.3.1'];
  
  var DEFAULT_OPTIONS = {
    mergeParams: true,
    caseSensitive: false,
    strict: false
  };
  
  var debug = Debug('express:router');
  
  /**
   * Instance factory
   * @param {Object} [options]
   * @returns {Router}
   */
  module.exports = function (options) {
    return new Router(options);
  };
  
  var Router = function () {
    /**
     * Constructor
     * @param {Object} [options]
     */
  
    function Router(options) {
      babelHelpers.classCallCheck(this, Router);
  
      options = assign({}, DEFAULT_OPTIONS, options);
  
      var boundMethod = this.method.bind(this);
  
      this.all = boundMethod;
      this.get = boundMethod;
      this.post = boundMethod;
      this.handle = this.handle.bind(this);
      this.stack = [];
      this.mergeParams = options.mergeParams;
      // Init matcher options
      this.matcherOpts = {
        sensitive: options.caseSensitive,
        strict: options.strict,
        end: false
      };
      this.strictMatcherOpts = {
        sensitive: options.caseSensitive,
        strict: options.strict,
        end: true
      };
      this.params = null;
    }
  
    /**
     * Handle param 'name' with 'fn'
     * @param {String} name
     * @param {Function} fn(req, res, next, value)
     */
  
  
    Router.prototype.param = function param(name, fn) {
      if (!this.params) this.params = {};
      this.params[name] = fn;
    };
  
    /**
     * Add one or more 'fn' to middleware pipeline at optional 'path'
     */
  
  
    Router.prototype.use = function use() {
      var _this = this;
  
      var offset = 0;
      var path = '/';
  
      for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
        fns[_key] = arguments[_key];
      }
  
      if ('string' == typeof fns[0]) {
        offset = 1;
        path = fns[0];
      }
  
      fns.slice(offset).forEach(function (fn) {
        if (fn instanceof Router) {
          fn = fn.handle;
        }
        var lyr = layer(path, fn, _this.matcherOpts);
  
        debug('adding router middleware %s with path %s', lyr.name, path);
        _this.stack.push(lyr);
      });
    };
  
    /**
     * Register method at 'path'
     * @param {String} path
     */
  
  
    Router.prototype.method = function method(path) {
      var _this2 = this;
  
      for (var _len2 = arguments.length, fns = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        fns[_key2 - 1] = arguments[_key2];
      }
  
      fns.forEach(function (fn) {
        var lyr = layer(path, fn, _this2.strictMatcherOpts);
  
        lyr.route = true;
  
        debug('adding router route %s with path %s', lyr.name, path);
        _this2.stack.push(lyr);
      });
    };
  
    /**
     * Run request/response through middleware pipline
     * @param {Request} req
     * @param {Response} res
     * @param {Function} done
     */
  
  
    Router.prototype.handle = function handle(req, res, done) {
      var self = this;
      var parentUrl = req.baseUrl || '';
      var idx = 0;
      var processedParams = {};
      var removed = '';
  
      // Update done to restore req props
      done = restore(done, req, 'baseUrl', 'next', 'params');
  
      // Setup next layer
      req.next = next;
      req.baseUrl = parentUrl;
  
      next();
  
      function next(err) {
        var lyr = self.stack[idx++];
        var layerErr = err;
  
        if (removed.length != 0) {
          debug('untrim %s from url %s', removed, req.path);
          req.baseUrl = parentUrl;
          req.path = urlUtils.join(removed, req.path);
          removed = '';
        }
  
        // Exit
        if (!lyr) return done(layerErr);
  
        // Skip if no match or err and route layer
        if (!lyr.match(req.path) || layerErr && !lyr.fastmatch) return next(layerErr);
  
        debug('%s matched layer %s with path %s', req.path, lyr.name, lyr.path);
  
        // Store params
        if (self.mergeParams) {
          if (!req.params) req.params = {};
          assign(req.params, lyr.params);
        } else {
          req.params = lyr.params;
        }
  
        // Process params if necessary
        self._processParams(processedParams, req.params, Object.keys(lyr.params), req, res, function (err) {
          if (err) return next(layerErr || err);
          if (!lyr.route) trim(lyr);
          if (layerErr) {
            lyr.handleError(layerErr, req, res, next);
          } else {
            lyr.handleRequest(req, res, next);
          }
        });
      }
  
      function trim(layer) {
        if (layer.path.length != 0) {
          debug('trim %s from url %s', layer.path, req.path);
          removed = layer.path;
          req.path = req.path.substr(removed.length);
          if (req.path.charAt(0) != '/') req.path = '/' + req.path;
  
          req.baseUrl = urlUtils.join(parentUrl, removed);
        }
      }
    };
  
    /**
     * Process middleware matched parameters
     * @param {Object} processedParams
     * @param {Object} params
     * @param {Array} keys
     * @param {Request} req
     * @param {Response} res
     * @param {Function} done(err)
     */
  
  
    Router.prototype._processParams = function _processParams(processedParams, params, keys, req, res, done) {
      var self = this;
      var idx = 0;
  
      function next(err) {
        // Stop processing on any error
        if (err) return done(err);
  
        if (idx >= keys.length) return done();
  
        var name = keys[idx++];
        var fn = self.params[name];
  
        // Process if match and not already processed
        if (fn && !processedParams[name]) {
          processedParams[name] = true;
          fn(req, res, next, params[name]);
        } else {
          next();
        }
      }
  
      if (this.params && keys.length) {
        next();
      } else {
        done();
      }
    };
  
    return Router;
  }();
  
  /**
   * Restore 'obj' props
   * @param {Function} fn
   * @param {Object} obj
   * @returns {Function}
   */
  
  
  function restore(fn, obj) {
    var props = new Array(arguments.length - 2);
    var vals = new Array(arguments.length - 2);
  
    for (var i = 0; i < props.length; i++) {
      props[i] = arguments[i + 2];
      vals[i] = obj[props[i]];
    }
  
    return function () {
      // Restore vals
      for (var _i = 0; _i < props.length; _i++) {
        obj[props[_i]] = vals[_i];
      }
  
      return fn.apply(this, arguments);
    };
  }

  return module.exports;
}).call({exports:{}});
_m_['eventemitter3/index.js#1.2.0']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  var has = Object.prototype.hasOwnProperty;
  
  //
  // We store our EE objects in a plain object whose properties are event names.
  // If `Object.create(null)` is not supported we prefix the event names with a
  // `~` to make sure that the built-in object properties are not overridden or
  // used as an attack vector.
  // We also assume that `Object.create(null)` is available when the event name
  // is an ES6 Symbol.
  //
  var prefix = typeof Object.create !== 'function' ? '~' : false;
  
  /**
   * Representation of a single EventEmitter function.
   *
   * @param {Function} fn Event handler to be called.
   * @param {Mixed} context Context for function execution.
   * @param {Boolean} [once=false] Only emit once
   * @api private
   */
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  
  /**
   * Minimal EventEmitter interface that is molded against the Node.js
   * EventEmitter interface.
   *
   * @constructor
   * @api public
   */
  function EventEmitter() { /* Nothing to set */ }
  
  /**
   * Hold the assigned EventEmitters by name.
   *
   * @type {Object}
   * @private
   */
  EventEmitter.prototype._events = undefined;
  
  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   *
   * @returns {Array}
   * @api public
   */
  EventEmitter.prototype.eventNames = function eventNames() {
    var events = this._events
      , names = []
      , name;
  
    if (!events) return names;
  
    for (name in events) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }
  
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
  
    return names;
  };
  
  /**
   * Return a list of assigned event listeners.
   *
   * @param {String} event The events that should be listed.
   * @param {Boolean} exists We only need to know if there are listeners.
   * @returns {Array|Boolean}
   * @api public
   */
  EventEmitter.prototype.listeners = function listeners(event, exists) {
    var evt = prefix ? prefix + event : event
      , available = this._events && this._events[evt];
  
    if (exists) return !!available;
    if (!available) return [];
    if (available.fn) return [available.fn];
  
    for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
      ee[i] = available[i].fn;
    }
  
    return ee;
  };
  
  /**
   * Emit an event to all registered event listeners.
   *
   * @param {String} event The name of the event.
   * @returns {Boolean} Indication if we've emitted an event.
   * @api public
   */
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
  
    if (!this._events || !this._events[evt]) return false;
  
    var listeners = this._events[evt]
      , len = arguments.length
      , args
      , i;
  
    if ('function' === typeof listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
  
      switch (len) {
        case 1: return listeners.fn.call(listeners.context), true;
        case 2: return listeners.fn.call(listeners.context, a1), true;
        case 3: return listeners.fn.call(listeners.context, a1, a2), true;
        case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
  
      for (i = 1, args = new Array(len -1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
  
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length
        , j;
  
      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
  
        switch (len) {
          case 1: listeners[i].fn.call(listeners[i].context); break;
          case 2: listeners[i].fn.call(listeners[i].context, a1); break;
          case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
          default:
            if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
  
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
  
    return true;
  };
  
  /**
   * Register a new EventListener for the given event.
   *
   * @param {String} event Name of the event.
   * @param {Function} fn Callback function.
   * @param {Mixed} [context=this] The context of the function.
   * @api public
   */
  EventEmitter.prototype.on = function on(event, fn, context) {
    var listener = new EE(fn, context || this)
      , evt = prefix ? prefix + event : event;
  
    if (!this._events) this._events = prefix ? {} : Object.create(null);
    if (!this._events[evt]) this._events[evt] = listener;
    else {
      if (!this._events[evt].fn) this._events[evt].push(listener);
      else this._events[evt] = [
        this._events[evt], listener
      ];
    }
  
    return this;
  };
  
  /**
   * Add an EventListener that's only called once.
   *
   * @param {String} event Name of the event.
   * @param {Function} fn Callback function.
   * @param {Mixed} [context=this] The context of the function.
   * @api public
   */
  EventEmitter.prototype.once = function once(event, fn, context) {
    var listener = new EE(fn, context || this, true)
      , evt = prefix ? prefix + event : event;
  
    if (!this._events) this._events = prefix ? {} : Object.create(null);
    if (!this._events[evt]) this._events[evt] = listener;
    else {
      if (!this._events[evt].fn) this._events[evt].push(listener);
      else this._events[evt] = [
        this._events[evt], listener
      ];
    }
  
    return this;
  };
  
  /**
   * Remove event listeners.
   *
   * @param {String} event The event we want to remove.
   * @param {Function} fn The listener that we need to find.
   * @param {Mixed} context Only remove listeners matching this context.
   * @param {Boolean} once Only remove once listeners.
   * @api public
   */
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
  
    if (!this._events || !this._events[evt]) return this;
  
    var listeners = this._events[evt]
      , events = [];
  
    if (fn) {
      if (listeners.fn) {
        if (
             listeners.fn !== fn
          || (once && !listeners.once)
          || (context && listeners.context !== context)
        ) {
          events.push(listeners);
        }
      } else {
        for (var i = 0, length = listeners.length; i < length; i++) {
          if (
               listeners[i].fn !== fn
            || (once && !listeners[i].once)
            || (context && listeners[i].context !== context)
          ) {
            events.push(listeners[i]);
          }
        }
      }
    }
  
    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) {
      this._events[evt] = events.length === 1 ? events[0] : events;
    } else {
      delete this._events[evt];
    }
  
    return this;
  };
  
  /**
   * Remove all listeners or only the listeners for the specified event.
   *
   * @param {String} event The event want to remove all listeners for.
   * @api public
   */
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    if (!this._events) return this;
  
    if (event) delete this._events[prefix ? prefix + event : event];
    else this._events = prefix ? {} : Object.create(null);
  
    return this;
  };
  
  //
  // Alias methods names because people roll like that.
  //
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  
  //
  // This function doesn't apply anymore.
  //
  EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
    return this;
  };
  
  //
  // Expose the prefix.
  //
  EventEmitter.prefixed = prefix;
  
  //
  // Expose the module.
  //
  if ('undefined' !== typeof module) {
    module.exports = EventEmitter;
  }
  

  return module.exports;
}).call({exports:{}});
_m_['cookie/index.js#0.2.4']=(function(module,exports){
  module=this;exports=module.exports;

  /*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  
  'use strict';
  
  /**
   * Module exports.
   * @public
   */
  
  exports.parse = parse;
  exports.serialize = serialize;
  
  /**
   * Module variables.
   * @private
   */
  
  var decode = decodeURIComponent;
  var encode = encodeURIComponent;
  var pairSplitRegExp = /; */;
  
  /**
   * RegExp to match field-content in RFC 7230 sec 3.2
   *
   * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
   * field-vchar   = VCHAR / obs-text
   * obs-text      = %x80-FF
   */
  
  var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
  
  /**
   * Parse a cookie header.
   *
   * Parse the given cookie header string into an object
   * The object has the various cookies as keys(names) => values
   *
   * @param {string} str
   * @param {object} [options]
   * @return {object}
   * @public
   */
  
  function parse(str, options) {
    if (typeof str !== 'string') {
      throw new TypeError('argument str must be a string');
    }
  
    var obj = {}
    var opt = options || {};
    var pairs = str.split(pairSplitRegExp);
    var dec = opt.decode || decode;
  
    for (var i = 0; i < pairs.length; i++) {
      var pair = pairs[i];
      var eq_idx = pair.indexOf('=');
  
      // skip things that don't look like key=value
      if (eq_idx < 0) {
        continue;
      }
  
      var key = pair.substr(0, eq_idx).trim()
      var val = pair.substr(++eq_idx, pair.length).trim();
  
      // quoted values
      if ('"' == val[0]) {
        val = val.slice(1, -1);
      }
  
      // only assign once
      if (undefined == obj[key]) {
        obj[key] = tryDecode(val, dec);
      }
    }
  
    return obj;
  }
  
  /**
   * Serialize data into a cookie header.
   *
   * Serialize the a name value pair into a cookie string suitable for
   * http headers. An optional options object specified cookie parameters.
   *
   * serialize('foo', 'bar', { httpOnly: true })
   *   => "foo=bar; httpOnly"
   *
   * @param {string} name
   * @param {string} val
   * @param {object} [options]
   * @return {string}
   * @public
   */
  
  function serialize(name, val, options) {
    var opt = options || {};
    var enc = opt.encode || encode;
  
    if (!fieldContentRegExp.test(name)) {
      throw new TypeError('argument name is invalid');
    }
  
    var value = enc(val);
  
    if (value && !fieldContentRegExp.test(value)) {
      throw new TypeError('argument val is invalid');
    }
  
    var str = name + '=' + value;
  
    if (null != opt.maxAge) {
      var maxAge = opt.maxAge - 0;
      if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
      str += '; Max-Age=' + Math.floor(maxAge);
    }
  
    if (opt.domain) {
      if (!fieldContentRegExp.test(opt.domain)) {
        throw new TypeError('option domain is invalid');
      }
  
      str += '; Domain=' + opt.domain;
    }
  
    if (opt.path) {
      if (!fieldContentRegExp.test(opt.path)) {
        throw new TypeError('option path is invalid');
      }
  
      str += '; Path=' + opt.path;
    }
  
    if (opt.expires) {
      str += '; Expires=' + opt.expires.toUTCString();
    }
  
    if (opt.httpOnly) {
      str += '; HttpOnly';
    }
  
    if (opt.secure) {
      str += '; Secure';
    }
  
    if (opt.firstPartyOnly) {
      str += '; First-Party-Only';
    }
  
    return str;
  }
  
  /**
   * Try decoding a string using a decoding function.
   *
   * @param {string} str
   * @param {function} decode
   * @private
   */
  
  function tryDecode(str, decode) {
    try {
      return decode(str);
    } catch (e) {
      return str;
    }
  }
  

  return module.exports;
}).call({exports:{}});
_m_['src/lib/response.js']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  /**
   * Browser response object
   */
  
  var assign = _m_['object-assign/index.js#4.1.0'];
  var _cookie = _m_['cookie/index.js#0.2.4'];
  var Emitter = _m_['eventemitter3/index.js#1.2.0'];
  
  /**
   * Instance factory
   * @returns {Response}
   */
  module.exports = function () {
    return new Response();
  };
  
  var Response = function (_Emitter) {
    babelHelpers.inherits(Response, _Emitter);
  
    /**
     * Constructor
     */
  
    function Response() {
      babelHelpers.classCallCheck(this, Response);
  
      var _this = babelHelpers.possibleConstructorReturn(this, _Emitter.call(this));
  
      _this.app = null;
      _this.req = null;
      _this.reset();
      return _this;
    }
  
    /**
     * Reset state
     */
  
  
    Response.prototype.reset = function reset() {
      this.cached = false;
      this.finished = false;
      this.locals = {};
      this.statusCode = 404;
    };
  
    /**
     * Set status 'code'
     * @param {Number} code
     * @returns {Response}
     */
  
  
    Response.prototype.status = function status(code) {
      this.statusCode = code;
      return this;
    };
  
    /**
     * Send response (last method called in pipeline)
     */
  
  
    Response.prototype.send = function send() {
      // Reset state
      this.req.reset();
      this.status(200);
      this.finished = true;
      this.emit('finish');
    };
  
    /**
     * Redirect to 'url'
     * @param {Number} statusCode
     * @param {String} url
     */
  
  
    Response.prototype.redirect = function redirect(statusCode, url) {
      this.app.redirectTo(url || statusCode);
    };
  
    /**
     * Set cookie
     * @param {String} name
     * @param {String|Object} val
     * @param {Object} options
     * @returns {Response}
     */
  
  
    Response.prototype.cookie = function cookie(name, val, options) {
      // Clone
      options = assign({}, options);
  
      if ('number' == typeof val) val = val.toString();
      if ('object' == typeof val) val = 'j:' + JSON.stringify(val);
  
      if ('maxAge' in options) {
        options.expires = new Date(Date.now() + options.maxAge);
        options.maxAge /= 1000;
      }
  
      if (options.path == null) options.path = '/';
  
      document.cookie = _cookie.serialize(name, String(val), options);
  
      return this;
    };
  
    return Response;
  }(Emitter);

  return module.exports;
}).call({exports:{}});
_m_['strict-uri-encode/index.js#1.1.0']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  module.exports = function (str) {
  	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
  		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  	});
  };
  

  return module.exports;
}).call({exports:{}});
_m_['query-string/index.js#4.1.0']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  var strictUriEncode = _m_['strict-uri-encode/index.js#1.1.0'];
  
  function encode(value, strict) {
  	return strict ? strictUriEncode(value) : encodeURIComponent(value);
  }
  
  exports.extract = function (str) {
  	return str.split('?')[1] || '';
  };
  
  exports.parse = function (str) {
  	// Create an object with no prototype
  	// https://github.com/sindresorhus/query-string/issues/47
  	var ret = Object.create(null);
  
  	if (typeof str !== 'string') {
  		return ret;
  	}
  
  	str = str.trim().replace(/^(\?|#|&)/, '');
  
  	if (!str) {
  		return ret;
  	}
  
  	str.split('&').forEach(function (param) {
  		var parts = param.replace(/\+/g, ' ').split('=');
  		// Firefox (pre 40) decodes `%3D` to `=`
  		// https://github.com/sindresorhus/query-string/pull/37
  		var key = parts.shift();
  		var val = parts.length > 0 ? parts.join('=') : undefined;
  
  		key = decodeURIComponent(key);
  
  		// missing `=` should be `null`:
  		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
  		val = val === undefined ? null : decodeURIComponent(val);
  
  		if (ret[key] === undefined) {
  			ret[key] = val;
  		} else if (Array.isArray(ret[key])) {
  			ret[key].push(val);
  		} else {
  			ret[key] = [ret[key], val];
  		}
  	});
  
  	return ret;
  };
  
  exports.stringify = function (obj, opts) {
  	opts = opts || {};
  
  	var strict = opts.strict !== false;
  
  	return obj ? Object.keys(obj).sort().map(function (key) {
  		var val = obj[key];
  
  		if (val === undefined) {
  			return '';
  		}
  
  		if (val === null) {
  			return key;
  		}
  
  		if (Array.isArray(val)) {
  			var result = [];
  
  			val.slice().sort().forEach(function (val2) {
  				if (val2 === undefined) {
  					return;
  				}
  
  				if (val2 === null) {
  					result.push(encode(key, strict));
  				} else {
  					result.push(encode(key, strict) + '=' + encode(val2, strict));
  				}
  			});
  
  			return result.join('&');
  		}
  
  		return encode(key, strict) + '=' + encode(val, strict);
  	}).filter(function (x) {
  		return x.length > 0;
  	}).join('&') : '';
  };
  

  return module.exports;
}).call({exports:{}});
_m_['src/lib/request.js']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  /**
   * Browser request object
   */
  
  var cookie = _m_['cookie/index.js#0.2.4'];
  var Emitter = _m_['eventemitter3/index.js#1.2.0'];
  var qsParse = _m_['query-string/index.js#4.1.0'].parse;
  var urlUtils = _m_['@yr/url-utils/index.js#2.3.1'];
  
  var RE_SPLIT = /[?#]/;
  
  /**
   * Instance factory
   * @param {String} url
   * @param {Boolean} bootstrap
   * @returns {Request}
   */
  module.exports = function (url, bootstrap) {
    return new Request(url, bootstrap);
  };
  
  var Request = function (_Emitter) {
    babelHelpers.inherits(Request, _Emitter);
  
    /**
     * Constructor
     * @param {String} url
     * @param {Boolean} bootstrap
     */
  
    function Request(url, bootstrap) {
      babelHelpers.classCallCheck(this, Request);
  
      var _this = babelHelpers.possibleConstructorReturn(this, _Emitter.call(this));
  
      url = url ? urlUtils.encode(url) : urlUtils.getCurrent();
  
      var path = url.split(RE_SPLIT);
      var qs = ~url.indexOf('?') && path[1] || '';
      var hash = ~url.indexOf('#') && path[path.length - 1] || '';
  
      _this.app = null;
      _this.cookies = cookie.parse(document.cookie);
      _this.path = urlUtils.sanitize(path[0]);
      _this.hash = qsParse(hash);
      _this.query = qsParse(qs);
      _this.querystring = qs;
      _this.search = qs ? '?' + qs : '';
      // Ignore hash
      _this.url = _this.originalUrl = url.split('#')[0];
      _this.reset(bootstrap);
      return _this;
    }
  
    /**
     * Abort response
     */
  
  
    Request.prototype.abort = function abort() {
      this.reset();
      this.emit('close');
    };
  
    /**
     * Reset state
     * @param {Boolean} bootstrap
     */
  
  
    Request.prototype.reset = function reset(bootstrap) {
      this.baseUrl = '';
      this.bootstrap = bootstrap || false;
      this.cached = false;
      this.path = urlUtils.sanitize(this.originalUrl.split('?')[0]);
      this.params = null;
    };
  
    return Request;
  }(Emitter);

  return module.exports;
}).call({exports:{}});
_m_['src/lib/history.js']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  /**
   * Manager for browser history.
   * Generates/stores request/response context for current url,
   * and responds to changes to state via History API.
   */
  
  var Debug = _m_['debug/browser.js#2.2.0'];
  var urlUtils = _m_['@yr/url-utils/index.js#2.3.1'];
  
  var debug = Debug('express:history');
  var bootstrap = true;
  
  /**
   * Instance factory
   * @param {Function} request
   * @param {Function} response
   * @param {Function} fn(req, res)
   * @returns {History}
   */
  module.exports = function (request, response, fn) {
    return new History(request, response, fn);
  };
  
  var History = function () {
    /**
     * Constructor
     * @param {Function} request(url)
     * @param {Function} response
     * @param {Function} fn(req, res)
     */
  
    function History(request, response, fn) {
      babelHelpers.classCallCheck(this, History);
  
      this.cache = {};
      this.current = '';
      this.running = false;
      this.request = request;
      this.response = response;
      this.fn = fn;
      this.onClick = this.onClick.bind(this);
      this.onPopstate = this.onPopstate.bind(this);
      this.navigateTo = this.navigateTo.bind(this);
      this.redirectTo = this.redirectTo.bind(this);
      this.getCurrentContext = this.getCurrentContext.bind(this);
    }
  
    /**
     * Notify on current context,
     * and begin listening for history changes
     * @returns {History}
     */
  
  
    History.prototype.listen = function listen() {
      var _this = this;
  
      // Handle current history state (triggers notification)
      var ctx = this.handle();
  
      if (!this.running && ctx) {
        // Test History API availability
        if (hasHistory()) {
          // Delay to prevent premature trigger when navigating back from nothing
          setTimeout(function () {
            window.addEventListener('click', _this.onClick, false);
            window.addEventListener('popstate', _this.onPopstate, false);
            _this.running = true;
          }, 500);
  
          // Update so that popstate will trigger for this route
          window.history.replaceState({}, document.title);
  
          debug('listening with history API');
        }
      }
  
      return this;
    };
  
    /**
     * Create a new or updated history state at 'url' with 'title'
     * @param {String} url
     * @param {String} title
     * @param {Boolean} isUpdate
     * @param {Boolean} noScroll
     */
  
  
    History.prototype.navigateTo = function navigateTo(url, title, isUpdate, noScroll) {
      // Only navigate if not same as current
      if (url != urlUtils.getCurrent()) {
        if (this.running) {
          // Will return empty if malformed
          url = urlUtils.encode(url);
          if (!url) return;
  
          debug('navigate to: %s', url);
  
          window.history[isUpdate ? 'replaceState' : 'pushState']({}, title, url);
          if (title) document.title = title;
          this.handle(url, noScroll);
        } else {
          this.redirectTo(url);
        }
      }
    };
  
    /**
     * Stop history management by redirecting to 'url'
     * @param {String} url
     */
  
  
    History.prototype.redirectTo = function redirectTo(url) {
      this.destroy();
      window.location = urlUtils.encode(url);
    };
  
    /**
     * Force a re-handle of current context
     */
  
  
    History.prototype.refresh = function refresh() {
      var ctx = this.getCurrentContext();
  
      // Undo pipeline modifications
      ctx.req.reset();
      ctx.res.reset();
      this.fn(ctx.req, ctx.res);
    };
  
    /**
     * Retrieve current context
     * @returns {Object}
     */
  
  
    History.prototype.getCurrentContext = function getCurrentContext() {
      return this.cache[this.current];
    };
  
    /**
     * Stop listening for history updates
     */
  
  
    History.prototype.destroy = function destroy() {
      if (this.running) {
        window.removeEventListener('click', this.onClick, false);
        window.removeEventListener('popstate', this.onPopstate, false);
        this.cache = null;
        this.running = false;
      }
    };
  
    /**
     * Handle history change and notify
     * @param {String} [url]
     * @param {Boolean} [noScroll]
     * @returns {Object}
     */
  
  
    History.prototype.handle = function handle(url, noScroll) {
      var ctx = {};
      var req = void 0,
          res = void 0;
  
      url = url ? urlUtils.encode(url) : urlUtils.getCurrent();
      // Error encoding url
      if (!url) return this.redirectTo(url);
  
      // Do nothing if current url is the same
      if (this.current && this.current === url) return;
  
      if (this.cache[url]) {
        ctx = this.cache[url];
        req = ctx.req;
        res = ctx.res;
        // Always reset in order to undo pipeline modifications
        req.reset();
        res.reset();
        // Set flag for use downstream
        req.cached = res.cached = true;
        debug('context retrieved from cache: %s', url);
      } else {
        req = this.request(url, bootstrap);
        res = this.response();
        debug('generating new context: %s', url);
      }
      res.req = req;
      ctx.req = req;
      ctx.res = res;
      this.cache[url] = ctx;
  
      // Abort if current request/response is not finished
      if (this.current && !this.cache[this.current].res.finished) {
        this.cache[this.current].req.abort();
        this.cache[this.current].res.reset();
      }
  
      // Store reference to current
      this.current = url;
  
      // Set scroll position to top if not bootstrap or overridden
      if (!bootstrap && !noScroll) window.scrollTo(0, 0);
  
      this.fn(req, res);
  
      // Make sure only first request flagged as bootstrap
      bootstrap = false;
  
      return ctx;
    };
  
    /**
     * Handle history change via 'popstate' event
     * @param {Object} evt
     */
  
  
    History.prototype.onPopstate = function onPopstate(evt) {
      // Prevent initial page load from triggering on some platforms when no state
      if (evt.state && this.running) {
        this.handle();
      }
    };
  
    /**
     * Handle click event
     * @param {Object} evt
     * @returns {null}
     */
  
  
    History.prototype.onClick = function onClick(evt) {
      var which = null == evt.which ? evt.button : evt.which;
      var el = evt.target;
  
      // Modifiers present
      if (which != 1) return;
      if (evt.metaKey || evt.ctrlKey || evt.shiftKey) return;
      if (evt.defaultPrevented) return;
  
      // Find anchor
      // svg elements on some platforms don't have nodeNames
      while (el && (el.nodeName == null || 'A' != el.nodeName.toUpperCase())) {
        el = el.parentNode;
      }
  
      // Anchor not found
      if (!el || 'A' != el.nodeName.toUpperCase()) return;
  
      // Cross origin
      if (!sameOrigin(el.href)) return this.fn(el.href);
  
      // IE11 prefixes extra slash on absolute links
      var path = (el.pathname + el.search).replace(/\/\//, '/');
      var isSameAsCurrent = path == urlUtils.getCurrent();
  
      // Anchor target on same page
      if (isSameAsCurrent && 'string' == typeof el.hash && el.hash) return;
  
      evt.preventDefault();
  
      // Same as current
      if (isSameAsCurrent) return;
  
      // Blur focus
      el.blur();
  
      debug('click event intercepted from %s', el);
      this.navigateTo(path);
    };
  
    return History;
  }();
  
  /**
   * Test for history API (Modernizr)
   * @returns {Boolean}
   */
  
  
  function hasHistory() {
    var ua = navigator.userAgent;
  
    // Stock android browser 2.2 & 2.3 & 4.0.x are buggy, ignore
    if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
    // Chrome identifies itself as 'Mobile Safari'
    ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
      return false;
    }
  
    // Usual test
    return window.history && 'pushState' in window.history;
  }
  
  /**
   * Check if 'url' is from same origin
   * @param {String} url
   * @returns {Boolean}
   */
  function sameOrigin(url) {
    var origin = location.protocol + '//' + location.hostname;
  
    if (location.port) origin += ':' + location.port;
    return url && url.indexOf(origin) == 0;
  }

  return module.exports;
}).call({exports:{}});
_m_['src/lib/application.js']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  /**
   * Browser application
   */
  
  var Debug = _m_['debug/browser.js#2.2.0'];
  var Emitter = _m_['eventemitter3/index.js#1.2.0'];
  var history = _m_['src/lib/history.js'];
  var request = _m_['src/lib/request.js'];
  var response = _m_['src/lib/response.js'];
  var router = _m_['src/lib/router.js'];
  
  var debug = Debug('express:application');
  
  /**
   * Instance factory
   * @returns {Application}
   */
  module.exports = function () {
    return new Application();
  };
  
  var Application = function (_Emitter) {
    babelHelpers.inherits(Application, _Emitter);
  
    /**
     * Constructor
     */
  
    function Application() {
      babelHelpers.classCallCheck(this, Application);
  
      var _this = babelHelpers.possibleConstructorReturn(this, _Emitter.call(this));
  
      _this.settings = {
        env: undefined || 'development'
      };
      _this.cache = {};
      _this.locals = {};
      _this.mountpath = '/';
      _this._router = router({
        caseSensitive: false,
        strict: false,
        mergeParams: true
      });
      _this.parent = null;
  
      _this.handle = _this.handle.bind(_this);
      _this.navigateTo = _this.navigateTo.bind(_this);
      _this.redirectTo = _this.redirectTo.bind(_this);
      _this.getCurrentContext = _this.getCurrentContext.bind(_this);
      _this.refresh = _this.refresh.bind(_this);
  
      // Create request/response factories
      var app = _this;
      var req = function req(url, bootstrap) {
        var req = request(url, bootstrap);
  
        req.app = app;
        return req;
      };
      var res = function res() {
        var res = response();
  
        res.app = app;
        return res;
      };
  
      _this.history = history(req, res, _this.handle);
  
      // Route ALL/POST methods to router
      _this.all = _this._router.all.bind(_this._router);
      _this.post = _this._router.post.bind(_this._router);
      return _this;
    }
  
    /**
     * Store 'value' for 'key'
     * @param {String} key
     * @param {Object} value
     * @returns {Object}
     */
  
  
    Application.prototype.set = function set(key, value) {
      // get()
      if (arguments.length == 1) return this.settings[key];
  
      this.settings[key] = value;
    };
  
    /**
     * Add one or more 'fn' to middleware pipeline at optional 'path'
     */
  
  
    Application.prototype.use = function use() {
      var _this2 = this;
  
      var offset = 0;
      var path = '/';
  
      for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
        fns[_key] = arguments[_key];
      }
  
      if ('string' == typeof fns[0]) {
        offset = 1;
        path = fns[0];
      }
  
      fns.slice(offset).forEach(function (fn) {
        if (fn instanceof Application) {
          (function () {
            var app = fn;
            var handler = app.handle;
  
            app.mountpath = path;
            app.parent = _this2;
            fn = function mounted_app(req, res, next) {
              // Change app reference to mounted
              var orig = req.app;
  
              req.app = res.app = app;
              handler(req, res, function (err) {
                // Restore app reference when done
                req.app = res.app = orig;
                next(err);
              });
            };
          })();
        }
  
        debug('adding application middleware layer with path %s', path);
        _this2._router.use(path, fn);
      });
    };
  
    /**
     * Add GET at 'path' with strict matching of path
     * @param {String} path
     * @returns {Object}
     */
  
  
    Application.prototype.get = function get(path) {
      var _router;
  
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
  
      // Not verb, only get/set
      if (!args.length) return this.set(path);
  
      (_router = this._router).get.apply(_router, [path].concat(args));
  
      return this;
    };
  
    /**
     * Handle param 'name' with 'fn'
     * @param {String} name
     * @param {Function} fn(req, res, next, value)
     */
  
  
    Application.prototype.param = function param(name, fn) {
      this._router.param(name, fn);
    };
  
    /**
     * Start listening for requests
     */
  
  
    Application.prototype.listen = function listen() {
      if (!this.parent) this.history.listen();
    };
  
    /**
     * Run request/response through router's middleware pipline
     * @param {Request} req
     * @param {Response} res
     * @param {Function} done
     */
  
  
    Application.prototype.handle = function handle(req, res, done) {
      // Handle external link
      if ('string' == typeof req) {
        this.emit('link:external', req);
      } else {
        this.emit('connect', req);
        this._router.handle(req, res, done || function () {});
      }
    };
  
    /**
     * Change/update browser history state
     * @param {String} url
     * @param {String} title
     * @param {Boolean} isUpdate
     * @param {Boolean} noScroll
     */
  
  
    Application.prototype.navigateTo = function navigateTo(url, title, isUpdate, noScroll) {
      this[this.parent ? 'parent' : 'history'].navigateTo(url, title, isUpdate, noScroll);
    };
  
    /**
     * Force browser location change
     * @param {String} url
     * @param {String} title
     */
  
  
    Application.prototype.redirectTo = function redirectTo(url) {
      this[this.parent ? 'parent' : 'history'].redirectTo(url);
    };
  
    /**
     * Retrieve current context
     * @returns {Object}
     */
  
  
    Application.prototype.getCurrentContext = function getCurrentContext() {
      return this[this.parent ? 'parent' : 'history'].getCurrentContext();
    };
  
    /**
     * Refresh current location
     */
  
  
    Application.prototype.refresh = function refresh() {
      this[this.parent ? 'parent' : 'history'].refresh();
    };
  
    return Application;
  }(Emitter);

  return module.exports;
}).call({exports:{}});
_m_['src/index.js']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  /**
   * An express.js framework for the browser
   * https://github.com/yr/express-client
   * @copyright Yr
   * @license MIT
   */
  
  var application = _m_['src/lib/application.js'];
  var Router = _m_['src/lib/router.js'];
  
  /**
   * Application factory
   * @returns {Application}
   */
  module.exports = function createApplication() {
    return application();
  };
  
  /**
   * Expose
   */
  module.exports.Router = Router;

  return module.exports;
}).call({exports:{}});