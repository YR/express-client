/* generated by Buddy 3.0.0-beta-1 */

(function(root) {
	// Load or return cached version of requested module with id 'path' or 'path/index'
	// @param {String} path
	// @return {Object}
	function require (path) {
		// Convert relative path to absolute for cases where 'require' has not been resolved
		// For example, called from outside of a module
		if (!this.module && path.charAt(0) == '.') {
			path = path.slice((path.indexOf('..') === 0) ? 3 : 2);
		}
		// Find in cache
		var m = require.modules[path] || require.modules[path + '/index'];
		if (!m) {
			// Handle versioned modules when called without version number
			var p, p2, idx;
			for (var p in require.modules) {
				if ((idx = p.indexOf('@')) != -1) {
					p2 = p.slice(0, idx);
					if (path == p2) {
						m = require.modules[p];
						break;
					}
				}
			}
			if (!m) throw "Couldn't find module for: " + path;
		}
		// Instantiate the module if it's export object is not yet defined
		if (!m.exports) {
			// Convert 'lazy' evaluated string to Function
			if ('string' == typeof m) {
				m = require.modules[path] = new Function('module', 'exports', 'require', m);
			}
			m.exports = {};
			m.filename = path;
			m.call(this, m, m.exports, require.relative(path));
		}
		// Return the exports object
		return m.exports;
	}

	// Cache of module objects
	require.modules = {};

	// Resolve 'to' an absolute path
	// @param {String} curr
	// @param {String} path
	// @return {String}
	require.resolve = function(from, to) {
		var fromSegs = from.split('/')
			, seg;

		// Non relative path
		if (to.charAt(0) != '.') return to;

		// Don't strip root paths (handled specially in require())
		if (fromSegs.length > 1) fromSegs.pop();
		to = to.split('/');
		// Use 'from' path segments to resolve relative 'to' path
		for (var i = 0; i < to.length; ++i) {
			seg = to[i];
			if (seg == '..') {
				fromSegs.pop();
			} else if (seg != '.') {
				fromSegs.push(seg);
			}
		}
		return fromSegs.join('/');
	};

	// Partial completion of the module's inner 'require' function
	// @param {String} path
	// @return {Object}
	require.relative = function(path) {
		return function(p) {
			return require(require.resolve(path, p));
		};
	};

	// Register a module with id of 'path' and callback of 'fn'
	// @param {String} path
	// @param {Function} fn [signature should be of type (module, exports, require)]
	require.register = function(path, fn) {
		require.modules[path] = fn;
	};

	// Expose
	root.require = require;
})((typeof window !== 'undefined') ? window : global);
require.register('isarray#0.0.1', function(module, exports, require) {
  module.exports = Array.isArray || function (arr) {
    return Object.prototype.toString.call(arr) == '[object Array]';
  };
  
});
require.register('path-to-regexp#1.2.0', function(module, exports, require) {
  var isarray = require('isarray#0.0.1')
  
  /**
   * Expose `pathToRegexp`.
   */
  module.exports = pathToRegexp
  module.exports.parse = parse
  module.exports.compile = compile
  module.exports.tokensToFunction = tokensToFunction
  module.exports.tokensToRegExp = tokensToRegExp
  
  /**
   * The main path matching regexp utility.
   *
   * @type {RegExp}
   */
  var PATH_REGEXP = new RegExp([
    // Match escaped characters that would otherwise appear in future matches.
    // This allows the user to escape special characters that won't transform.
    '(\\\\.)',
    // Match Express-style parameters and un-named parameters with a prefix
    // and optional suffixes. Matches appear as:
    //
    // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
    // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
    // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
    '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))'
  ].join('|'), 'g')
  
  /**
   * Parse a string for the raw tokens.
   *
   * @param  {String} str
   * @return {Array}
   */
  function parse (str) {
    var tokens = []
    var key = 0
    var index = 0
    var path = ''
    var res
  
    while ((res = PATH_REGEXP.exec(str)) != null) {
      var m = res[0]
      var escaped = res[1]
      var offset = res.index
      path += str.slice(index, offset)
      index = offset + m.length
  
      // Ignore already escaped sequences.
      if (escaped) {
        path += escaped[1]
        continue
      }
  
      // Push the current path onto the tokens.
      if (path) {
        tokens.push(path)
        path = ''
      }
  
      var prefix = res[2]
      var name = res[3]
      var capture = res[4]
      var group = res[5]
      var suffix = res[6]
      var asterisk = res[7]
  
      var repeat = suffix === '+' || suffix === '*'
      var optional = suffix === '?' || suffix === '*'
      var delimiter = prefix || '/'
      var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')
  
      tokens.push({
        name: name || key++,
        prefix: prefix || '',
        delimiter: delimiter,
        optional: optional,
        repeat: repeat,
        pattern: escapeGroup(pattern)
      })
    }
  
    // Match any characters still remaining.
    if (index < str.length) {
      path += str.substr(index)
    }
  
    // If the path exists, push it onto the end.
    if (path) {
      tokens.push(path)
    }
  
    return tokens
  }
  
  /**
   * Compile a string to a template function for the path.
   *
   * @param  {String}   str
   * @return {Function}
   */
  function compile (str) {
    return tokensToFunction(parse(str))
  }
  
  /**
   * Expose a method for transforming tokens into the path function.
   */
  function tokensToFunction (tokens) {
    // Compile all the tokens into regexps.
    var matches = new Array(tokens.length)
  
    // Compile all the patterns before compilation.
    for (var i = 0; i < tokens.length; i++) {
      if (typeof tokens[i] === 'object') {
        matches[i] = new RegExp('^' + tokens[i].pattern + '$')
      }
    }
  
    return function (obj) {
      var path = ''
  
      obj = obj || {}
  
      for (var i = 0; i < tokens.length; i++) {
        var key = tokens[i]
  
        if (typeof key === 'string') {
          path += key
  
          continue
        }
  
        var value = obj[key.name]
  
        if (value == null) {
          if (key.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + key.name + '" to be defined')
          }
        }
  
        if (isarray(value)) {
          if (!key.repeat) {
            throw new TypeError('Expected "' + key.name + '" to not repeat')
          }
  
          if (value.length === 0) {
            if (key.optional) {
              continue
            } else {
              throw new TypeError('Expected "' + key.name + '" to not be empty')
            }
          }
  
          for (var j = 0; j < value.length; j++) {
            if (!matches[i].test(value[j])) {
              throw new TypeError('Expected all "' + key.name + '" to match "' + key.pattern + '"')
            }
  
            path += (j === 0 ? key.prefix : key.delimiter) + encodeURIComponent(value[j])
          }
  
          continue
        }
  
        if (!matches[i].test(value)) {
          throw new TypeError('Expected "' + key.name + '" to match "' + key.pattern + '"')
        }
  
        path += key.prefix + encodeURIComponent(value)
      }
  
      return path
    }
  }
  
  /**
   * Escape a regular expression string.
   *
   * @param  {String} str
   * @return {String}
   */
  function escapeString (str) {
    return str.replace(/([.+*?=^!:${}()[\]|\/])/g, '\\$1')
  }
  
  /**
   * Escape the capturing group by escaping special characters and meaning.
   *
   * @param  {String} group
   * @return {String}
   */
  function escapeGroup (group) {
    return group.replace(/([=!:$\/()])/g, '\\$1')
  }
  
  /**
   * Attach the keys as a property of the regexp.
   *
   * @param  {RegExp} re
   * @param  {Array}  keys
   * @return {RegExp}
   */
  function attachKeys (re, keys) {
    re.keys = keys
    return re
  }
  
  /**
   * Get the flags for a regexp from the options.
   *
   * @param  {Object} options
   * @return {String}
   */
  function flags (options) {
    return options.sensitive ? '' : 'i'
  }
  
  /**
   * Pull out keys from a regexp.
   *
   * @param  {RegExp} path
   * @param  {Array}  keys
   * @return {RegExp}
   */
  function regexpToRegexp (path, keys) {
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g)
  
    if (groups) {
      for (var i = 0; i < groups.length; i++) {
        keys.push({
          name: i,
          prefix: null,
          delimiter: null,
          optional: false,
          repeat: false,
          pattern: null
        })
      }
    }
  
    return attachKeys(path, keys)
  }
  
  /**
   * Transform an array into a regexp.
   *
   * @param  {Array}  path
   * @param  {Array}  keys
   * @param  {Object} options
   * @return {RegExp}
   */
  function arrayToRegexp (path, keys, options) {
    var parts = []
  
    for (var i = 0; i < path.length; i++) {
      parts.push(pathToRegexp(path[i], keys, options).source)
    }
  
    var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))
  
    return attachKeys(regexp, keys)
  }
  
  /**
   * Create a path regexp from string input.
   *
   * @param  {String} path
   * @param  {Array}  keys
   * @param  {Object} options
   * @return {RegExp}
   */
  function stringToRegexp (path, keys, options) {
    var tokens = parse(path)
    var re = tokensToRegExp(tokens, options)
  
    // Attach keys back to the regexp.
    for (var i = 0; i < tokens.length; i++) {
      if (typeof tokens[i] !== 'string') {
        keys.push(tokens[i])
      }
    }
  
    return attachKeys(re, keys)
  }
  
  /**
   * Expose a function for taking tokens and returning a RegExp.
   *
   * @param  {Array}  tokens
   * @param  {Array}  keys
   * @param  {Object} options
   * @return {RegExp}
   */
  function tokensToRegExp (tokens, options) {
    options = options || {}
  
    var strict = options.strict
    var end = options.end !== false
    var route = ''
    var lastToken = tokens[tokens.length - 1]
    var endsWithSlash = typeof lastToken === 'string' && /\/$/.test(lastToken)
  
    // Iterate over the tokens and create our regexp string.
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]
  
      if (typeof token === 'string') {
        route += escapeString(token)
      } else {
        var prefix = escapeString(token.prefix)
        var capture = token.pattern
  
        if (token.repeat) {
          capture += '(?:' + prefix + capture + ')*'
        }
  
        if (token.optional) {
          if (prefix) {
            capture = '(?:' + prefix + '(' + capture + '))?'
          } else {
            capture = '(' + capture + ')?'
          }
        } else {
          capture = prefix + '(' + capture + ')'
        }
  
        route += capture
      }
    }
  
    // In non-strict mode we allow a slash at the end of match. If the path to
    // match already ends with a slash, we remove it for consistency. The slash
    // is valid at the end of a path match, not in the middle. This is important
    // in non-ending mode, where "/test/" shouldn't match "/test//route".
    if (!strict) {
      route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?'
    }
  
    if (end) {
      route += '$'
    } else {
      // In non-ending mode, we need the capturing groups to match as much as
      // possible by using a positive lookahead to the end or next path segment.
      route += strict && endsWithSlash ? '' : '(?=\\/|$)'
    }
  
    return new RegExp('^' + route, flags(options))
  }
  
  /**
   * Normalize the given path string, returning a regular expression.
   *
   * An empty array can be passed in for the keys, which will hold the
   * placeholder key descriptions. For example, using `/user/:id`, `keys` will
   * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
   *
   * @param  {(String|RegExp|Array)} path
   * @param  {Array}                 [keys]
   * @param  {Object}                [options]
   * @return {RegExp}
   */
  function pathToRegexp (path, keys, options) {
    keys = keys || []
  
    if (!isarray(keys)) {
      options = keys
      keys = []
    } else if (!options) {
      options = {}
    }
  
    if (path instanceof RegExp) {
      return regexpToRegexp(path, keys, options)
    }
  
    if (isarray(path)) {
      return arrayToRegexp(path, keys, options)
    }
  
    return stringToRegexp(path, keys, options)
  }
  
});
require.register('lib/layer.js', function(module, exports, require) {
  'use strict';
  
  /**
   * Router layer object
   */
  
  var matcher = require('path-to-regexp#1.2.0')
  	, urlUtils = require('@yr/url-utils#2.0.3');
  
  module.exports = Layer;
  
  /**
   * Constructor
   * @param {String} url
   */
  function Layer (path, fn, options) {
  	if (!(this instanceof Layer)) {
  		return new Layer(path, fn, options);
  	}
  
  	// To be filled by matcher
  	this.keys = [];
  	this.path = null;
  	this.params = null;
  	this.fn = fn;
  	this.name = fn.name ? '<' + fn.name + '>' : '<anonymous>';
  	this.fastmatch = (path == '/' && !options.end);
  	this.regexp = matcher(path, this.keys, options);
  }
  
  /**
   * Determine if this route matches 'path'
   * @param {String} path
   * @returns {Boolean}
   */
  Layer.prototype.match = function (path) {
  	if (this.fastmatch) {
  		this.params = {};
  		this.path = '';
  		return true;
  	}
  
  	var match = this.regexp.exec(path);
  
  	if (!match) {
  		this.params = null;
  		this.path = null;
  		return false;
  	}
  
  	this.params = {};
  	this.path = match[0];
  
  	var n = 0
  		, key, val;
  
  	for (var i = 1, len = match.length; i < len; ++i) {
  		key = this.keys[i - 1];
  		val = urlUtils.decode(match[i]);
  
  		if (key) {
  			this.params[key.name] = val;
  		} else {
  			this.params[n++] = val;
  		}
  	}
  
  	return true;
  };
  
  /**
   * Handle
   * @param {Error} err
   * @param {Request} req
   * @param {Response} res
   * @param {Function} next
   */
  Layer.prototype.handle = function (err, req, res, next) {
  	if (err) {
  		// Only call if it handles errors
  		return (this.fn.length > 3)
  			? this.fn(err, req, res, next)
  			: next(err);
  	}
  
  	// Skip if error handler
  	return (this.fn.length < 4)
  		? this.fn(req, res, next)
  		: next();
  };
});
require.register('lib/router.js', function(module, exports, require) {
  'use strict';
  
  /**
   * Router for handling middleware pipeline.
   * Can be isolated under a specific mount path.
   */
  
  var assign = require('object-assign#3.0.0')
  	, debug = require('debug#2.2.0')('express:router')
  	, layer = require('lib/layer.js')
  	, urlUtils = require('@yr/url-utils#2.0.3')
  
  	, METHODS = ['get', 'post', 'all']
  	, DEFAULTS = {
  			mergeParams: true,
  			caseSensitive: false,
  			strict: false
  		};
  
  module.exports = Router;
  
  /**
   * Constructor
   * @param {Object} [options]
   */
  function Router (options) {
  	if (!(this instanceof Router)) {
  		return new Router(options);
  	}
  
  	options = assign({}, DEFAULTS, options);
  
  	this.stack = [];
  	this.mergeParams = options.mergeParams;
  	this.handle = this.handle.bind(this);
  	// Init matcher options
  	this.matcherOpts = {
  		sensitive: options.caseSensitive,
  		strict: options.strict,
  		end: false
  	};
  	this.strictMatcherOpts = {
  		sensitive: options.caseSensitive,
  		strict: options.strict,
  		end: true
  	};
  	this.params;
  }
  
  /**
   * Handle param 'name' with 'fn'
   * @param {String} name
   * @param {Function} fn(req, res, next, value)
   */
  Router.prototype.param = function (name, fn) {
  	if (!this.params) this.params = {};
  	this.params[name] = fn;
  };
  
  /**
   * Add one or more 'fn' to middleware pipeline at optional 'path'
   * @param {Function} fn
   */
  Router.prototype.use = function (/* path, */ fn /* ...fn */) {
  	var offset = 0
  		, path = '/'
  		, fns;
  
  	if ('string' == typeof fn) {
  		offset = 1;
  		path = fn;
  	}
  
  	fns = Array.prototype.slice.call(arguments, offset);
  
  	fns.forEach(function (fn) {
  		if (fn instanceof Router) {
  			fn = fn.handle;
  		}
  		var lyr = layer(path, fn, this.matcherOpts);
  		debug('adding router middleware %s with path %s', lyr.name, path);
  		this.stack.push(lyr);
  	}, this);
  };
  
  /**
   * Add one or more VERB fns at 'path' with strict matching of path
   * @param {String} path
   */
  METHODS.forEach(function (method) {
  	Router.prototype[method] = function (path) {
  		var fns = Array.prototype.slice.call(arguments, 1);
  
  		fns.forEach(function (fn) {
  			var lyr = layer(path, fn, this.strictMatcherOpts);
  			lyr.route = true;
  			debug('adding router route %s with path %s', lyr.name, path);
  			this.stack.push(lyr);
  		}, this);
  	};
  });
  
  /**
   * Run request/response through middleware pipline
   * @param {Request} req
   * @param {Response} res
   * @param {Function} done
   */
  Router.prototype.handle = function (req, res, done) {
  	var idx = 0
  		, self = this
  		, processedParams = {}
  		, removed = ''
  		, parentUrl = req.baseUrl || '';
  
  	// Update done to restore req props
  	done = restore(done, req, 'baseUrl', 'next', 'params');
  
  	// Setup next layer
  	req.next = next;
  	req.baseUrl = parentUrl;
  
  	next();
  
  	function next (err) {
  		var lyr = self.stack[idx++]
  			, layerErr = err;
  
  		if (removed.length != 0) {
  			debug('untrim %s from url %s', removed, req.path);
  			req.baseUrl = parentUrl;
  			req.path = urlUtils.join(removed, req.path);
  			removed = '';
  		}
  
  		// Exit
  		if (!lyr) {
  			return done(err);
  		}
  
  		// Skip if no match
  		if (!lyr.match(req.path)) {
  			return next(err);
  		}
  
  		debug('%s matched layer %s with path %s', req.path, lyr.name, lyr.path);
  
  		// Store params
  		if (self.mergeParams) {
  			if (!req.params) req.params = {};
  			assign(req.params, lyr.params);
  		} else {
  			req.params = lyr.params;
  		}
  
  		var keys = Object.keys(lyr.params);
  		// Process params if necessary
  		self._processParams(processedParams, req.params, keys, req, res, function (err) {
  			if (err) return next(layerErr || err);
  			if (!lyr.route) trim(lyr);
  			return lyr.handle(layerErr, req, res, next);
  		});
  	}
  
  	function trim (layer) {
  		if (layer.path.length != 0) {
  			debug('trim %s from url %s', layer.path, req.path);
  			removed = layer.path;
  			req.path = req.path.substr(removed.length);
  			if (req.path.charAt(0) != '/') req.path = '/' + req.path;
  
  			req.baseUrl = urlUtils.join(parentUrl, removed);
  		}
  	}
  };
  
  /**
   * Process middleware matched parameters
   * @param {Object} processedParams
   * @param {Object} params
   * @param {Array} keys
   * @param {Request} req
   * @param {Response} res
   * @param {Function} done(err)
   */
  Router.prototype._processParams = function (processedParams, params, keys, req, res, done) {
  	function next (err) {
  		// Stop processing on any error
  		if (err) return done(err);
  
  		if (idx >= keys.length) return done();
  
  		var name = keys[idx++]
  			, fn = self.params[name];
  
  		// Process if match and not already processed
  		if (fn && !processedParams[name]) {
  			processedParams[name] = true;
  			fn(req, res, next, params[name]);
  		} else {
  			next();
  		}
  	}
  
  	if (this.params && keys.length) {
  		var idx = 0
  			, self = this;
  
  		next();
  	} else {
  		done();
  	}
  };
  
  /**
   * Restore 'obj' props
   * @param {Function} fn
   * @param {Object} obj
   */
  function restore (fn, obj) {
  	var props = new Array(arguments.length - 2)
  		, vals = new Array(arguments.length - 2);
  
  	for (var i = 0; i < props.length; i++) {
  		props[i] = arguments[i + 2];
  		vals[i] = obj[props[i]];
  	}
  
  	return function () {
  		// Restore vals
  		for (var i = 0; i < props.length; i++) {
  			obj[props[i]] = vals[i];
  		}
  
  		return fn.apply(this, arguments);
  	};
  }
});
require.register('lib/response.js', function(module, exports, require) {
  'use strict';
  
  /**
   * Browser response object
   */
  
  var assign = require('object-assign#3.0.0')
  	, cookie = require('cookie#0.1.3')
  	, emitter = require('eventemitter3#1.1.1');
  
  module.exports = Response;
  
  /**
   * Constructor
   */
  function Response () {
  	if (!(this instanceof Response)) {
  		return new Response();
  	}
  
  	this.app;
  	this.req;
  	this.reset();
  
  	assign(this, emitter.prototype);
  }
  
  /**
   * Reset state
   */
  Response.prototype.reset = function () {
  	this.cached = false;
  	this.finished = false;
  	this.locals = {};
  	this.statusCode = 404;
  };
  
  /**
   * Set status 'code'
   * @param {Number} code
   * @returns {Response}
   */
  Response.prototype.status = function (code) {
  	this.statusCode = code;
  	return this;
  };
  
  /**
   * Send response (last method called in pipeline)
   */
  Response.prototype.send = function () {
  	// Reset state
  	this.req.reset();
  	this.status(200);
  	this.finished = true;
  	this.emit('finish');
  };
  
  /**
   * Redirect to 'url'
   * @param {Number} statusCode
   * @param {String} url
   */
  Response.prototype.redirect = function (statusCode, url) {
  	this.app.redirectTo(url || statusCode);
  };
  
  /**
   * Set cookie
   * @param {String} name
   * @param {String|Object} val
   * @param {Object} options
   * @returns {Response}
   */
  Response.prototype.cookie = function (name, val, options) {
    options = assign({}, options);
  
    if ('number' == typeof val) val = val.toString();
    if ('object' == typeof val) val = 'j:' + JSON.stringify(val);
  
    if ('maxAge' in options) {
      options.expires = new Date(Date.now() + options.maxAge);
      options.maxAge /= 1000;
    }
  
    if (null == options.path) options.path = '/';
    var headerVal = cookie.serialize(name, String(val), options);
  
    document.cookie = headerVal;
  
    return this;
  };
});
require.register('strict-uri-encode#1.0.2', function(module, exports, require) {
  'use strict';
  module.exports = function (str) {
  	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
  		return '%' + c.charCodeAt(0).toString(16);
  	});
  };
  
});
require.register('query-string#2.4.0', function(module, exports, require) {
  'use strict';
  var strictUriEncode = require('strict-uri-encode#1.0.2');
  
  exports.extract = function (str) {
  	return str.split('?')[1] || '';
  };
  
  exports.parse = function (str) {
  	if (typeof str !== 'string') {
  		return {};
  	}
  
  	str = str.trim().replace(/^(\?|#|&)/, '');
  
  	if (!str) {
  		return {};
  	}
  
  	return str.split('&').reduce(function (ret, param) {
  		var parts = param.replace(/\+/g, ' ').split('=');
  		var key = parts[0];
  		var val = parts[1];
  
  		key = decodeURIComponent(key);
  
  		// missing `=` should be `null`:
  		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
  		val = val === undefined ? null : decodeURIComponent(val);
  
  		if (!ret.hasOwnProperty(key)) {
  			ret[key] = val;
  		} else if (Array.isArray(ret[key])) {
  			ret[key].push(val);
  		} else {
  			ret[key] = [ret[key], val];
  		}
  
  		return ret;
  	}, {});
  };
  
  exports.stringify = function (obj) {
  	return obj ? Object.keys(obj).sort().map(function (key) {
  		var val = obj[key];
  
  		if (Array.isArray(val)) {
  			return val.sort().map(function (val2) {
  				return strictUriEncode(key) + '=' + strictUriEncode(val2);
  			}).join('&');
  		}
  
  		return strictUriEncode(key) + '=' + strictUriEncode(val);
  	}).join('&') : '';
  };
  
});
require.register('cookie#0.1.3', function(module, exports, require) {
  /*!  
   * cookie  
   * Copyright(c) 2012-2014 Roman Shtylman  
   * MIT Licensed  
   */  
    
  /**  
   * Module exports.  
   * @public  
   */  
    
  exports.parse = parse;  
  exports.serialize = serialize;  
    
  /**  
   * Module variables.  
   * @private  
   */  
    
  var decode = decodeURIComponent;  
  var encode = encodeURIComponent;  
    
  /**  
   * Parse a cookie header.  
   *  
   * Parse the given cookie header string into an object  
   * The object has the various cookies as keys(names) => values  
   *  
   * @param {string} str  
   * @param {object} [options]  
   * @return {string}  
   * @public  
   */  
    
  function parse(str, options) {  
    var obj = {}  
    var opt = options || {};  
    var pairs = str.split(/; */);  
    var dec = opt.decode || decode;  
    
    pairs.forEach(function(pair) {  
      var eq_idx = pair.indexOf('=')  
    
      // skip things that don't look like key=value  
      if (eq_idx < 0) {  
        return;  
      }  
    
      var key = pair.substr(0, eq_idx).trim()  
      var val = pair.substr(++eq_idx, pair.length).trim();  
    
      // quoted values  
      if ('"' == val[0]) {  
        val = val.slice(1, -1);  
      }  
    
      // only assign once  
      if (undefined == obj[key]) {  
        obj[key] = tryDecode(val, dec);  
      }  
    });  
    
    return obj;  
  }  
    
  /**  
   * Serialize data into a cookie header.  
   *  
   * Serialize the a name value pair into a cookie string suitable for  
   * http headers. An optional options object specified cookie parameters.  
   *  
   * serialize('foo', 'bar', { httpOnly: true })  
   *   => "foo=bar; httpOnly"  
   *  
   * @param {string} name  
   * @param {string} val  
   * @param {object} [options]  
   * @return {string}  
   * @public  
   */  
    
  function serialize(name, val, options) {  
    var opt = options || {};  
    var enc = opt.encode || encode;  
    var pairs = [name + '=' + enc(val)];  
    
    if (null != opt.maxAge) {  
      var maxAge = opt.maxAge - 0;  
      if (isNaN(maxAge)) throw new Error('maxAge should be a Number');  
      pairs.push('Max-Age=' + maxAge);  
    }  
    
    if (opt.domain) pairs.push('Domain=' + opt.domain);  
    if (opt.path) pairs.push('Path=' + opt.path);  
    if (opt.expires) pairs.push('Expires=' + opt.expires.toUTCString());  
    if (opt.httpOnly) pairs.push('HttpOnly');  
    if (opt.secure) pairs.push('Secure');  
    
    return pairs.join('; ');  
  }  
    
  /**  
   * Try decoding a string using a decoding function.  
   *  
   * @param {string} str  
   * @param {function} decode  
   * @private  
   */  
    
  function tryDecode(str, decode) {  
    try {  
      return decode(str);  
    } catch (e) {  
      return str;  
    }  
  }  
  
});
require.register('lib/request.js', function(module, exports, require) {
  'use strict';
  
  /**
   * Browser request object
   */
  
  var assign = require('object-assign#3.0.0')
  	, cookie = require('cookie#0.1.3')
  	, emitter = require('eventemitter3#1.1.1')
  	, qsParse = require('query-string#2.4.0').parse
  	, urlUtils = require('@yr/url-utils#2.0.3');
  
  module.exports = Request;
  
  /**
   * Constructor
   * @param {String} url
   * @param {Boolean} bootstrap
   */
  function Request (url, bootstrap) {
  	if (!(this instanceof Request)) {
  		return new Request(url, bootstrap);
  	}
  
  	url = url
  		? urlUtils.encode(url)
  		: urlUtils.getCurrent();
  
  	var path = url.split('?')
  		, qs = path[1] || '';
  
  	this.app;
  	this.cookies = cookie.parse(document.cookie);
  	this.path = urlUtils.sanitize(path[0]);
  	this.query = qsParse(qs);
  	this.querystring = qs;
  	this.search = qs ? '?' + qs : '';
  	this.url = this.originalUrl = url;
  	this.reset(bootstrap);
  
  	assign(this, emitter.prototype);
  }
  
  /**
   * Abort response
   */
  Request.prototype.abort = function () {
  	this.reset();
  	this.emit('close');
  };
  
  /**
   * Reset state
   * @param {Boolean} bootstrap
   */
  Request.prototype.reset = function (bootstrap) {
  	this.baseUrl = '';
  	this.bootstrap = bootstrap || false;
  	this.cached = false;
  	this.path = urlUtils.sanitize(this.originalUrl.split('?')[0]);
  	this.params = null;
  };
  
});
require.register('@yr/runtime#0.1.0', function(module, exports, require) {
  var isNode = (typeof process !== 'undefined'
  	&& {}.toString.call(process) === '[object process]');
  
  exports.isServer = isNode;
  exports.isBrowser = !isNode;
});
require.register('@yr/url-utils#2.0.3', function(module, exports, require) {
  var isServer = require('@yr/runtime#0.1.0').isServer
  
  	, RE_TEMPLATE = /\{([0-9a-zA-Z]+)\}/g
  	, RE_URL = /([^:])(\/{2,})/g;
  
  /**
   * Join url segments
   * Handles strings or arrays of strings
   * @param {String|Array} ...segments
   * @returns {String}
   */
  exports.join = function join (/* ...segments */) {
  	// Non-leaky conversion of arguments to array
  	var n = arguments.length
  		, segments = new Array(n);
  	for (var i = 0; i < n; i++) { segments[i] = arguments[i]; }
  
  	var path = []
  		, leading = ''
  		, segment;
  
  	function add (seg) {
  		if (seg) {
  			// Handle leading slash
  			if (seg.charAt(0) == '/') {
  				// Keep if first segment
  				if (!path.length) leading = '/';
  				seg = seg.slice(1);
  			}
  			if (seg.length) path.push(exports.sanitize(seg));
  		}
  	}
  
  	if (segments.length) {
  		for (var i = 0, n = segments.length; i < n; i++) {
  			segment = segments[i];
  			// Handle array
  			if (Array.isArray(segment)) {
  				segment.forEach(add);
  			} else {
  				add(segment);
  			}
  		}
  
  		return leading + path.join('/');
  	}
  
  	return '';
  };
  
  /**
   * Add query parameters to url in alphabetical order
   * Handles undefined query parameters
   * @param {String} url
   * @param {Object} query
   * @returns {String}
   */
  exports.query = function query (url, query) {
  	var delimit = '?'
  		, sorted = [];
  
  	function append (q) {
  		if (url.charAt(url.length - 1) != delimit) url += '&';
  		url += q + '=' + query[q];
  	}
  
  	if (url && query) {
  		url = exports.sanitize(url);
  		sorted = Object.keys(query).sort();
  		if (!sorted.length) return '';
  		// Add delimiter
  		url += delimit;
  		// Append queries
  		sorted.forEach(function (q) {
  			if (query[q] != null) append(q);
  		});
  
  		return exports.encode(url);
  	}
  
  	return '';
  };
  
  /**
   * Remove trailing '/' from 'url'
   * @param {String} url
   * @returns {String}
   */
  exports.sanitize = function sanitize (url) {
  	if (url && url != '/') {
  		url = url.replace(RE_URL, '$1/');
  		if (url.charAt(url.length - 1) == '/') url = url.slice(0, -1);
  	}
  
  	return url || '';
  };
  
  /**
   * Decode 'url'
   * @param {String} url
   * @returns {String}
   */
  exports.decode = function decode (url) {
  	if ('string' == typeof url) {
  		try {
  			url = decodeURI(url);
  			return url;
  		} catch (err) {
  			throw new Error('failed to decode "' + url + '"');
  		}
  	}
  
  	return url;
  };
  
  /**
   * Encode 'url'
   * @param {String} url
   * @returns {String}
   */
  exports.encode = function encode (url) {
  	if ('string' == typeof url) {
  		try {
  			// Try to decode first in-case url is encoded
  			try {
  				url = decodeURI(url);
  			} catch (err) {
  				// Do nothing
  			}
  			return encodeURI(url);
  		} catch (err) {
  			throw new Error('failed to encode"' + url + '"');
  		}
  	}
  
  	return url;
  };
  
  /**
   * Retrieve current browser path
   * @returns {String}
   */
  exports.getCurrent = function getCurrent () {
  	return (!isServer)
  		? exports.encode(window.location.pathname + window.location.search)
  		: '';
  };
  
  /**
   * Substitute 'data' values in 'str' template
   * @param {String} str
   * @param {Object} data
   * @params {Object} options
   * @returns {String}
   */
  exports.template = function template (str, data, options) {
  	options = options || {};
  	var str = String(str).replace(RE_TEMPLATE, function (match, prop, idx) {
  		return (data && data[prop] != null)
  			? data[prop]
  			: (options.loose) ? match : '';
  	});
  
  	return exports.sanitize(str);
  };
});
require.register('lib/history.js', function(module, exports, require) {
  'use strict';
  
  /**
   * Manager for browser history.
   * Generates/stores request/response context for current url,
   * and responds to changes to state via History API.
   */
  
  var debug = require('debug#2.2.0')('express:history')
  	, urlUtils = require('@yr/url-utils#2.0.3')
  	, bootstrap = true;
  
  module.exports = History;
  
  /**
   * Constructor
   * @param {Function} request(url)
   * @param {Function} response
   * @param {Function} fn(req, res)
   */
  function History (request, response, fn) {
  	if (!(this instanceof History)) {
  		return new History(request, response, fn);
  	}
  
  	this.cache = {};
  	this.current = '';
  	this.running = false;
  	this.request = request;
  	this.response = response;
  	this.fn = fn;
  	this.onClick = this.onClick.bind(this);
  	this.onPopstate = this.onPopstate.bind(this);
  	this.navigateTo = this.navigateTo.bind(this);
  	this.redirectTo = this.redirectTo.bind(this);
  	this.getCurrentContext = this.getCurrentContext.bind(this);
  }
  
  /**
   * Notify on current context,
   * and begin listening for history changes
   * @returns {History}
   */
  History.prototype.listen = function () {
  	// Handle current history state (triggers notification)
  	var ctx = this.handle();
  
  	if (!this.running && ctx) {
  		// Test History API availability
  		if (hasHistory()) {
  			var self = this;
  			// Delay to prevent premature trigger when navigating back from nothing
  			setTimeout(function () {
  				window.addEventListener('click', self.onClick, false);
  				window.addEventListener('popstate', self.onPopstate, false);
  				self.running = true;
  			}, 500);
  
  			// Update so that popstate will trigger for this route
  			window.history.replaceState({}, document.title);
  
  			debug('listening with history API');
  		}
  	}
  
  	return this;
  };
  
  /**
   * Create a new or updated history state at 'url' with 'title'
   * @param {String} url
   * @param {String} title
   * @param {Boolean} isUpdate
   */
  History.prototype.navigateTo = function (url, title, isUpdate) {
  	// Only navigate if not same as current
  	if (url != urlUtils.getCurrent()) {
  		if (this.running) {
  			// Will throw if malformed
  			url = urlUtils.encode(url);
  
  			debug('navigate to: %s', url);
  
  			window.history[isUpdate ? 'replaceState' : 'pushState']({}, title, url);
  			if (title) document.title = title;
  			this.handle(url);
  		} else {
  			this.redirectTo(url);
  		}
  	}
  };
  
  /**
   * Stop history management by redirecting to 'url'
   * @param {String} url
   */
  History.prototype.redirectTo = function (url) {
  	this.destroy();
  	window.location = urlUtils.encode(url);
  };
  
  /**
   * Force a re-handle of current context
   */
  History.prototype.refresh = function () {
  	var ctx = this.getCurrentContext();
  	// Undo pipeline modifications
  	ctx.req.reset();
  	ctx.res.reset();
  	this.fn(ctx.req, ctx.res);
  };
  
  /**
   * Retrieve current context
   * @returns {Object}
   */
  History.prototype.getCurrentContext = function () {
  	return this.cache[this.current];
  };
  
  /**
   * Stop listening for history updates
   */
  History.prototype.destroy = function () {
  	if (this.running) {
  		window.removeEventListener('click', this.onClick, false);
  		window.removeEventListener('popstate', this.onPopstate, false);
  		this.cache = null;
  		this.running = false;
  	}
  };
  
  /**
   * Handle history change and notify
   * @param {String} [url]
   * @param {State} [state]
   * @returns {Object}
   */
  History.prototype.handle = function (url) {
  	var ctx = {}
  		, req, res;
  
  	try {
  		url = url
  			? urlUtils.encode(url)
  			: urlUtils.getCurrent();
  	} catch (err) {
  		// Error encoding url
  		return this.redirectTo(url);
  	}
  
  	// Do nothing if current url is the same
  	if (this.current && this.current === url) return;
  
  	if (this.cache[url]) {
  		ctx = this.cache[url];
  		req = ctx.req;
  		res = ctx.res;
  		// Always reset in order to undo pipeline modifications
  		req.reset();
  		res.reset();
  		// Set flag for use downstream
  		req.cached = res.cached = true;
  		debug('context retrieved from cache: %s', url);
  	} else {
  		req = this.request(url, bootstrap);
  		res = this.response();
  		debug('generating new context: %s', url);
  	}
  	res.req = req;
  	ctx.req = req;
  	ctx.res = res;
  	this.cache[url] = ctx;
  
  	// Make sure only first request flagged as bootstrap
  	bootstrap = false;
  
  	// Abort if current request/response is not finished
  	if (this.current && !this.cache[this.current].res.finished) {
  		this.cache[this.current].req.abort();
  		this.cache[this.current].res.reset();
  	}
  
  	// Store reference to current
  	this.current = url;
  
  	this.fn(req, res);
  
  	return ctx;
  };
  
  /**
   * Handle history change via 'popstate' event
   * @param {Object} evt
   */
  History.prototype.onPopstate = function (evt) {
  	// Prevent initial page load from triggering on some platforms when no state
  	if (evt.state && this.running) {
  		this.handle();
  	}
  };
  
  /**
   * Handle click event
   * @param {Object} evt
   */
  History.prototype.onClick = function (evt) {
  	var which = (null == evt.which)
  			? evt.button
  			: evt.which
  		, el = evt.target;
  
  	// Modifiers present
  	if (which != 1) return;
  	if (evt.metaKey || evt.ctrlKey || evt.shiftKey) return;
  	if (evt.defaultPrevented) return;
  
  	// Find anchor
  	// svg elements on some platforms don't have nodeNames
  	while (el && (el.nodeName == null || 'A' != el.nodeName.toUpperCase())) {
  		el = el.parentNode;
  	}
  
  	// Anchor not found
  	if (!el || 'A' != el.nodeName.toUpperCase()) return;
  
  	// Cross origin
  	if (!sameOrigin(el.href)) return this.fn(el.href);
  
  	var path = el.pathname + el.search;
  
  	evt.preventDefault();
  
  	// Same as current
  	if (path == urlUtils.getCurrent()) return;
  
  	debug('click event intercepted from %s', el);
  	// TODO: what about title?
  	this.navigateTo(path);
  };
  
  /**
   * Test for history API (Modernizr)
   * @returns {Boolean}
   */
  function hasHistory () {
  	var ua = navigator.userAgent;
  
  	// Stock android browser 2.2 & 2.3 & 4.0.x are buggy, ignore
  	if ((ua.indexOf('Android 2.') !== -1
  		|| (ua.indexOf('Android 4.0') !== -1))
  		// Chrome identifies itself as 'Mobile Safari'
  		&& ua.indexOf('Mobile Safari') !== -1
  		&& ua.indexOf('Chrome') === -1) {
  			return false;
  	}
  
  	// Usual test
  	return (window.history && 'pushState' in window.history);
  }
  
  /**
   * Check if 'url' is from same origin
   * @param {String} url
   * @returns {Boolean}
   */
  function sameOrigin (url) {
  	var origin = location.protocol + '//' + location.hostname;
  	if (location.port) origin += ':' + location.port;
  	return (url && (url.indexOf(origin) == 0));
  }
});
require.register('eventemitter3#1.1.1', function(module, exports, require) {
  'use strict';
  
  //
  // We store our EE objects in a plain object whose properties are event names.
  // If `Object.create(null)` is not supported we prefix the event names with a
  // `~` to make sure that the built-in object properties are not overridden or
  // used as an attack vector.
  // We also assume that `Object.create(null)` is available when the event name
  // is an ES6 Symbol.
  //
  var prefix = typeof Object.create !== 'function' ? '~' : false;
  
  /**
   * Representation of a single EventEmitter function.
   *
   * @param {Function} fn Event handler to be called.
   * @param {Mixed} context Context for function execution.
   * @param {Boolean} once Only emit once
   * @api private
   */
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  
  /**
   * Minimal EventEmitter interface that is molded against the Node.js
   * EventEmitter interface.
   *
   * @constructor
   * @api public
   */
  function EventEmitter() { /* Nothing to set */ }
  
  /**
   * Holds the assigned EventEmitters by name.
   *
   * @type {Object}
   * @private
   */
  EventEmitter.prototype._events = undefined;
  
  /**
   * Return a list of assigned event listeners.
   *
   * @param {String} event The events that should be listed.
   * @param {Boolean} exists We only need to know if there are listeners.
   * @returns {Array|Boolean}
   * @api public
   */
  EventEmitter.prototype.listeners = function listeners(event, exists) {
    var evt = prefix ? prefix + event : event
      , available = this._events && this._events[evt];
  
    if (exists) return !!available;
    if (!available) return [];
    if (available.fn) return [available.fn];
  
    for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
      ee[i] = available[i].fn;
    }
  
    return ee;
  };
  
  /**
   * Emit an event to all registered event listeners.
   *
   * @param {String} event The name of the event.
   * @returns {Boolean} Indication if we've emitted an event.
   * @api public
   */
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
  
    if (!this._events || !this._events[evt]) return false;
  
    var listeners = this._events[evt]
      , len = arguments.length
      , args
      , i;
  
    if ('function' === typeof listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
  
      switch (len) {
        case 1: return listeners.fn.call(listeners.context), true;
        case 2: return listeners.fn.call(listeners.context, a1), true;
        case 3: return listeners.fn.call(listeners.context, a1, a2), true;
        case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
  
      for (i = 1, args = new Array(len -1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
  
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length
        , j;
  
      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
  
        switch (len) {
          case 1: listeners[i].fn.call(listeners[i].context); break;
          case 2: listeners[i].fn.call(listeners[i].context, a1); break;
          case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
          default:
            if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
  
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
  
    return true;
  };
  
  /**
   * Register a new EventListener for the given event.
   *
   * @param {String} event Name of the event.
   * @param {Functon} fn Callback function.
   * @param {Mixed} context The context of the function.
   * @api public
   */
  EventEmitter.prototype.on = function on(event, fn, context) {
    var listener = new EE(fn, context || this)
      , evt = prefix ? prefix + event : event;
  
    if (!this._events) this._events = prefix ? {} : Object.create(null);
    if (!this._events[evt]) this._events[evt] = listener;
    else {
      if (!this._events[evt].fn) this._events[evt].push(listener);
      else this._events[evt] = [
        this._events[evt], listener
      ];
    }
  
    return this;
  };
  
  /**
   * Add an EventListener that's only called once.
   *
   * @param {String} event Name of the event.
   * @param {Function} fn Callback function.
   * @param {Mixed} context The context of the function.
   * @api public
   */
  EventEmitter.prototype.once = function once(event, fn, context) {
    var listener = new EE(fn, context || this, true)
      , evt = prefix ? prefix + event : event;
  
    if (!this._events) this._events = prefix ? {} : Object.create(null);
    if (!this._events[evt]) this._events[evt] = listener;
    else {
      if (!this._events[evt].fn) this._events[evt].push(listener);
      else this._events[evt] = [
        this._events[evt], listener
      ];
    }
  
    return this;
  };
  
  /**
   * Remove event listeners.
   *
   * @param {String} event The event we want to remove.
   * @param {Function} fn The listener that we need to find.
   * @param {Mixed} context Only remove listeners matching this context.
   * @param {Boolean} once Only remove once listeners.
   * @api public
   */
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
  
    if (!this._events || !this._events[evt]) return this;
  
    var listeners = this._events[evt]
      , events = [];
  
    if (fn) {
      if (listeners.fn) {
        if (
             listeners.fn !== fn
          || (once && !listeners.once)
          || (context && listeners.context !== context)
        ) {
          events.push(listeners);
        }
      } else {
        for (var i = 0, length = listeners.length; i < length; i++) {
          if (
               listeners[i].fn !== fn
            || (once && !listeners[i].once)
            || (context && listeners[i].context !== context)
          ) {
            events.push(listeners[i]);
          }
        }
      }
    }
  
    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) {
      this._events[evt] = events.length === 1 ? events[0] : events;
    } else {
      delete this._events[evt];
    }
  
    return this;
  };
  
  /**
   * Remove all listeners or only the listeners for the specified event.
   *
   * @param {String} event The event want to remove all listeners for.
   * @api public
   */
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    if (!this._events) return this;
  
    if (event) delete this._events[prefix ? prefix + event : event];
    else this._events = prefix ? {} : Object.create(null);
  
    return this;
  };
  
  //
  // Alias methods names because people roll like that.
  //
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  
  //
  // This function doesn't apply anymore.
  //
  EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
    return this;
  };
  
  //
  // Expose the prefix.
  //
  EventEmitter.prefixed = prefix;
  
  //
  // Expose the module.
  //
  if ('undefined' !== typeof module) {
    module.exports = EventEmitter;
  }
  
});
require.register('ms#0.7.1', function(module, exports, require) {
  /**
   * Helpers.
   */
  
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  
  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} options
   * @return {String|Number}
   * @api public
   */
  
  module.exports = function(val, options){
    options = options || {};
    if ('string' == typeof val) return parse(val);
    return options.long
      ? long(val)
      : short(val);
  };
  
  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */
  
  function parse(str) {
    str = '' + str;
    if (str.length > 10000) return;
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) return;
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
    }
  }
  
  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */
  
  function short(ms) {
    if (ms >= d) return Math.round(ms / d) + 'd';
    if (ms >= h) return Math.round(ms / h) + 'h';
    if (ms >= m) return Math.round(ms / m) + 'm';
    if (ms >= s) return Math.round(ms / s) + 's';
    return ms + 'ms';
  }
  
  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */
  
  function long(ms) {
    return plural(ms, d, 'day')
      || plural(ms, h, 'hour')
      || plural(ms, m, 'minute')
      || plural(ms, s, 'second')
      || ms + ' ms';
  }
  
  /**
   * Pluralization helper.
   */
  
  function plural(ms, n, name) {
    if (ms < n) return;
    if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
    return Math.ceil(ms / n) + ' ' + name + 's';
  }
  
});
require.register('debug/debug.js#2.2.0', function(module, exports, require) {
  
  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   *
   * Expose `debug()` as the module.
   */
  
  exports = module.exports = debug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = require('ms#0.7.1');
  
  /**
   * The currently active debug mode names, and names to skip.
   */
  
  exports.names = [];
  exports.skips = [];
  
  /**
   * Map of special "%n" handling functions, for the debug "format" argument.
   *
   * Valid key names are a single, lowercased letter, i.e. "n".
   */
  
  exports.formatters = {};
  
  /**
   * Previously assigned color.
   */
  
  var prevColor = 0;
  
  /**
   * Previous log timestamp.
   */
  
  var prevTime;
  
  /**
   * Select a color.
   *
   * @return {Number}
   * @api private
   */
  
  function selectColor() {
    return exports.colors[prevColor++ % exports.colors.length];
  }
  
  /**
   * Create a debugger with the given `namespace`.
   *
   * @param {String} namespace
   * @return {Function}
   * @api public
   */
  
  function debug(namespace) {
  
    // define the `disabled` version
    function disabled() {
    }
    disabled.enabled = false;
  
    // define the `enabled` version
    function enabled() {
  
      var self = enabled;
  
      // set `diff` timestamp
      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
  
      // add the `color` if not set
      if (null == self.useColors) self.useColors = exports.useColors();
      if (null == self.color && self.useColors) self.color = selectColor();
  
      var args = Array.prototype.slice.call(arguments);
  
      args[0] = exports.coerce(args[0]);
  
      if ('string' !== typeof args[0]) {
        // anything else let's inspect with %o
        args = ['%o'].concat(args);
      }
  
      // apply any `formatters` transformations
      var index = 0;
      args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
        // if we encounter an escaped % then don't increase the array index
        if (match === '%%') return match;
        index++;
        var formatter = exports.formatters[format];
        if ('function' === typeof formatter) {
          var val = args[index];
          match = formatter.call(self, val);
  
          // now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });
  
      if ('function' === typeof exports.formatArgs) {
        args = exports.formatArgs.apply(self, args);
      }
      var logFn = enabled.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }
    enabled.enabled = true;
  
    var fn = exports.enabled(namespace) ? enabled : disabled;
  
    fn.namespace = namespace;
  
    return fn;
  }
  
  /**
   * Enables a debug mode by namespaces. This can include modes
   * separated by a colon and wildcards.
   *
   * @param {String} namespaces
   * @api public
   */
  
  function enable(namespaces) {
    exports.save(namespaces);
  
    var split = (namespaces || '').split(/[\s,]+/);
    var len = split.length;
  
    for (var i = 0; i < len; i++) {
      if (!split[i]) continue; // ignore empty strings
      namespaces = split[i].replace(/\*/g, '.*?');
      if (namespaces[0] === '-') {
        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        exports.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  
  /**
   * Disable debug output.
   *
   * @api public
   */
  
  function disable() {
    exports.enable('');
  }
  
  /**
   * Returns true if the given mode name is enabled, false otherwise.
   *
   * @param {String} name
   * @return {Boolean}
   * @api public
   */
  
  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length; i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length; i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  
  /**
   * Coerce `val`.
   *
   * @param {Mixed} val
   * @return {Mixed}
   * @api private
   */
  
  function coerce(val) {
    if (val instanceof Error) return val.stack || val.message;
    return val;
  }
  
});
require.register('debug#2.2.0', function(module, exports, require) {
  
  /**
   * This is the web browser implementation of `debug()`.
   *
   * Expose `debug()` as the module.
   */
  
  exports = module.exports = require('debug/debug.js#2.2.0');
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = 'undefined' != typeof chrome
                 && 'undefined' != typeof chrome.storage
                    ? chrome.storage.local
                    : localstorage();
  
  /**
   * Colors.
   */
  
  exports.colors = [
    'lightseagreen',
    'forestgreen',
    'goldenrod',
    'dodgerblue',
    'darkorchid',
    'crimson'
  ];
  
  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */
  
  function useColors() {
    // is webkit? http://stackoverflow.com/a/16459606/376773
    return ('WebkitAppearance' in document.documentElement.style) ||
      // is firebug? http://stackoverflow.com/a/398120/376773
      (window.console && (console.firebug || (console.exception && console.table))) ||
      // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
  }
  
  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */
  
  exports.formatters.j = function(v) {
    return JSON.stringify(v);
  };
  
  
  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */
  
  function formatArgs() {
    var args = arguments;
    var useColors = this.useColors;
  
    args[0] = (useColors ? '%c' : '')
      + this.namespace
      + (useColors ? ' %c' : ' ')
      + args[0]
      + (useColors ? '%c ' : ' ')
      + '+' + exports.humanize(this.diff);
  
    if (!useColors) return args;
  
    var c = 'color: ' + this.color;
    args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
  
    // the final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-z%]/g, function(match) {
      if ('%%' === match) return;
      index++;
      if ('%c' === match) {
        // we only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });
  
    args.splice(lastC, 0, c);
    return args;
  }
  
  /**
   * Invokes `console.log()` when available.
   * No-op when `console.log` is not a "function".
   *
   * @api public
   */
  
  function log() {
    // this hackery is required for IE8/9, where
    // the `console.log` function doesn't have 'apply'
    return 'object' === typeof console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }
  
  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */
  
  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports.storage.removeItem('debug');
      } else {
        exports.storage.debug = namespaces;
      }
    } catch(e) {}
  }
  
  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */
  
  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch(e) {}
    return r;
  }
  
  /**
   * Enable namespaces listed in `localStorage.debug` initially.
   */
  
  exports.enable(load());
  
  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */
  
  function localstorage(){
    try {
      return window.localStorage;
    } catch (e) {}
  }
  
});
require.register('object-assign#3.0.0', function(module, exports, require) {
  'use strict';
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  
  function ToObject(val) {
  	if (val == null) {
  		throw new TypeError('Object.assign cannot be called with null or undefined');
  	}
  
  	return Object(val);
  }
  
  function ownEnumerableKeys(obj) {
  	var keys = Object.getOwnPropertyNames(obj);
  
  	if (Object.getOwnPropertySymbols) {
  		keys = keys.concat(Object.getOwnPropertySymbols(obj));
  	}
  
  	return keys.filter(function (key) {
  		return propIsEnumerable.call(obj, key);
  	});
  }
  
  module.exports = Object.assign || function (target, source) {
  	var from;
  	var keys;
  	var to = ToObject(target);
  
  	for (var s = 1; s < arguments.length; s++) {
  		from = arguments[s];
  		keys = ownEnumerableKeys(Object(from));
  
  		for (var i = 0; i < keys.length; i++) {
  			to[keys[i]] = from[keys[i]];
  		}
  	}
  
  	return to;
  };
  
});
require.register('lib/application.js', function(module, exports, require) {
  'use strict';
  
  /**
   * Browser application
   */
  
  var assign = require('object-assign#3.0.0')
  	, debug = require('debug#2.2.0')('express:application')
  	, emitter = require('eventemitter3#1.1.1')
  	, history = require('lib/history.js')
  	, request = require('lib/request.js')
  	, response = require('lib/response.js')
  	, router = require('lib/router.js')
  
  	, METHODS = ['get', 'post', 'all'];
  
  module.exports = Application;
  
  /**
   * Constructor
   */
  function Application () {
  	if (!(this instanceof Application)) {
  		return new Application();
  	}
  
  	this.settings = {
  		env: undefined || 'development'
  	};
  	this.cache = {};
  	this.locals = {};
  	this.mountpath = '/';
  	this._router = router({
  		caseSensitive: false,
  		strict: false,
  		mergeParams: true
  	});
  	this.parent;
  
  	this.handle = this.handle.bind(this);
  	this.navigateTo = this.navigateTo.bind(this);
  	this.redirectTo = this.redirectTo.bind(this);
  	this.getCurrentContext = this.getCurrentContext.bind(this);
  	this.refresh = this.refresh.bind(this);
  
  	// Create request/response factories
  	var app = this
  		, req = function (url, bootstrap) {
  				var req = request(url, bootstrap);
  				req.app = app;
  				return req;
  			}
  		, res = function () {
  				var res = response();
  				res.app = app;
  				return res;
  			};
  
  	this.history = history(req, res, this.handle);
  
  	assign(this, emitter.prototype);
  }
  
  /**
   * Store 'value' for 'key'
   * @param {String} key
   * @param {Object} value
   */
  Application.prototype.set = function (key, value) {
  	// get()
  	if (arguments.length == 1) return this.settings[key];
  
  	this.settings[key] = value;
  };
  
  /**
   * Add one or more 'fn' to middleware pipeline at optional 'path'
   * @param {Function} fn(req, res, next)
   */
  Application.prototype.use = function (/* path, */ fn /* ...fn */) {
  	var offset = 0
  		, path = '/'
  		, fns, path;
  
  	if ('string' == typeof fn) {
  		offset = 1;
  		path = fn;
  	}
  
  	fns = Array.prototype.slice.call(arguments, offset);
  
  	fns.forEach(function (fn) {
  		if (fn instanceof Application) {
  			var app = fn
  				, handler = app.handle;
  			app.mountpath = path;
  			app.parent = this;
  			fn = function mounted_app (req, res, next) {
  				// Change app reference to mounted
  				var orig = req.app;
  				req.app = res.app = app;
  				handler(req, res, function (err) {
  					// Restore app reference when done
  					req.app = res.app = orig;
  					next(err);
  				});
  			};
  		}
  
  		debug('adding application middleware layer with path %s', path);
  		this._router.use(path, fn);
  	}, this);
  };
  
  /**
   * Handle param 'name' with 'fn'
   * @param {String} name
   * @param {Function} fn(req, res, next, value)
   */
  Application.prototype.param = function (name, fn) {
  	this._router.param(name, fn);
  };
  
  /**
   * Add one or more VERB fns at 'path' with strict matching of path
   * @param {String} path
   */
  METHODS.forEach(function (method) {
  	Application.prototype[method] = function (path) {
  		// get/set version
  		if (method == 'get' && arguments.length == 1) return this.set(path);
  
  		this._router[method].apply(this._router, Array.prototype.slice.call(arguments));
  
  		return this;
  	};
  });
  
  /**
   * Start listening for requests
   */
  Application.prototype.listen = function () {
  	if (!this.parent) this.history.listen();
  };
  
  /**
   * Run request/response through router's middleware pipline
   * @param {Request} req
   * @param {Response} res
   * @param {Function} done
   */
  Application.prototype.handle = function (req, res, done) {
  	// Handle external link
  	if ('string' == typeof req) {
  		this.emit('link:external', req);
  	} else {
  		this._router.handle(req, res, done || function () { });
  	}
  };
  
  /**
   * Change/update browser history state
   * @param {String} url
   * @param {String} title
   * @param {Boolean} isUpdate
   */
  Application.prototype.navigateTo = function (url, title, isUpdate) {
  	this[this.parent ? 'parent' : 'history'].navigateTo(url, title, isUpdate);
  };
  
  /**
   * Force browser location change
   * @param {String} url
   * @param {String} title
   */
  Application.prototype.redirectTo = function (url) {
  	this[this.parent ? 'parent' : 'history'].redirectTo(url);
  };
  
  /**
   * Retrieve current context
   * @returns {Object}
   */
  Application.prototype.getCurrentContext = function () {
  	return this[this.parent ? 'parent' : 'history'].getCurrentContext();
  };
  
  /**
   * Refresh current location
   * @returns {Object}
   */
  Application.prototype.refresh = function () {
  	this[this.parent ? 'parent' : 'history'].refresh();
  };
});
require.register('express-client/index.js', function(module, exports, require) {
  'use strict';
  
  var application = require('lib/application.js')
  	, Router = require('lib/router.js');
  
  module.exports = createApplication;
  
  /**
   * Application factory
   */
  function createApplication () {
  	return application();
  }
  
  /**
   * Expose
   */
  module.exports.Router = Router;
});
require.register('lib.js', function(module, exports, require) {
  require('express-client/index.js');
});
require('lib.js');