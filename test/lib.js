/* generated by Buddy */
(function(root) {
	/**
	 * Load or retrieve cached version of requested module with id 'path' or 'path/index'
	 * @param {String} path
	 * @returns {Object}
	 */
	function require (path) {
		// Find in cache
		var m = require.modules[path] || require.modules[path + '/index'];

		if (!m) {
			// Handle versioned modules when called without version number
			var p, idx;
			for (var p in require.modules) {
				if ((idx = p.indexOf('#')) != -1) {
					if (path == p.slice(0, idx)) {
						m = require.modules[p];
						break;
					}
				}
			}
			if (!m) throw new Error("Couldn't find module for: " + path);
		}

		// Instantiate the module if it's export object is not yet defined
		if (!m.exports) {
			// Convert 'lazy' evaluated string to Function
			if ('string' == typeof m) {
				// 'm' is key to raw source
				m = require.modules[path] = new Function('require', 'module', 'exports', require.modules[m]);
			}
			m.exports = {};
			m.filename = path;
			m.call(null, require, m, m.exports);
		}

		// Return the exports object
		return m.exports;
	}

	// Cache of module objects
	require.modules = {};

	/**
	 * Retrieve raw 'lazy' module source
	 * @param {String} path
	 * @returns {String}
	 */
	require.raw = function requireRaw (path) {
		return require.modules['raw:' + path] || '';
	};

	/**
	 * Register a module with id of 'path' and callback of 'fn'
	 * Alternatively accepts 'fn' string for lazy evaluation
	 * @param {String} path
	 * @param {Function|String} fn [signature should be of type (require, module, exports)]
	 */
	require.register = function requireRegister (path, fn) {
		if ('string' == typeof fn) {
			// Store raw source
			var key = 'raw:' + path;
			require.modules[key] = fn;
			require.modules[path] = key;
		} else {
			require.modules[path] = fn;
		}
	};

	// Expose
	root.require = require;

})((typeof window !== 'undefined') ? window : global);
var global = window.global = window;

(function (global) {
  var babelHelpers = global.babelHelpers = {};

  babelHelpers.classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  babelHelpers.createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  babelHelpers.defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  babelHelpers.get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  babelHelpers.inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  babelHelpers.possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  babelHelpers.taggedTemplateLiteral = function (strings, raw) {
    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  };
})(typeof global === "undefined" ? self : global);
require.register('isarray/index.js#0.0.1', function(require, module, exports) {
    module.exports = Array.isArray || function (arr) {
      return Object.prototype.toString.call(arr) == '[object Array]';
    };
    
});
require.register('path-to-regexp/index.js#1.2.1', function(require, module, exports) {
    var isarray = require('isarray/index.js#0.0.1')
    
    /**
     * Expose `pathToRegexp`.
     */
    module.exports = pathToRegexp
    module.exports.parse = parse
    module.exports.compile = compile
    module.exports.tokensToFunction = tokensToFunction
    module.exports.tokensToRegExp = tokensToRegExp
    
    /**
     * The main path matching regexp utility.
     *
     * @type {RegExp}
     */
    var PATH_REGEXP = new RegExp([
      // Match escaped characters that would otherwise appear in future matches.
      // This allows the user to escape special characters that won't transform.
      '(\\\\.)',
      // Match Express-style parameters and un-named parameters with a prefix
      // and optional suffixes. Matches appear as:
      //
      // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
      // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
      // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
      '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))'
    ].join('|'), 'g')
    
    /**
     * Parse a string for the raw tokens.
     *
     * @param  {String} str
     * @return {Array}
     */
    function parse (str) {
      var tokens = []
      var key = 0
      var index = 0
      var path = ''
      var res
    
      while ((res = PATH_REGEXP.exec(str)) != null) {
        var m = res[0]
        var escaped = res[1]
        var offset = res.index
        path += str.slice(index, offset)
        index = offset + m.length
    
        // Ignore already escaped sequences.
        if (escaped) {
          path += escaped[1]
          continue
        }
    
        // Push the current path onto the tokens.
        if (path) {
          tokens.push(path)
          path = ''
        }
    
        var prefix = res[2]
        var name = res[3]
        var capture = res[4]
        var group = res[5]
        var suffix = res[6]
        var asterisk = res[7]
    
        var repeat = suffix === '+' || suffix === '*'
        var optional = suffix === '?' || suffix === '*'
        var delimiter = prefix || '/'
        var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')
    
        tokens.push({
          name: name || key++,
          prefix: prefix || '',
          delimiter: delimiter,
          optional: optional,
          repeat: repeat,
          pattern: escapeGroup(pattern)
        })
      }
    
      // Match any characters still remaining.
      if (index < str.length) {
        path += str.substr(index)
      }
    
      // If the path exists, push it onto the end.
      if (path) {
        tokens.push(path)
      }
    
      return tokens
    }
    
    /**
     * Compile a string to a template function for the path.
     *
     * @param  {String}   str
     * @return {Function}
     */
    function compile (str) {
      return tokensToFunction(parse(str))
    }
    
    /**
     * Expose a method for transforming tokens into the path function.
     */
    function tokensToFunction (tokens) {
      // Compile all the tokens into regexps.
      var matches = new Array(tokens.length)
    
      // Compile all the patterns before compilation.
      for (var i = 0; i < tokens.length; i++) {
        if (typeof tokens[i] === 'object') {
          matches[i] = new RegExp('^' + tokens[i].pattern + '$')
        }
      }
    
      return function (obj) {
        var path = ''
        var data = obj || {}
    
        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i]
    
          if (typeof token === 'string') {
            path += token
    
            continue
          }
    
          var value = data[token.name]
          var segment
    
          if (value == null) {
            if (token.optional) {
              continue
            } else {
              throw new TypeError('Expected "' + token.name + '" to be defined')
            }
          }
    
          if (isarray(value)) {
            if (!token.repeat) {
              throw new TypeError('Expected "' + token.name + '" to not repeat, but received "' + value + '"')
            }
    
            if (value.length === 0) {
              if (token.optional) {
                continue
              } else {
                throw new TypeError('Expected "' + token.name + '" to not be empty')
              }
            }
    
            for (var j = 0; j < value.length; j++) {
              segment = encodeURIComponent(value[j])
    
              if (!matches[i].test(segment)) {
                throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
              }
    
              path += (j === 0 ? token.prefix : token.delimiter) + segment
            }
    
            continue
          }
    
          segment = encodeURIComponent(value)
    
          if (!matches[i].test(segment)) {
            throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
          }
    
          path += token.prefix + segment
        }
    
        return path
      }
    }
    
    /**
     * Escape a regular expression string.
     *
     * @param  {String} str
     * @return {String}
     */
    function escapeString (str) {
      return str.replace(/([.+*?=^!:${}()[\]|\/])/g, '\\$1')
    }
    
    /**
     * Escape the capturing group by escaping special characters and meaning.
     *
     * @param  {String} group
     * @return {String}
     */
    function escapeGroup (group) {
      return group.replace(/([=!:$\/()])/g, '\\$1')
    }
    
    /**
     * Attach the keys as a property of the regexp.
     *
     * @param  {RegExp} re
     * @param  {Array}  keys
     * @return {RegExp}
     */
    function attachKeys (re, keys) {
      re.keys = keys
      return re
    }
    
    /**
     * Get the flags for a regexp from the options.
     *
     * @param  {Object} options
     * @return {String}
     */
    function flags (options) {
      return options.sensitive ? '' : 'i'
    }
    
    /**
     * Pull out keys from a regexp.
     *
     * @param  {RegExp} path
     * @param  {Array}  keys
     * @return {RegExp}
     */
    function regexpToRegexp (path, keys) {
      // Use a negative lookahead to match only capturing groups.
      var groups = path.source.match(/\((?!\?)/g)
    
      if (groups) {
        for (var i = 0; i < groups.length; i++) {
          keys.push({
            name: i,
            prefix: null,
            delimiter: null,
            optional: false,
            repeat: false,
            pattern: null
          })
        }
      }
    
      return attachKeys(path, keys)
    }
    
    /**
     * Transform an array into a regexp.
     *
     * @param  {Array}  path
     * @param  {Array}  keys
     * @param  {Object} options
     * @return {RegExp}
     */
    function arrayToRegexp (path, keys, options) {
      var parts = []
    
      for (var i = 0; i < path.length; i++) {
        parts.push(pathToRegexp(path[i], keys, options).source)
      }
    
      var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))
    
      return attachKeys(regexp, keys)
    }
    
    /**
     * Create a path regexp from string input.
     *
     * @param  {String} path
     * @param  {Array}  keys
     * @param  {Object} options
     * @return {RegExp}
     */
    function stringToRegexp (path, keys, options) {
      var tokens = parse(path)
      var re = tokensToRegExp(tokens, options)
    
      // Attach keys back to the regexp.
      for (var i = 0; i < tokens.length; i++) {
        if (typeof tokens[i] !== 'string') {
          keys.push(tokens[i])
        }
      }
    
      return attachKeys(re, keys)
    }
    
    /**
     * Expose a function for taking tokens and returning a RegExp.
     *
     * @param  {Array}  tokens
     * @param  {Array}  keys
     * @param  {Object} options
     * @return {RegExp}
     */
    function tokensToRegExp (tokens, options) {
      options = options || {}
    
      var strict = options.strict
      var end = options.end !== false
      var route = ''
      var lastToken = tokens[tokens.length - 1]
      var endsWithSlash = typeof lastToken === 'string' && /\/$/.test(lastToken)
    
      // Iterate over the tokens and create our regexp string.
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i]
    
        if (typeof token === 'string') {
          route += escapeString(token)
        } else {
          var prefix = escapeString(token.prefix)
          var capture = token.pattern
    
          if (token.repeat) {
            capture += '(?:' + prefix + capture + ')*'
          }
    
          if (token.optional) {
            if (prefix) {
              capture = '(?:' + prefix + '(' + capture + '))?'
            } else {
              capture = '(' + capture + ')?'
            }
          } else {
            capture = prefix + '(' + capture + ')'
          }
    
          route += capture
        }
      }
    
      // In non-strict mode we allow a slash at the end of match. If the path to
      // match already ends with a slash, we remove it for consistency. The slash
      // is valid at the end of a path match, not in the middle. This is important
      // in non-ending mode, where "/test/" shouldn't match "/test//route".
      if (!strict) {
        route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?'
      }
    
      if (end) {
        route += '$'
      } else {
        // In non-ending mode, we need the capturing groups to match as much as
        // possible by using a positive lookahead to the end or next path segment.
        route += strict && endsWithSlash ? '' : '(?=\\/|$)'
      }
    
      return new RegExp('^' + route, flags(options))
    }
    
    /**
     * Normalize the given path string, returning a regular expression.
     *
     * An empty array can be passed in for the keys, which will hold the
     * placeholder key descriptions. For example, using `/user/:id`, `keys` will
     * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
     *
     * @param  {(String|RegExp|Array)} path
     * @param  {Array}                 [keys]
     * @param  {Object}                [options]
     * @return {RegExp}
     */
    function pathToRegexp (path, keys, options) {
      keys = keys || []
    
      if (!isarray(keys)) {
        options = keys
        keys = []
      } else if (!options) {
        options = {}
      }
    
      if (path instanceof RegExp) {
        return regexpToRegexp(path, keys, options)
      }
    
      if (isarray(path)) {
        return arrayToRegexp(path, keys, options)
      }
    
      return stringToRegexp(path, keys, options)
    }
    
});
require.register('src/lib/layer.js', function(require, module, exports) {
    'use strict';
    
    /**
     * Router layer object
     */
    
    var matcher = require('path-to-regexp/index.js#1.2.1'),
        urlUtils = require('@yr/url-utils/index.js#2.2.0');
    
    /**
     * Instance Factory
     * @param {String} path
     * @param {Function} fn
     * @param {Object} options
     * @returns {Layer}
     */
    module.exports = function (path, fn, options) {
      return new Layer(path, fn, options);
    };
    
    var Layer = function () {
      /**
       * Constructor
       * @param {String} path
       * @param {Function} fn
       * @param {Object} options
       */
    
      function Layer(path, fn, options) {
        babelHelpers.classCallCheck(this, Layer);
    
        // To be filled by matcher
        this.keys = [];
        this.path = null;
        this.params = null;
        this.fn = fn;
        this.name = fn.name ? '<' + fn.name + '>' : '<anonymous>';
        this.fastmatch = path == '/' && !options.end;
        this.regexp = matcher(path, this.keys, options);
      }
    
      /**
       * Determine if this route matches 'path'
       * @param {String} path
       * @returns {Boolean}
       */
    
    
      Layer.prototype.match = function match(path) {
        if (this.fastmatch) {
          this.params = {};
          this.path = '';
          return true;
        }
    
        var mtch = this.regexp.exec(path);
    
        if (!mtch) {
          this.params = null;
          this.path = null;
          return false;
        }
    
        this.params = {};
        this.path = mtch[0];
    
        var n = 0,
            key = void 0,
            val = void 0;
    
        for (var i = 1, len = mtch.length; i < len; ++i) {
          key = this.keys[i - 1];
          val = urlUtils.decode(mtch[i]);
    
          if (key) {
            this.params[key.name] = val;
          } else {
            this.params[n++] = val;
          }
        }
    
        return true;
      };
    
      /**
       * Handle
       * @param {Error} err
       * @param {Request} req
       * @param {Response} res
       * @param {Function} next
       * @returns {null}
       */
    
    
      Layer.prototype.handle = function handle(err, req, res, next) {
        if (err) {
          // Only call if it handles errors
          return this.fn.length > 3 ? this.fn(err, req, res, next) : next(err);
        }
    
        // Skip if error handler
        return this.fn.length < 4 ? this.fn(req, res, next) : next();
      };
    
      return Layer;
    }();
});
require.register('src/lib/router.js', function(require, module, exports) {
    'use strict';
    
    /**
     * Router for handling middleware pipeline.
     * Can be isolated under a specific mount path.
     */
    
    var assign = require('object-assign/index.js#4.0.1'),
        debug = require('debug/browser.js#2.2.0')('express:router'),
        layer = require('src/lib/layer.js'),
        urlUtils = require('@yr/url-utils/index.js#2.2.0'),
        DEFAULTS = {
      mergeParams: true,
      caseSensitive: false,
      strict: false
    };
    
    /**
     * Instance factory
     * @param {Object} [options]
     * @returns {Router}
     */
    module.exports = function (options) {
      return new Router(options);
    };
    
    var Router = function () {
      /**
       * Constructor
       * @param {Object} [options]
       */
    
      function Router(options) {
        babelHelpers.classCallCheck(this, Router);
    
        options = assign({}, DEFAULTS, options);
    
        var boundMethod = this.method.bind(this);
    
        this.all = boundMethod;
        this.get = boundMethod;
        this.post = boundMethod;
        this.handle = this.handle.bind(this);
        this.stack = [];
        this.mergeParams = options.mergeParams;
        // Init matcher options
        this.matcherOpts = {
          sensitive: options.caseSensitive,
          strict: options.strict,
          end: false
        };
        this.strictMatcherOpts = {
          sensitive: options.caseSensitive,
          strict: options.strict,
          end: true
        };
        this.params = null;
      }
    
      /**
       * Handle param 'name' with 'fn'
       * @param {String} name
       * @param {Function} fn(req, res, next, value)
       */
    
    
      Router.prototype.param = function param(name, fn) {
        if (!this.params) this.params = {};
        this.params[name] = fn;
      };
    
      /**
       * Add one or more 'fn' to middleware pipeline at optional 'path'
       * @param {Function} fn
       */
    
    
      Router.prototype.use = function use( /* path, */fn /* ...fn */) {
        var offset = 0,
            path = '/',
            fns = void 0;
    
        if ('string' == typeof fn) {
          offset = 1;
          path = fn;
        }
    
        fns = Array.prototype.slice.call(arguments, offset);
    
        fns.forEach(function (fn) {
          if (fn instanceof Router) {
            fn = fn.handle;
          }
          var lyr = layer(path, fn, this.matcherOpts);
    
          debug('adding router middleware %s with path %s', lyr.name, path);
          this.stack.push(lyr);
        }, this);
      };
    
      /**
       * Register method at 'path'
       * @param {String} path
       */
    
    
      Router.prototype.method = function method(path) {
        var fns = Array.prototype.slice.call(arguments, 1);
    
        fns.forEach(function (fn) {
          var lyr = layer(path, fn, this.strictMatcherOpts);
    
          lyr.route = true;
    
          debug('adding router route %s with path %s', lyr.name, path);
          this.stack.push(lyr);
        }, this);
      };
    
      /**
       * Run request/response through middleware pipline
       * @param {Request} req
       * @param {Response} res
       * @param {Function} done
       */
    
    
      Router.prototype.handle = function handle(req, res, done) {
        var self = this,
            parentUrl = req.baseUrl || '';
    
        var idx = 0,
            processedParams = {},
            removed = '';
    
        // Update done to restore req props
        done = restore(done, req, 'baseUrl', 'next', 'params');
    
        // Setup next layer
        req.next = next;
        req.baseUrl = parentUrl;
    
        next();
    
        function next(err) {
          var lyr = self.stack[idx++],
              layerErr = err;
    
          if (removed.length != 0) {
            debug('untrim %s from url %s', removed, req.path);
            req.baseUrl = parentUrl;
            req.path = urlUtils.join(removed, req.path);
            removed = '';
          }
    
          // Exit
          if (!lyr) return done(err);
    
          // Skip if no match
          if (!lyr.match(req.path)) return next(err);
    
          debug('%s matched layer %s with path %s', req.path, lyr.name, lyr.path);
    
          // Store params
          if (self.mergeParams) {
            if (!req.params) req.params = {};
            assign(req.params, lyr.params);
          } else {
            req.params = lyr.params;
          }
    
          var keys = Object.keys(lyr.params);
    
          // Process params if necessary
          self._processParams(processedParams, req.params, keys, req, res, function (err) {
            if (err) return next(layerErr || err);
            if (!lyr.route) trim(lyr);
            return lyr.handle(layerErr, req, res, next);
          });
        }
    
        function trim(layer) {
          if (layer.path.length != 0) {
            debug('trim %s from url %s', layer.path, req.path);
            removed = layer.path;
            req.path = req.path.substr(removed.length);
            if (req.path.charAt(0) != '/') req.path = '/' + req.path;
    
            req.baseUrl = urlUtils.join(parentUrl, removed);
          }
        }
      };
    
      /**
       * Process middleware matched parameters
       * @param {Object} processedParams
       * @param {Object} params
       * @param {Array} keys
       * @param {Request} req
       * @param {Response} res
       * @param {Function} done(err)
       */
    
    
      Router.prototype._processParams = function _processParams(processedParams, params, keys, req, res, done) {
        var self = this;
    
        var idx = 0;
    
        function next(err) {
          // Stop processing on any error
          if (err) return done(err);
    
          if (idx >= keys.length) return done();
    
          var name = keys[idx++],
              fn = self.params[name];
    
          // Process if match and not already processed
          if (fn && !processedParams[name]) {
            processedParams[name] = true;
            fn(req, res, next, params[name]);
          } else {
            next();
          }
        }
    
        if (this.params && keys.length) {
          next();
        } else {
          done();
        }
      };
    
      return Router;
    }();
    
    /**
     * Restore 'obj' props
     * @param {Function} fn
     * @param {Object} obj
     * @returns {Function}
     */
    
    
    function restore(fn, obj) {
      var props = new Array(arguments.length - 2),
          vals = new Array(arguments.length - 2);
    
      for (var i = 0; i < props.length; i++) {
        props[i] = arguments[i + 2];
        vals[i] = obj[props[i]];
      }
    
      return function () {
        // Restore vals
        for (var _i = 0; _i < props.length; _i++) {
          obj[props[_i]] = vals[_i];
        }
    
        return fn.apply(this, arguments);
      };
    }
});
require.register('object-assign/index.js#4.0.1', function(require, module, exports) {
    /* eslint-disable no-unused-vars */
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    
    function toObject(val) {
    	if (val === null || val === undefined) {
    		throw new TypeError('Object.assign cannot be called with null or undefined');
    	}
    
    	return Object(val);
    }
    
    module.exports = Object.assign || function (target, source) {
    	var from;
    	var to = toObject(target);
    	var symbols;
    
    	for (var s = 1; s < arguments.length; s++) {
    		from = Object(arguments[s]);
    
    		for (var key in from) {
    			if (hasOwnProperty.call(from, key)) {
    				to[key] = from[key];
    			}
    		}
    
    		if (Object.getOwnPropertySymbols) {
    			symbols = Object.getOwnPropertySymbols(from);
    			for (var i = 0; i < symbols.length; i++) {
    				if (propIsEnumerable.call(from, symbols[i])) {
    					to[symbols[i]] = from[symbols[i]];
    				}
    			}
    		}
    	}
    
    	return to;
    };
    
});
require.register('src/lib/response.js', function(require, module, exports) {
    'use strict';
    
    /**
     * Browser response object
     */
    
    var assign = require('object-assign/index.js#4.0.1'),
        _cookie = require('cookie/index.js#0.2.3'),
        Emitter = require('eventemitter3/index.js#1.1.1');
    
    /**
     * Instance factory
     * @returns {Response}
     */
    module.exports = function () {
      return new Response();
    };
    
    var Response = function (_Emitter) {
      babelHelpers.inherits(Response, _Emitter);
    
      /**
       * Constructor
       */
    
      function Response() {
        babelHelpers.classCallCheck(this, Response);
    
        var _this = babelHelpers.possibleConstructorReturn(this, _Emitter.call(this));
    
        _this.app = null;
        _this.req = null;
        _this.reset();
        return _this;
      }
    
      /**
       * Reset state
       */
    
    
      Response.prototype.reset = function reset() {
        this.cached = false;
        this.finished = false;
        this.locals = {};
        this.statusCode = 404;
      };
    
      /**
       * Set status 'code'
       * @param {Number} code
       * @returns {Response}
       */
    
    
      Response.prototype.status = function status(code) {
        this.statusCode = code;
        return this;
      };
    
      /**
       * Send response (last method called in pipeline)
       */
    
    
      Response.prototype.send = function send() {
        // Reset state
        this.req.reset();
        this.status(200);
        this.finished = true;
        this.emit('finish');
      };
    
      /**
       * Redirect to 'url'
       * @param {Number} statusCode
       * @param {String} url
       */
    
    
      Response.prototype.redirect = function redirect(statusCode, url) {
        this.app.redirectTo(url || statusCode);
      };
    
      /**
       * Set cookie
       * @param {String} name
       * @param {String|Object} val
       * @param {Object} options
       * @returns {Response}
       */
    
    
      Response.prototype.cookie = function cookie(name, val, options) {
        options = assign({}, options);
    
        if ('number' == typeof val) val = val.toString();
        if ('object' == typeof val) val = 'j:' + JSON.stringify(val);
    
        if ('maxAge' in options) {
          options.expires = new Date(Date.now() + options.maxAge);
          options.maxAge /= 1000;
        }
    
        if (options.path == null) options.path = '/';
    
        document.cookie = _cookie.serialize(name, String(val), options);
    
        return this;
      };
    
      return Response;
    }(Emitter);
});
require.register('strict-uri-encode/index.js#1.1.0', function(require, module, exports) {
    'use strict';
    module.exports = function (str) {
    	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
    		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
    	});
    };
    
});
require.register('query-string/index.js#3.0.1', function(require, module, exports) {
    'use strict';
    var strictUriEncode = require('strict-uri-encode/index.js#1.1.0');
    
    exports.extract = function (str) {
    	return str.split('?')[1] || '';
    };
    
    exports.parse = function (str) {
    	if (typeof str !== 'string') {
    		return {};
    	}
    
    	str = str.trim().replace(/^(\?|#|&)/, '');
    
    	if (!str) {
    		return {};
    	}
    
    	return str.split('&').reduce(function (ret, param) {
    		var parts = param.replace(/\+/g, ' ').split('=');
    		// Firefox (pre 40) decodes `%3D` to `=`
    		// https://github.com/sindresorhus/query-string/pull/37
    		var key = parts.shift();
    		var val = parts.length > 0 ? parts.join('=') : undefined;
    
    		key = decodeURIComponent(key);
    
    		// missing `=` should be `null`:
    		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
    		val = val === undefined ? null : decodeURIComponent(val);
    
    		if (!ret.hasOwnProperty(key)) {
    			ret[key] = val;
    		} else if (Array.isArray(ret[key])) {
    			ret[key].push(val);
    		} else {
    			ret[key] = [ret[key], val];
    		}
    
    		return ret;
    	}, {});
    };
    
    exports.stringify = function (obj) {
    	return obj ? Object.keys(obj).sort().map(function (key) {
    		var val = obj[key];
    
    		if (val === undefined) {
    			return '';
    		}
    
    		if (val === null) {
    			return key;
    		}
    
    		if (Array.isArray(val)) {
    			return val.slice().sort().map(function (val2) {
    				return strictUriEncode(key) + '=' + strictUriEncode(val2);
    			}).join('&');
    		}
    
    		return strictUriEncode(key) + '=' + strictUriEncode(val);
    	}).filter(function (x) {
    		return x.length > 0;
    	}).join('&') : '';
    };
    
});
require.register('cookie/index.js#0.2.3', function(require, module, exports) {
    /*!    
     * cookie    
     * Copyright(c) 2012-2014 Roman Shtylman    
     * Copyright(c) 2015 Douglas Christopher Wilson    
     * MIT Licensed    
     */    
        
    /**    
     * Module exports.    
     * @public    
     */    
        
    exports.parse = parse;    
    exports.serialize = serialize;    
        
    /**    
     * Module variables.    
     * @private    
     */    
        
    var decode = decodeURIComponent;    
    var encode = encodeURIComponent;    
    var pairSplitRegExp = /; */;    
        
    /**    
     * RegExp to match field-content in RFC 7230 sec 3.2    
     *    
     * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]    
     * field-vchar   = VCHAR / obs-text    
     * obs-text      = %x80-FF    
     */    
        
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;    
        
    /**    
     * Parse a cookie header.    
     *    
     * Parse the given cookie header string into an object    
     * The object has the various cookies as keys(names) => values    
     *    
     * @param {string} str    
     * @param {object} [options]    
     * @return {object}    
     * @public    
     */    
        
    function parse(str, options) {    
      if (typeof str !== 'string') {    
        throw new TypeError('argument str must be a string');    
      }    
        
      var obj = {}    
      var opt = options || {};    
      var pairs = str.split(pairSplitRegExp);    
      var dec = opt.decode || decode;    
        
      pairs.forEach(function(pair) {    
        var eq_idx = pair.indexOf('=')    
        
        // skip things that don't look like key=value    
        if (eq_idx < 0) {    
          return;    
        }    
        
        var key = pair.substr(0, eq_idx).trim()    
        var val = pair.substr(++eq_idx, pair.length).trim();    
        
        // quoted values    
        if ('"' == val[0]) {    
          val = val.slice(1, -1);    
        }    
        
        // only assign once    
        if (undefined == obj[key]) {    
          obj[key] = tryDecode(val, dec);    
        }    
      });    
        
      return obj;    
    }    
        
    /**    
     * Serialize data into a cookie header.    
     *    
     * Serialize the a name value pair into a cookie string suitable for    
     * http headers. An optional options object specified cookie parameters.    
     *    
     * serialize('foo', 'bar', { httpOnly: true })    
     *   => "foo=bar; httpOnly"    
     *    
     * @param {string} name    
     * @param {string} val    
     * @param {object} [options]    
     * @return {string}    
     * @public    
     */    
        
    function serialize(name, val, options) {    
      var opt = options || {};    
      var enc = opt.encode || encode;    
        
      if (!fieldContentRegExp.test(name)) {    
        throw new TypeError('argument name is invalid');    
      }    
        
      var value = enc(val);    
        
      if (value && !fieldContentRegExp.test(value)) {    
        throw new TypeError('argument val is invalid');    
      }    
        
      var pairs = [name + '=' + value];    
        
      if (null != opt.maxAge) {    
        var maxAge = opt.maxAge - 0;    
        if (isNaN(maxAge)) throw new Error('maxAge should be a Number');    
        pairs.push('Max-Age=' + Math.floor(maxAge));    
      }    
        
      if (opt.domain) {    
        if (!fieldContentRegExp.test(opt.domain)) {    
          throw new TypeError('option domain is invalid');    
        }    
        
        pairs.push('Domain=' + opt.domain);    
      }    
        
      if (opt.path) {    
        if (!fieldContentRegExp.test(opt.path)) {    
          throw new TypeError('option path is invalid');    
        }    
        
        pairs.push('Path=' + opt.path);    
      }    
        
      if (opt.expires) pairs.push('Expires=' + opt.expires.toUTCString());    
      if (opt.httpOnly) pairs.push('HttpOnly');    
      if (opt.secure) pairs.push('Secure');    
      if (opt.firstPartyOnly) pairs.push('First-Party-Only');    
        
      return pairs.join('; ');    
    }    
        
    /**    
     * Try decoding a string using a decoding function.    
     *    
     * @param {string} str    
     * @param {function} decode    
     * @private    
     */    
        
    function tryDecode(str, decode) {    
      try {    
        return decode(str);    
      } catch (e) {    
        return str;    
      }    
    }    
    
});
require.register('src/lib/request.js', function(require, module, exports) {
    'use strict';
    
    /**
     * Browser request object
     */
    
    var cookie = require('cookie/index.js#0.2.3'),
        Emitter = require('eventemitter3/index.js#1.1.1'),
        qsParse = require('query-string/index.js#3.0.1').parse,
        urlUtils = require('@yr/url-utils/index.js#2.2.0'),
        RE_SPLIT = /[?#]/;
    
    /**
     * Instance factory
     * @param {String} url
     * @param {Boolean} bootstrap
     * @returns {Request}
     */
    module.exports = function (url, bootstrap) {
      return new Request(url, bootstrap);
    };
    
    var Request = function (_Emitter) {
      babelHelpers.inherits(Request, _Emitter);
    
      /**
       * Constructor
       * @param {String} url
       * @param {Boolean} bootstrap
       */
    
      function Request(url, bootstrap) {
        babelHelpers.classCallCheck(this, Request);
    
        var _this = babelHelpers.possibleConstructorReturn(this, _Emitter.call(this));
    
        url = url ? urlUtils.encode(url) : urlUtils.getCurrent();
    
        var path = url.split(RE_SPLIT),
            qs = ~url.indexOf('?') && path[1] || '',
            hash = ~url.indexOf('#') && path[path.length - 1] || '';
    
        _this.app = null;
        _this.cookies = cookie.parse(document.cookie);
        _this.path = urlUtils.sanitize(path[0]);
        _this.hash = qsParse(hash);
        _this.query = qsParse(qs);
        _this.querystring = qs;
        _this.search = qs ? '?' + qs : '';
        // Ignore hash
        _this.url = _this.originalUrl = url.split('#')[0];
        _this.reset(bootstrap);
        return _this;
      }
    
      /**
       * Abort response
       */
    
    
      Request.prototype.abort = function abort() {
        this.reset();
        this.emit('close');
      };
    
      /**
       * Reset state
       * @param {Boolean} bootstrap
       */
    
    
      Request.prototype.reset = function reset(bootstrap) {
        this.baseUrl = '';
        this.bootstrap = bootstrap || false;
        this.cached = false;
        this.path = urlUtils.sanitize(this.originalUrl.split('?')[0]);
        this.params = null;
      };
    
      return Request;
    }(Emitter);
});
require.register('@yr/runtime/index.js#1.2.0', function(require, module, exports) {
    'use strict';
    
    /**
     * Determine if the current runtime is server or browser
     * https://github.com/yr/runtime
     * @copyright Yr
     * @license MIT
     */
    
    var isNode = (typeof process !== 'undefined'
      && {}.toString.call(process) === '[object process]');
    
    exports.isServer = isNode;
    exports.isBrowser = !isNode;
});
require.register('@yr/url-utils/index.js#2.2.0', function(require, module, exports) {
    'use strict';
    
    /**
     * URL/path utilities
     * https://github.com/yr/url-utils
     * @copyright Yr
     * @license MIT
     */
    
    var isServer = require('@yr/runtime/index.js#1.2.0').isServer,
        RE_TEMPLATE = /\{([0-9a-zA-Z]+)\}/g,
        RE_URL = /([^:])(\/{2,})/g;
    
    /**
     * Join url segments
     * Handles strings or arrays of strings
     * @returns {String}
     */
    exports.join = function () /* ...segments */{
      // Non-leaky conversion of arguments to array
      var n = arguments.length,
          segments = new Array(n);
    
      for (var i = 0; i < n; i++) {
        segments[i] = arguments[i];
      }
    
      var leading = '',
          path = [];
    
      function add(seg) {
        if (seg) {
          // Handle leading slash
          if (seg.charAt(0) == '/') {
            // Keep if first segment
            if (!path.length) leading = '/';
            seg = seg.slice(1);
          }
          if (seg.length) path.push(exports.sanitize(seg));
        }
      }
    
      if (segments.length) {
        segments.forEach(function (segment) {
          // Handle array
          if (Array.isArray(segment)) {
            segment.forEach(add);
          } else {
            add(segment);
          }
        });
    
        return leading + path.join('/');
      }
    
      return '';
    };
    
    /**
     * Add query parameters to url in alphabetical order
     * Handles undefined query parameters
     * @param {String} url
     * @param {Object} query
     * @returns {String}
     */
    exports.query = function (url, query) {
      var delimit = '?';
    
      var sorted = [];
    
      function append(q) {
        if (url.charAt(url.length - 1) != delimit) url += '&';
        url += q + '=' + query[q];
      }
    
      if (url && query) {
        url = exports.sanitize(url);
        sorted = Object.keys(query).sort();
        if (!sorted.length) return '';
        // Add delimiter
        url += delimit;
        // Append queries
        sorted.forEach(function (q) {
          if (query[q] != null) append(q);
        });
    
        return exports.encode(url);
      }
    
      return '';
    };
    
    /**
     * Remove trailing '/' from 'url'
     * @param {String} url
     * @returns {String}
     */
    exports.sanitize = function (url) {
      if (url && url != '/') {
        url = url.replace(RE_URL, '$1/');
        if (url.charAt(url.length - 1) == '/') url = url.slice(0, -1);
      }
    
      return url || '';
    };
    
    /**
     * Decode 'url'
     * @param {String} url
     * @returns {String}
     */
    exports.decode = function (url) {
      if ('string' == typeof url) {
        try {
          url = decodeURI(url);
          return url;
        } catch (err) {
          throw new Error('failed to decode "' + url + '"');
        }
      }
    
      return url;
    };
    
    /**
     * Encode 'url'
     * @param {String} url
     * @returns {String}
     */
    exports.encode = function (url) {
      if ('string' == typeof url) {
        try {
          // Try to decode first in-case url is encoded
          try {
            url = decodeURI(url);
          } catch (err) {
            // Do nothing
          }
          return encodeURI(url);
        } catch (err) {
          throw new Error('failed to encode"' + url + '"');
        }
      }
    
      return url;
    };
    
    /**
     * Retrieve current browser path
     * @returns {String}
     */
    exports.getCurrent = function () {
      return !isServer ? exports.encode(window.location.pathname + window.location.search + window.location.hash) : '';
    };
    
    /**
     * Substitute 'data' values in 'str' template
     * @param {String} str
     * @param {Object} data
     * @param {Object} options
     * @returns {String}
     */
    exports.template = function (str, data, options) {
      options = options || {};
      str = String(str).replace(RE_TEMPLATE, function (match, prop, idx) {
        return data && data[prop] != null ? data[prop] : options.loose ? match : '';
      });
    
      return exports.sanitize(str);
    };
});
require.register('src/lib/history.js', function(require, module, exports) {
    'use strict';
    
    /**
     * Manager for browser history.
     * Generates/stores request/response context for current url,
     * and responds to changes to state via History API.
     */
    
    var debug = require('debug/browser.js#2.2.0')('express:history'),
        urlUtils = require('@yr/url-utils/index.js#2.2.0');
    
    var bootstrap = true;
    
    /**
     * Instance factory
     * @param {Function} request
     * @param {Function} response
     * @param {Function} fn(req, res)
     * @returns {History}
     */
    module.exports = function (request, response, fn) {
      return new History(request, response, fn);
    };
    
    var History = function () {
      /**
       * Constructor
       * @param {Function} request(url)
       * @param {Function} response
       * @param {Function} fn(req, res)
       */
    
      function History(request, response, fn) {
        babelHelpers.classCallCheck(this, History);
    
        this.cache = {};
        this.current = '';
        this.running = false;
        this.request = request;
        this.response = response;
        this.fn = fn;
        this.onClick = this.onClick.bind(this);
        this.onPopstate = this.onPopstate.bind(this);
        this.navigateTo = this.navigateTo.bind(this);
        this.redirectTo = this.redirectTo.bind(this);
        this.getCurrentContext = this.getCurrentContext.bind(this);
      }
    
      /**
       * Notify on current context,
       * and begin listening for history changes
       * @returns {History}
       */
    
    
      History.prototype.listen = function listen() {
        var _this = this;
    
        // Handle current history state (triggers notification)
        var ctx = this.handle();
    
        if (!this.running && ctx) {
          // Test History API availability
          if (hasHistory()) {
            // Delay to prevent premature trigger when navigating back from nothing
            setTimeout(function () {
              window.addEventListener('click', _this.onClick, false);
              window.addEventListener('popstate', _this.onPopstate, false);
              _this.running = true;
            }, 500);
    
            // Update so that popstate will trigger for this route
            window.history.replaceState({}, document.title);
    
            debug('listening with history API');
          }
        }
    
        return this;
      };
    
      /**
       * Create a new or updated history state at 'url' with 'title'
       * @param {String} url
       * @param {String} title
       * @param {Boolean} isUpdate
       * @param {Boolean} noScroll
       */
    
    
      History.prototype.navigateTo = function navigateTo(url, title, isUpdate, noScroll) {
        // Only navigate if not same as current
        if (url != urlUtils.getCurrent()) {
          if (this.running) {
            // Will throw if malformed
            url = urlUtils.encode(url);
    
            debug('navigate to: %s', url);
    
            window.history[isUpdate ? 'replaceState' : 'pushState']({}, title, url);
            if (title) document.title = title;
            this.handle(url, noScroll);
          } else {
            this.redirectTo(url);
          }
        }
      };
    
      /**
       * Stop history management by redirecting to 'url'
       * @param {String} url
       */
    
    
      History.prototype.redirectTo = function redirectTo(url) {
        this.destroy();
        window.location = urlUtils.encode(url);
      };
    
      /**
       * Force a re-handle of current context
       */
    
    
      History.prototype.refresh = function refresh() {
        var ctx = this.getCurrentContext();
    
        // Undo pipeline modifications
        ctx.req.reset();
        ctx.res.reset();
        this.fn(ctx.req, ctx.res);
      };
    
      /**
       * Retrieve current context
       * @returns {Object}
       */
    
    
      History.prototype.getCurrentContext = function getCurrentContext() {
        return this.cache[this.current];
      };
    
      /**
       * Stop listening for history updates
       */
    
    
      History.prototype.destroy = function destroy() {
        if (this.running) {
          window.removeEventListener('click', this.onClick, false);
          window.removeEventListener('popstate', this.onPopstate, false);
          this.cache = null;
          this.running = false;
        }
      };
    
      /**
       * Handle history change and notify
       * @param {String} [url]
       * @param {Boolean} [noScroll]
       * @returns {Object}
       */
    
    
      History.prototype.handle = function handle(url, noScroll) {
        var ctx = {},
            req = void 0,
            res = void 0;
    
        try {
          url = url ? urlUtils.encode(url) : urlUtils.getCurrent();
        } catch (err) {
          // Error encoding url
          return this.redirectTo(url);
        }
    
        // Do nothing if current url is the same
        if (this.current && this.current === url) return;
    
        if (this.cache[url]) {
          ctx = this.cache[url];
          req = ctx.req;
          res = ctx.res;
          // Always reset in order to undo pipeline modifications
          req.reset();
          res.reset();
          // Set flag for use downstream
          req.cached = res.cached = true;
          debug('context retrieved from cache: %s', url);
        } else {
          req = this.request(url, bootstrap);
          res = this.response();
          debug('generating new context: %s', url);
        }
        res.req = req;
        ctx.req = req;
        ctx.res = res;
        this.cache[url] = ctx;
    
        // Abort if current request/response is not finished
        if (this.current && !this.cache[this.current].res.finished) {
          this.cache[this.current].req.abort();
          this.cache[this.current].res.reset();
        }
    
        // Store reference to current
        this.current = url;
    
        // Set scroll position to top if not bootstrap or overridden
        if (!bootstrap && !noScroll) window.scrollTo(0, 0);
    
        this.fn(req, res);
    
        // Make sure only first request flagged as bootstrap
        bootstrap = false;
    
        return ctx;
      };
    
      /**
       * Handle history change via 'popstate' event
       * @param {Object} evt
       */
    
    
      History.prototype.onPopstate = function onPopstate(evt) {
        // Prevent initial page load from triggering on some platforms when no state
        if (evt.state && this.running) {
          this.handle();
        }
      };
    
      /**
       * Handle click event
       * @param {Object} evt
       * @returns {null}
       */
    
    
      History.prototype.onClick = function onClick(evt) {
        var which = null == evt.which ? evt.button : evt.which;
    
        var el = evt.target;
    
        // Modifiers present
        if (which != 1) return;
        if (evt.metaKey || evt.ctrlKey || evt.shiftKey) return;
        if (evt.defaultPrevented) return;
    
        // Find anchor
        // svg elements on some platforms don't have nodeNames
        while (el && (el.nodeName == null || 'A' != el.nodeName.toUpperCase())) {
          el = el.parentNode;
        }
    
        // Anchor not found
        if (!el || 'A' != el.nodeName.toUpperCase()) return;
    
        // Cross origin
        if (!sameOrigin(el.href)) return this.fn(el.href);
    
        // IE11 prefixes extra slash on absolute links
        var path = (el.pathname + el.search).replace(/\/\//, '/'),
            isSameAsCurrent = path == urlUtils.getCurrent();
    
        // Anchor target on same page
        if (isSameAsCurrent && 'string' == typeof el.hash && el.hash) return;
    
        evt.preventDefault();
    
        // Same as current
        if (isSameAsCurrent) return;
    
        // Blur focus
        el.blur();
    
        debug('click event intercepted from %s', el);
        this.navigateTo(path);
      };
    
      return History;
    }();
    
    /**
     * Test for history API (Modernizr)
     * @returns {Boolean}
     */
    
    
    function hasHistory() {
      var ua = navigator.userAgent;
    
      // Stock android browser 2.2 & 2.3 & 4.0.x are buggy, ignore
      if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
      // Chrome identifies itself as 'Mobile Safari'
      ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
        return false;
      }
    
      // Usual test
      return window.history && 'pushState' in window.history;
    }
    
    /**
     * Check if 'url' is from same origin
     * @param {String} url
     * @returns {Boolean}
     */
    function sameOrigin(url) {
      var origin = location.protocol + '//' + location.hostname;
    
      if (location.port) origin += ':' + location.port;
      return url && url.indexOf(origin) == 0;
    }
});
require.register('eventemitter3/index.js#1.1.1', function(require, module, exports) {
    'use strict';
    
    //
    // We store our EE objects in a plain object whose properties are event names.
    // If `Object.create(null)` is not supported we prefix the event names with a
    // `~` to make sure that the built-in object properties are not overridden or
    // used as an attack vector.
    // We also assume that `Object.create(null)` is available when the event name
    // is an ES6 Symbol.
    //
    var prefix = typeof Object.create !== 'function' ? '~' : false;
    
    /**
     * Representation of a single EventEmitter function.
     *
     * @param {Function} fn Event handler to be called.
     * @param {Mixed} context Context for function execution.
     * @param {Boolean} once Only emit once
     * @api private
     */
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    
    /**
     * Minimal EventEmitter interface that is molded against the Node.js
     * EventEmitter interface.
     *
     * @constructor
     * @api public
     */
    function EventEmitter() { /* Nothing to set */ }
    
    /**
     * Holds the assigned EventEmitters by name.
     *
     * @type {Object}
     * @private
     */
    EventEmitter.prototype._events = undefined;
    
    /**
     * Return a list of assigned event listeners.
     *
     * @param {String} event The events that should be listed.
     * @param {Boolean} exists We only need to know if there are listeners.
     * @returns {Array|Boolean}
     * @api public
     */
    EventEmitter.prototype.listeners = function listeners(event, exists) {
      var evt = prefix ? prefix + event : event
        , available = this._events && this._events[evt];
    
      if (exists) return !!available;
      if (!available) return [];
      if (available.fn) return [available.fn];
    
      for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
        ee[i] = available[i].fn;
      }
    
      return ee;
    };
    
    /**
     * Emit an event to all registered event listeners.
     *
     * @param {String} event The name of the event.
     * @returns {Boolean} Indication if we've emitted an event.
     * @api public
     */
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
    
      if (!this._events || !this._events[evt]) return false;
    
      var listeners = this._events[evt]
        , len = arguments.length
        , args
        , i;
    
      if ('function' === typeof listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
    
        switch (len) {
          case 1: return listeners.fn.call(listeners.context), true;
          case 2: return listeners.fn.call(listeners.context, a1), true;
          case 3: return listeners.fn.call(listeners.context, a1, a2), true;
          case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
    
        for (i = 1, args = new Array(len -1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
    
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length
          , j;
    
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
    
          switch (len) {
            case 1: listeners[i].fn.call(listeners[i].context); break;
            case 2: listeners[i].fn.call(listeners[i].context, a1); break;
            case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
            default:
              if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
    
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
    
      return true;
    };
    
    /**
     * Register a new EventListener for the given event.
     *
     * @param {String} event Name of the event.
     * @param {Functon} fn Callback function.
     * @param {Mixed} context The context of the function.
     * @api public
     */
    EventEmitter.prototype.on = function on(event, fn, context) {
      var listener = new EE(fn, context || this)
        , evt = prefix ? prefix + event : event;
    
      if (!this._events) this._events = prefix ? {} : Object.create(null);
      if (!this._events[evt]) this._events[evt] = listener;
      else {
        if (!this._events[evt].fn) this._events[evt].push(listener);
        else this._events[evt] = [
          this._events[evt], listener
        ];
      }
    
      return this;
    };
    
    /**
     * Add an EventListener that's only called once.
     *
     * @param {String} event Name of the event.
     * @param {Function} fn Callback function.
     * @param {Mixed} context The context of the function.
     * @api public
     */
    EventEmitter.prototype.once = function once(event, fn, context) {
      var listener = new EE(fn, context || this, true)
        , evt = prefix ? prefix + event : event;
    
      if (!this._events) this._events = prefix ? {} : Object.create(null);
      if (!this._events[evt]) this._events[evt] = listener;
      else {
        if (!this._events[evt].fn) this._events[evt].push(listener);
        else this._events[evt] = [
          this._events[evt], listener
        ];
      }
    
      return this;
    };
    
    /**
     * Remove event listeners.
     *
     * @param {String} event The event we want to remove.
     * @param {Function} fn The listener that we need to find.
     * @param {Mixed} context Only remove listeners matching this context.
     * @param {Boolean} once Only remove once listeners.
     * @api public
     */
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
    
      if (!this._events || !this._events[evt]) return this;
    
      var listeners = this._events[evt]
        , events = [];
    
      if (fn) {
        if (listeners.fn) {
          if (
               listeners.fn !== fn
            || (once && !listeners.once)
            || (context && listeners.context !== context)
          ) {
            events.push(listeners);
          }
        } else {
          for (var i = 0, length = listeners.length; i < length; i++) {
            if (
                 listeners[i].fn !== fn
              || (once && !listeners[i].once)
              || (context && listeners[i].context !== context)
            ) {
              events.push(listeners[i]);
            }
          }
        }
      }
    
      //
      // Reset the array, or remove it completely if we have no more listeners.
      //
      if (events.length) {
        this._events[evt] = events.length === 1 ? events[0] : events;
      } else {
        delete this._events[evt];
      }
    
      return this;
    };
    
    /**
     * Remove all listeners or only the listeners for the specified event.
     *
     * @param {String} event The event want to remove all listeners for.
     * @api public
     */
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      if (!this._events) return this;
    
      if (event) delete this._events[prefix ? prefix + event : event];
      else this._events = prefix ? {} : Object.create(null);
    
      return this;
    };
    
    //
    // Alias methods names because people roll like that.
    //
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    
    //
    // This function doesn't apply anymore.
    //
    EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
      return this;
    };
    
    //
    // Expose the prefix.
    //
    EventEmitter.prefixed = prefix;
    
    //
    // Expose the module.
    //
    if ('undefined' !== typeof module) {
      module.exports = EventEmitter;
    }
    
});
require.register('ms/index.js#0.7.1', function(require, module, exports) {
    /**
     * Helpers.
     */
    
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    
    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} options
     * @return {String|Number}
     * @api public
     */
    
    module.exports = function(val, options){
      options = options || {};
      if ('string' == typeof val) return parse(val);
      return options.long
        ? long(val)
        : short(val);
    };
    
    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */
    
    function parse(str) {
      str = '' + str;
      if (str.length > 10000) return;
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) return;
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
      }
    }
    
    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function short(ms) {
      if (ms >= d) return Math.round(ms / d) + 'd';
      if (ms >= h) return Math.round(ms / h) + 'h';
      if (ms >= m) return Math.round(ms / m) + 'm';
      if (ms >= s) return Math.round(ms / s) + 's';
      return ms + 'ms';
    }
    
    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function long(ms) {
      return plural(ms, d, 'day')
        || plural(ms, h, 'hour')
        || plural(ms, m, 'minute')
        || plural(ms, s, 'second')
        || ms + ' ms';
    }
    
    /**
     * Pluralization helper.
     */
    
    function plural(ms, n, name) {
      if (ms < n) return;
      if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
      return Math.ceil(ms / n) + ' ' + name + 's';
    }
    
});
require.register('debug/debug.js#2.2.0', function(require, module, exports) {
    
    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    
    exports = module.exports = debug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require('ms/index.js#0.7.1');
    
    /**
     * The currently active debug mode names, and names to skip.
     */
    
    exports.names = [];
    exports.skips = [];
    
    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lowercased letter, i.e. "n".
     */
    
    exports.formatters = {};
    
    /**
     * Previously assigned color.
     */
    
    var prevColor = 0;
    
    /**
     * Previous log timestamp.
     */
    
    var prevTime;
    
    /**
     * Select a color.
     *
     * @return {Number}
     * @api private
     */
    
    function selectColor() {
      return exports.colors[prevColor++ % exports.colors.length];
    }
    
    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */
    
    function debug(namespace) {
    
      // define the `disabled` version
      function disabled() {
      }
      disabled.enabled = false;
    
      // define the `enabled` version
      function enabled() {
    
        var self = enabled;
    
        // set `diff` timestamp
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
    
        // add the `color` if not set
        if (null == self.useColors) self.useColors = exports.useColors();
        if (null == self.color && self.useColors) self.color = selectColor();
    
        var args = Array.prototype.slice.call(arguments);
    
        args[0] = exports.coerce(args[0]);
    
        if ('string' !== typeof args[0]) {
          // anything else let's inspect with %o
          args = ['%o'].concat(args);
        }
    
        // apply any `formatters` transformations
        var index = 0;
        args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
          // if we encounter an escaped % then don't increase the array index
          if (match === '%%') return match;
          index++;
          var formatter = exports.formatters[format];
          if ('function' === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);
    
            // now we need to remove `args[index]` since it's inlined in the `format`
            args.splice(index, 1);
            index--;
          }
          return match;
        });
    
        if ('function' === typeof exports.formatArgs) {
          args = exports.formatArgs.apply(self, args);
        }
        var logFn = enabled.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }
      enabled.enabled = true;
    
      var fn = exports.enabled(namespace) ? enabled : disabled;
    
      fn.namespace = namespace;
    
      return fn;
    }
    
    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */
    
    function enable(namespaces) {
      exports.save(namespaces);
    
      var split = (namespaces || '').split(/[\s,]+/);
      var len = split.length;
    
      for (var i = 0; i < len; i++) {
        if (!split[i]) continue; // ignore empty strings
        namespaces = split[i].replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }
    
    /**
     * Disable debug output.
     *
     * @api public
     */
    
    function disable() {
      exports.enable('');
    }
    
    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */
    
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    
    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */
    
    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
    
});
require.register('debug/browser.js#2.2.0', function(require, module, exports) {
    
    /**
     * This is the web browser implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    
    exports = module.exports = require('debug/debug.js#2.2.0');
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = 'undefined' != typeof chrome
                   && 'undefined' != typeof chrome.storage
                      ? chrome.storage.local
                      : localstorage();
    
    /**
     * Colors.
     */
    
    exports.colors = [
      'lightseagreen',
      'forestgreen',
      'goldenrod',
      'dodgerblue',
      'darkorchid',
      'crimson'
    ];
    
    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */
    
    function useColors() {
      // is webkit? http://stackoverflow.com/a/16459606/376773
      return ('WebkitAppearance' in document.documentElement.style) ||
        // is firebug? http://stackoverflow.com/a/398120/376773
        (window.console && (console.firebug || (console.exception && console.table))) ||
        // is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
    }
    
    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */
    
    exports.formatters.j = function(v) {
      return JSON.stringify(v);
    };
    
    
    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */
    
    function formatArgs() {
      var args = arguments;
      var useColors = this.useColors;
    
      args[0] = (useColors ? '%c' : '')
        + this.namespace
        + (useColors ? ' %c' : ' ')
        + args[0]
        + (useColors ? '%c ' : ' ')
        + '+' + exports.humanize(this.diff);
    
      if (!useColors) return args;
    
      var c = 'color: ' + this.color;
      args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
    
      // the final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-z%]/g, function(match) {
        if ('%%' === match) return;
        index++;
        if ('%c' === match) {
          // we only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });
    
      args.splice(lastC, 0, c);
      return args;
    }
    
    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */
    
    function log() {
      // this hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return 'object' === typeof console
        && console.log
        && Function.prototype.apply.call(console.log, console, arguments);
    }
    
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem('debug');
        } else {
          exports.storage.debug = namespaces;
        }
      } catch(e) {}
    }
    
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch(e) {}
      return r;
    }
    
    /**
     * Enable namespaces listed in `localStorage.debug` initially.
     */
    
    exports.enable(load());
    
    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */
    
    function localstorage(){
      try {
        return window.localStorage;
      } catch (e) {}
    }
    
});
require.register('src/lib/application.js', function(require, module, exports) {
    'use strict';
    
    /**
     * Browser application
     */
    
    var debug = require('debug/browser.js#2.2.0')('express:application'),
        Emitter = require('eventemitter3/index.js#1.1.1'),
        history = require('src/lib/history.js'),
        request = require('src/lib/request.js'),
        response = require('src/lib/response.js'),
        router = require('src/lib/router.js');
    
    /**
     * Instance factory
     * @returns {Application}
     */
    module.exports = function () {
      return new Application();
    };
    
    var Application = function (_Emitter) {
      babelHelpers.inherits(Application, _Emitter);
    
      /**
       * Constructor
       */
    
      function Application() {
        babelHelpers.classCallCheck(this, Application);
    
        var _this = babelHelpers.possibleConstructorReturn(this, _Emitter.call(this));
    
        _this.settings = {
          env: undefined || 'development'
        };
        _this.cache = {};
        _this.locals = {};
        _this.mountpath = '/';
        _this._router = router({
          caseSensitive: false,
          strict: false,
          mergeParams: true
        });
        _this.parent = null;
    
        _this.handle = _this.handle.bind(_this);
        _this.navigateTo = _this.navigateTo.bind(_this);
        _this.redirectTo = _this.redirectTo.bind(_this);
        _this.getCurrentContext = _this.getCurrentContext.bind(_this);
        _this.refresh = _this.refresh.bind(_this);
    
        // Create request/response factories
        var app = _this,
            req = function req(url, bootstrap) {
          var req = request(url, bootstrap);
          req.app = app;
          return req;
        },
            res = function res() {
          var res = response();
          res.app = app;
          return res;
        };
    
        _this.history = history(req, res, _this.handle);
    
        // Route ALL/POST methods to router
        _this.all = _this._router.all.bind(_this._router);
        _this.post = _this._router.post.bind(_this._router);
        return _this;
      }
    
      /**
       * Store 'value' for 'key'
       * @param {String} key
       * @param {Object} value
       * @returns {Object}
       */
    
    
      Application.prototype.set = function set(key, value) {
        // get()
        if (arguments.length == 1) return this.settings[key];
    
        this.settings[key] = value;
      };
    
      /**
       * Add one or more 'fn' to middleware pipeline at optional 'path'
       * @param {Function} fn(req, res, next)
       */
    
    
      Application.prototype.use = function use( /* path, */fn /* ...fn */) {
        var offset = 0,
            path = '/',
            fns = void 0;
    
        if ('string' == typeof fn) {
          offset = 1;
          path = fn;
        }
    
        fns = Array.prototype.slice.call(arguments, offset);
    
        fns.forEach(function (fn) {
          var _this2 = this;
    
          if (fn instanceof Application) {
            (function () {
              var app = fn,
                  handler = app.handle;
    
              app.mountpath = path;
              app.parent = _this2;
              fn = function mounted_app(req, res, next) {
                // Change app reference to mounted
                var orig = req.app;
    
                req.app = res.app = app;
                handler(req, res, function (err) {
                  // Restore app reference when done
                  req.app = res.app = orig;
                  next(err);
                });
              };
            })();
          }
    
          debug('adding application middleware layer with path %s', path);
          this._router.use(path, fn);
        }, this);
      };
    
      /**
       * Add GET at 'path' with strict matching of path
       * @param {String} path
       * @returns {Object}
       */
    
    
      Application.prototype.get = function get(path) {
        // Not verb, only get/set
        if (arguments.length == 1) return this.set(path);
    
        this._router.get.apply(this._router, Array.prototype.slice.call(arguments));
    
        return this;
      };
    
      /**
       * Handle param 'name' with 'fn'
       * @param {String} name
       * @param {Function} fn(req, res, next, value)
       */
    
    
      Application.prototype.param = function param(name, fn) {
        this._router.param(name, fn);
      };
    
      /**
       * Start listening for requests
       */
    
    
      Application.prototype.listen = function listen() {
        if (!this.parent) this.history.listen();
      };
    
      /**
       * Run request/response through router's middleware pipline
       * @param {Request} req
       * @param {Response} res
       * @param {Function} done
       */
    
    
      Application.prototype.handle = function handle(req, res, done) {
        // Handle external link
        if ('string' == typeof req) {
          _Emitter.prototype.emit.call(this, 'link:external', req);
        } else {
          this._router.handle(req, res, done || function () {});
        }
      };
    
      /**
       * Change/update browser history state
       * @param {String} url
       * @param {String} title
       * @param {Boolean} isUpdate
       * @param {Boolean} noScroll
       */
    
    
      Application.prototype.navigateTo = function navigateTo(url, title, isUpdate, noScroll) {
        this[this.parent ? 'parent' : 'history'].navigateTo(url, title, isUpdate, noScroll);
      };
    
      /**
       * Force browser location change
       * @param {String} url
       * @param {String} title
       */
    
    
      Application.prototype.redirectTo = function redirectTo(url) {
        this[this.parent ? 'parent' : 'history'].redirectTo(url);
      };
    
      /**
       * Retrieve current context
       * @returns {Object}
       */
    
    
      Application.prototype.getCurrentContext = function getCurrentContext() {
        return this[this.parent ? 'parent' : 'history'].getCurrentContext();
      };
    
      /**
       * Refresh current location
       */
    
    
      Application.prototype.refresh = function refresh() {
        this[this.parent ? 'parent' : 'history'].refresh();
      };
    
      return Application;
    }(Emitter);
});
require.register('src/index.js', function(require, module, exports) {
    'use strict';
    
    /**
     * An express.js framework for the browser
     * https://github.com/yr/express-client
     * @copyright Yr
     * @license MIT
     */
    
    var application = require('src/lib/application.js'),
        Router = require('src/lib/router.js');
    
    module.exports = createApplication;
    
    /**
     * Application factory
     * @returns {Application}
     */
    function createApplication() {
      return application();
    }
    
    /**
     * Expose
     */
    module.exports.Router = Router;
});

require('src/index.js');