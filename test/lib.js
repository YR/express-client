/* generated by Buddy 3.0.0-beta-1 */

(function(root) {
	// Load or return cached version of requested module with id 'path' or 'path/index'
	// @param {String} path
	// @return {Object}
	function require (path) {
		// Convert relative path to absolute for cases where 'require' has not been resolved
		// For example, called from outside of a module
		if (!this.module && path.charAt(0) == '.') {
			path = path.slice((path.indexOf('..') === 0) ? 3 : 2);
		}
		// Find in cache
		var m = require.modules[path] || require.modules[path + '/index'];
		if (!m) {
			// Handle versioned modules when called without version number
			var p, p2, idx;
			for (var p in require.modules) {
				if ((idx = p.indexOf('#')) != -1) {
					p2 = p.slice(0, idx);
					if (path == p2) {
						m = require.modules[p];
						break;
					}
				}
			}
			if (!m) throw "Couldn't find module for: " + path;
		}
		// Instantiate the module if it's export object is not yet defined
		if (!m.exports) {
			// Convert 'lazy' evaluated string to Function
			if ('string' == typeof m) {
				m = require.modules[path] = new Function('module', 'exports', 'require', m);
			}
			m.exports = {};
			m.filename = path;
			m.call(this, m, m.exports, require.relative(path));
		}
		// Return the exports object
		return m.exports;
	}

	// Cache of module objects
	require.modules = {};

	// Resolve 'to' an absolute path
	// @param {String} curr
	// @param {String} path
	// @return {String}
	require.resolve = function(from, to) {
		var fromSegs = from.split('/')
			, seg;

		// Non relative path
		if (to.charAt(0) != '.') return to;

		// Don't strip root paths (handled specially in require())
		if (fromSegs.length > 1) fromSegs.pop();
		to = to.split('/');
		// Use 'from' path segments to resolve relative 'to' path
		for (var i = 0; i < to.length; ++i) {
			seg = to[i];
			if (seg == '..') {
				fromSegs.pop();
			} else if (seg != '.') {
				fromSegs.push(seg);
			}
		}
		return fromSegs.join('/');
	};

	// Partial completion of the module's inner 'require' function
	// @param {String} path
	// @return {Object}
	require.relative = function(path) {
		return function(p) {
			return require(require.resolve(path, p));
		};
	};

	// Register a module with id of 'path' and callback of 'fn'
	// @param {String} path
	// @param {Function} fn [signature should be of type (module, exports, require)]
	require.register = function(path, fn) {
		require.modules[path] = fn;
	};

	// Expose
	root.require = require;
})((typeof window !== 'undefined') ? window : global);
require.register('isarray#0.0.1', function(module, exports, require) {
  module.exports = Array.isArray || function (arr) {
    return Object.prototype.toString.call(arr) == '[object Array]';
  };
  
});
require.register('path-to-regexp#1.0.3', function(module, exports, require) {
  var isArray = require('isarray#0.0.1');
  
  /**
   * Expose `pathToRegexp`.
   */
  module.exports = pathToRegexp;
  
  /**
   * The main path matching regexp utility.
   *
   * @type {RegExp}
   */
  var PATH_REGEXP = new RegExp([
    // Match escaped characters that would otherwise appear in future matches.
    // This allows the user to escape special characters that won't transform.
    '(\\\\.)',
    // Match Express-style parameters and un-named parameters with a prefix
    // and optional suffixes. Matches appear as:
    //
    // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
    // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
    '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
    // Match regexp special characters that are always escaped.
    '([.+*?=^!:${}()[\\]|\\/])'
  ].join('|'), 'g');
  
  /**
   * Escape the capturing group by escaping special characters and meaning.
   *
   * @param  {String} group
   * @return {String}
   */
  function escapeGroup (group) {
    return group.replace(/([=!:$\/()])/g, '\\$1');
  }
  
  /**
   * Attach the keys as a property of the regexp.
   *
   * @param  {RegExp} re
   * @param  {Array}  keys
   * @return {RegExp}
   */
  function attachKeys (re, keys) {
    re.keys = keys;
    return re;
  }
  
  /**
   * Get the flags for a regexp from the options.
   *
   * @param  {Object} options
   * @return {String}
   */
  function flags (options) {
    return options.sensitive ? '' : 'i';
  }
  
  /**
   * Pull out keys from a regexp.
   *
   * @param  {RegExp} path
   * @param  {Array}  keys
   * @return {RegExp}
   */
  function regexpToRegexp (path, keys) {
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);
  
    if (groups) {
      for (var i = 0; i < groups.length; i++) {
        keys.push({
          name:      i,
          delimiter: null,
          optional:  false,
          repeat:    false
        });
      }
    }
  
    return attachKeys(path, keys);
  }
  
  /**
   * Transform an array into a regexp.
   *
   * @param  {Array}  path
   * @param  {Array}  keys
   * @param  {Object} options
   * @return {RegExp}
   */
  function arrayToRegexp (path, keys, options) {
    var parts = [];
  
    for (var i = 0; i < path.length; i++) {
      parts.push(pathToRegexp(path[i], keys, options).source);
    }
  
    var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
    return attachKeys(regexp, keys);
  }
  
  /**
   * Replace the specific tags with regexp strings.
   *
   * @param  {String} path
   * @param  {Array}  keys
   * @return {String}
   */
  function replacePath (path, keys) {
    var index = 0;
  
    function replace (_, escaped, prefix, key, capture, group, suffix, escape) {
      if (escaped) {
        return escaped;
      }
  
      if (escape) {
        return '\\' + escape;
      }
  
      var repeat   = suffix === '+' || suffix === '*';
      var optional = suffix === '?' || suffix === '*';
  
      keys.push({
        name:      key || index++,
        delimiter: prefix || '/',
        optional:  optional,
        repeat:    repeat
      });
  
      prefix = prefix ? ('\\' + prefix) : '';
      capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');
  
      if (repeat) {
        capture = capture + '(?:' + prefix + capture + ')*';
      }
  
      if (optional) {
        return '(?:' + prefix + '(' + capture + '))?';
      }
  
      // Basic parameter support.
      return prefix + '(' + capture + ')';
    }
  
    return path.replace(PATH_REGEXP, replace);
  }
  
  /**
   * Normalize the given path string, returning a regular expression.
   *
   * An empty array can be passed in for the keys, which will hold the
   * placeholder key descriptions. For example, using `/user/:id`, `keys` will
   * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
   *
   * @param  {(String|RegExp|Array)} path
   * @param  {Array}                 [keys]
   * @param  {Object}                [options]
   * @return {RegExp}
   */
  function pathToRegexp (path, keys, options) {
    keys = keys || [];
  
    if (!isArray(keys)) {
      options = keys;
      keys = [];
    } else if (!options) {
      options = {};
    }
  
    if (path instanceof RegExp) {
      return regexpToRegexp(path, keys, options);
    }
  
    if (isArray(path)) {
      return arrayToRegexp(path, keys, options);
    }
  
    var strict = options.strict;
    var end = options.end !== false;
    var route = replacePath(path, keys);
    var endsWithSlash = path.charAt(path.length - 1) === '/';
  
    // In non-strict mode we allow a slash at the end of match. If the path to
    // match already ends with a slash, we remove it for consistency. The slash
    // is valid at the end of a path match, not in the middle. This is important
    // in non-ending mode, where "/test/" shouldn't match "/test//route".
    if (!strict) {
      route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
    }
  
    if (end) {
      route += '$';
    } else {
      // In non-ending mode, we need the capturing groups to match as much as
      // possible by using a positive lookahead to the end or next path segment.
      route += strict && endsWithSlash ? '' : '(?=\\/|$)';
    }
  
    return attachKeys(new RegExp('^' + route, flags(options)), keys);
  }
  
});
require.register('lib/layer.js', function(module, exports, require) {
  /**
   * Router layer object
   */
  
  var matcher = require('path-to-regexp#1.0.3')
  	, urlUtils = require('@yr/url-utils#1.8.1');
  
  module.exports = Layer;
  
  /**
   * Constructor
   * @param {String} url
   */
  function Layer (path, fn, options) {
  	if (!(this instanceof Layer)) {
  		return new Layer(path, fn, options);
  	}
  
  	// To be filled by matcher
  	this.keys = [];
  	this.path = null;
  	this.params = null;
  	this.fn = fn;
  	this.name = fn.name ? '<' + fn.name + '>' : '<anonymous>';
  	this.fastmatch = (path == '/' && !options.end);
  	this.regexp = matcher(this._path(path), this.keys, options);
  
  }
  
  /**
   * Determine if this route matches 'path'
   * @param {String} path
   * @returns {Boolean}
   */
  Layer.prototype.match = function (path) {
  	if (this.fastmatch) {
  		this.params = {};
  		this.path = '';
  		return true;
  	}
  
  	var match = this.regexp.exec(path);
  
  	if (!match) {
  		this.params = null;
  		this.path = null;
  		return false;
  	}
  
  	this.params = {};
  	this.path = match[0];
  
  	var n = 0
  		, key, val;
  
  	for (var i = 1, len = match.length; i < len; ++i) {
  		key = this.keys[i - 1];
  		val = urlUtils.decode(match[i]);
  
  		if (key) {
  			this.params[key.name] = val;
  		} else {
  			this.params[n++] = val;
  		}
  	}
  
  	return true;
  };
  
  /**
   * Handle
   * @param {Error} err
   * @param {Request} req
   * @param {Response} res
   * @param {Function} next
   */
  Layer.prototype.handle = function (err, req, res, next) {
  	if (err) {
  		// Only call if it handles errors
  		return (this.fn.length > 3)
  			? this.fn(err, req, res, next)
  			: next(err);
  	}
  
  	// Skip if error handler
  	return (this.fn.length < 4)
  		? this.fn(req, res, next)
  		: next();
  };
  
  /**
   * Format 'path'
   * @params {String} path
   * @returns {String}
   */
  Layer.prototype._path = function (path) {
  	// Convert wildcard
  	return (path == '*')
  		? '(.*)'
  		: path;
  };
});
require.register('lib/router.js', function(module, exports, require) {
  /**
   * Router for handling middleware pipeline.
   * Can be isolated under a specific mount path.
   */
  
  var bind = require('lodash-compat/function/bind.js#3.7.0')
  	, debug = require('debug#2.1.2')('express:router')
  	, forEach = require('lodash-compat/collection/forEach.js#3.7.0')
  	, layer = require('lib/layer.js')
  	, merge = require('lodash-compat/object/merge.js#3.7.0')
  	, objKeys = require('lodash-compat/object/keys.js#3.7.0')
  	, urlUtils = require('@yr/url-utils#1.8.1')
  
  	, METHODS = ['get', 'post', 'all']
  	, DEFAULTS = {
  			mergeParams: true,
  			caseSensitive: false,
  			strict: false
  		};
  
  module.exports = Router;
  
  /**
   * Constructor
   * @param {Object} [options]
   */
  function Router (options) {
  	if (!(this instanceof Router)) {
  		return new Router(options);
  	}
  
  	options = merge({}, DEFAULTS, options);
  
  	this.stack = [];
  	this.mergeParams = options.mergeParams;
  	this.handle = bind(this.handle, this);
  	// Init matcher options
  	this.matcherOpts = {
  		sensitive: options.caseSensitive,
  		strict: options.strict,
  		end: false
  	};
  	this.strictMatcherOpts = {
  		sensitive: options.caseSensitive,
  		strict: options.strict,
  		end: true
  	};
  	this.params;
  }
  
  /**
   * Handle param 'name' with 'fn'
   * @param {String} name
   * @param {Function} fn(req, res, next, value)
   */
  Router.prototype.param = function (name, fn) {
  	if (!this.params) this.params = {};
  	this.params[name] = fn;
  };
  
  /**
   * Add one or more 'fn' to middleware pipeline at optional 'path'
   * @param {Function} fn
   */
  Router.prototype.use = function (/* path, */ fn /* ...fn */) {
  	var offset = 0
  		, path = '/'
  		, fns;
  
  	if ('string' == typeof fn) {
  		offset = 1;
  		path = fn;
  	}
  
  	fns = Array.prototype.slice.call(arguments, offset);
  
  	forEach(fns, function (fn) {
  		if (fn instanceof Router) {
  			fn = fn.handle;
  		}
  		var lyr = layer(path, fn, this.matcherOpts);
  		debug('adding router middleware %s with path %s', lyr.name, path);
  		this.stack.push(lyr);
  	}, this);
  };
  
  /**
   * Add one or more VERB fns at 'path' with strict matching of path
   * @param {String} path
   */
  forEach(METHODS, function (method) {
  	Router.prototype[method] = function (path) {
  		var fns = Array.prototype.slice.call(arguments, 1);
  
  		forEach(fns, function (fn) {
  			var lyr = layer(path, fn, this.strictMatcherOpts);
  			lyr.route = true;
  			debug('adding router route %s with path %s', lyr.name, path);
  			this.stack.push(lyr);
  		}, this);
  	};
  });
  
  /**
   * Run request/response through middleware pipline
   * @param {Request} req
   * @param {Response} res
   * @param {Function} done
   */
  Router.prototype.handle = function (req, res, done) {
  	var idx = 0
  		, self = this
  		, processedParams = {}
  		, removed = ''
  		, parentUrl = req.baseUrl || '';
  
  	// Update done to restore req props
  	done = restore(done, req, 'baseUrl', 'next', 'params');
  
  	// Setup next layer
  	req.next = next;
  	req.baseUrl = parentUrl;
  
  	next();
  
  	function next (err) {
  		var lyr = self.stack[idx++]
  			, layerErr = err;
  
  		if (removed.length != 0) {
  			debug('untrim %s from url %s', removed, req.path);
  			req.baseUrl = parentUrl;
  			req.path = urlUtils.join(removed, req.path);
  			removed = '';
  		}
  
  		// Exit
  		if (!lyr) {
  			return done(err);
  		}
  
  		// Skip if no match
  		if (!lyr.match(req.path)) {
  			return next(err);
  		}
  
  		debug('%s matched layer %s with path %s', req.path, lyr.name, lyr.path);
  
  		// Store params
  		if (self.mergeParams) {
  			if (!req.params) req.params = {};
  			merge(req.params, lyr.params);
  		} else {
  			req.params = lyr.params;
  		}
  
  		var keys = objKeys(lyr.params);
  		// Process params if necessary
  		self._processParams(processedParams, req.params, keys, req, res, function (err) {
  			if (err) return next(layerErr || err);
  			if (!lyr.route) trim(lyr);
  			return lyr.handle(layerErr, req, res, next);
  		});
  	}
  
  	function trim (layer) {
  		if (layer.path.length != 0) {
  			debug('trim %s from url %s', layer.path, req.path);
  			removed = layer.path;
  			req.path = req.path.substr(removed.length);
  			if (req.path.charAt(0) != '/') req.path = '/' + req.path;
  
  			req.baseUrl = urlUtils.join(parentUrl, removed);
  		}
  	}
  };
  
  /**
   * Process middleware matched parameters
   * @param {Object} processedParams
   * @param {Object} params
   * @param {Array} keys
   * @param {Request} req
   * @param {Response} res
   * @param {Function} done(err)
   */
  Router.prototype._processParams = function (processedParams, params, keys, req, res, done) {
  	function next (err) {
  		// Stop processing on any error
  		if (err) return done(err);
  
  		var name = keys[idx++]
  			, fn = self.params[name];
  
  		// Process if match and not already processed
  		if (fn && !processedParams[name]) {
  			processedParams[name] = true;
  			return fn(req, res, next, params[name]);
  		}
  
  		(idx < keys.length)
  			? next()
  			: done();
  	}
  
  	if (this.params && keys.length) {
  		var idx = 0
  			, self = this;
  
  		next();
  	} else {
  		done();
  	}
  };
  
  /**
   * Restore 'obj' props
   * @param {Function} fn
   * @param {Object} obj
   */
  function restore (fn, obj) {
  	var props = new Array(arguments.length - 2)
  		, vals = new Array(arguments.length - 2);
  
  	for (var i = 0; i < props.length; i++) {
  		props[i] = arguments[i + 2];
  		vals[i] = obj[props[i]];
  	}
  
  	return function (err) {
  		// Restore vals
  		for (var i = 0; i < props.length; i++) {
  			obj[props[i]] = vals[i];
  		}
  
  		return fn.apply(this, arguments);
  	};
  }
});
require.register('lib/response.js', function(module, exports, require) {
  /**
   * Browser response object
   */
  
  var cookie = require('cookie#0.1.2')
  	, emitter = require('eventemitter3#1.0.1')
  	, merge = require('lib/safeMerge.js');
  
  module.exports = Response;
  
  /**
   * Constructor
   */
  function Response () {
  	if (!(this instanceof Response)) {
  		return new Response();
  	}
  
  	this.app;
  	this.req;
  	this.reset();
  
  	merge(this, emitter.prototype);
  };
  
  /**
   * Reset state
   */
  Response.prototype.reset = function () {
  	this.cached = false;
  	this.finished = false;
  	this.locals = {};
  	this.statusCode = 404;
  };
  
  /**
   * Set status 'code'
   * @param {Number} code
   * @returns {Response}
   */
  Response.prototype.status = function (code) {
  	this.statusCode = code;
  	return this;
  };
  
  /**
   * Send response (last method called in pipeline)
   */
  Response.prototype.send = function () {
  	// Reset state
  	this.req.reset();
  	this.status(200);
  	this.finished = true;
  	this.emit('finish');
  };
  
  /**
   * Redirect to 'url'
   * @param {Number} statusCode
   * @param {String} url
   */
  Response.prototype.redirect = function (statusCode, url) {
  	this.app.redirectTo(url || statusCode);
  };
  
  /**
   * Render 'view' with the given 'options' and optional callback 'fn'
   * @param {String} view
   * @param {Object} [options]
   * @param {Function} [fn(err)]
   */
  Response.prototype.render = function (view, options, fn) {
  	options = options || {};
  
  	var self = this
  		, app = this.app
  		, req = this.req;
  
  	if ('function' == typeof options) {
  		fn = options;
  		options = {};
  	}
  
  	// Store locals so that app can merge
  	options._locals = this.locals;
  
  	// Default callback
  	fn = fn || function (err) {
  		if (err) return req.next(err);
  		self.send();
  	};
  
  	app.render(view, options, fn);
  };
  
  /**
   * Set cookie
   * @param {String} name
   * @param {String|Object} val
   * @param {Object} options
   * @returns {Response}
   */
  Response.prototype.cookie = function (name, val, options) {
    options = merge({}, options);
  
    if ('number' == typeof val) val = val.toString();
    if ('object' == typeof val) val = 'j:' + JSON.stringify(val);
  
    if ('maxAge' in options) {
      options.expires = new Date(Date.now() + options.maxAge);
      options.maxAge /= 1000;
    }
  
    if (null == options.path) options.path = '/';
    var headerVal = cookie.serialize(name, String(val), options);
  
    document.cookie = headerVal;
    return this;
  };
});
require.register('query-string#1.0.0', function(module, exports, require) {
  /*!
  	query-string
  	Parse and stringify URL query strings
  	https://github.com/sindresorhus/query-string
  	by Sindre Sorhus
  	MIT License
  */
  (function () {
  	'use strict';
  	var queryString = {};
  
  	queryString.parse = function (str) {
  		if (typeof str !== 'string') {
  			return {};
  		}
  
  		str = str.trim().replace(/^(\?|#)/, '');
  
  		if (!str) {
  			return {};
  		}
  
  		return str.trim().split('&').reduce(function (ret, param) {
  			var parts = param.replace(/\+/g, ' ').split('=');
  			var key = parts[0];
  			var val = parts[1];
  
  			key = decodeURIComponent(key);
  			// missing `=` should be `null`:
  			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
  			val = val === undefined ? null : decodeURIComponent(val);
  
  			if (!ret.hasOwnProperty(key)) {
  				ret[key] = val;
  			} else if (Array.isArray(ret[key])) {
  				ret[key].push(val);
  			} else {
  				ret[key] = [ret[key], val];
  			}
  
  			return ret;
  		}, {});
  	};
  
  	queryString.stringify = function (obj) {
  		return obj ? Object.keys(obj).map(function (key) {
  			var val = obj[key];
  
  			if (Array.isArray(val)) {
  				return val.map(function (val2) {
  					return encodeURIComponent(key) + '=' + encodeURIComponent(val2);
  				}).join('&');
  			}
  
  			return encodeURIComponent(key) + '=' + encodeURIComponent(val);
  		}).join('&') : '';
  	};
  
  	if (typeof define === 'function' && define.amd) {
  		define(function() { return queryString; });
  	} else if (typeof module !== 'undefined' && module.exports) {
  		module.exports = queryString;
  	} else {
  		window.queryString = queryString;
  	}
  })();
  
});
require.register('lib/safeMerge.js', function(module, exports, require) {
  /**
   * Safely merge object 'b' into 'a',
   * making sure not to overwrite existing properties in 'a'
   *
   * @param {Object} a
   * @param {Object} b
   * @returns {Object}
   */
  module.exports = function safeMerge (a, b) {
  	if (a && b) {
  		for (var key in b) {
  			if (a[key] == null) a[key] = b[key];
  		}
  	}
  
  	return a;
  };
});
require.register('eventemitter3#1.0.1', function(module, exports, require) {
  'use strict';
  
  /**
   * Representation of a single EventEmitter function.
   *
   * @param {Function} fn Event handler to be called.
   * @param {Mixed} context Context for function execution.
   * @param {Boolean} once Only emit once
   * @api private
   */
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  
  /**
   * Minimal EventEmitter interface that is molded against the Node.js
   * EventEmitter interface.
   *
   * @constructor
   * @api public
   */
  function EventEmitter() { /* Nothing to set */ }
  
  /**
   * Holds the assigned EventEmitters by name.
   *
   * @type {Object}
   * @private
   */
  EventEmitter.prototype._events = undefined;
  
  /**
   * Return a list of assigned event listeners.
   *
   * @param {String} event The events that should be listed.
   * @param {Boolean} exists We only need to know if there are listeners.
   * @returns {Array|Boolean}
   * @api public
   */
  EventEmitter.prototype.listeners = function listeners(event, exists) {
    var prefix = '~'+ event
      , available = this._events && this._events[prefix];
  
    if (exists) return !!available;
    if (!available) return [];
    if (this._events[prefix].fn) return [this._events[prefix].fn];
  
    for (var i = 0, l = this._events[prefix].length, ee = new Array(l); i < l; i++) {
      ee[i] = this._events[prefix][i].fn;
    }
  
    return ee;
  };
  
  /**
   * Emit an event to all registered event listeners.
   *
   * @param {String} event The name of the event.
   * @returns {Boolean} Indication if we've emitted an event.
   * @api public
   */
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var prefix = '~'+ event;
  
    if (!this._events || !this._events[prefix]) return false;
  
    var listeners = this._events[prefix]
      , len = arguments.length
      , args
      , i;
  
    if ('function' === typeof listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
  
      switch (len) {
        case 1: return listeners.fn.call(listeners.context), true;
        case 2: return listeners.fn.call(listeners.context, a1), true;
        case 3: return listeners.fn.call(listeners.context, a1, a2), true;
        case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
  
      for (i = 1, args = new Array(len -1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
  
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length
        , j;
  
      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
  
        switch (len) {
          case 1: listeners[i].fn.call(listeners[i].context); break;
          case 2: listeners[i].fn.call(listeners[i].context, a1); break;
          case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
          default:
            if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
  
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
  
    return true;
  };
  
  /**
   * Register a new EventListener for the given event.
   *
   * @param {String} event Name of the event.
   * @param {Functon} fn Callback function.
   * @param {Mixed} context The context of the function.
   * @api public
   */
  EventEmitter.prototype.on = function on(event, fn, context) {
    var listener = new EE(fn, context || this)
      , prefix = '~'+ event;
  
    if (!this._events) this._events = {};
    if (!this._events[prefix]) this._events[prefix] = listener;
    else {
      if (!this._events[prefix].fn) this._events[prefix].push(listener);
      else this._events[prefix] = [
        this._events[prefix], listener
      ];
    }
  
    return this;
  };
  
  /**
   * Add an EventListener that's only called once.
   *
   * @param {String} event Name of the event.
   * @param {Function} fn Callback function.
   * @param {Mixed} context The context of the function.
   * @api public
   */
  EventEmitter.prototype.once = function once(event, fn, context) {
    var listener = new EE(fn, context || this, true)
      , prefix = '~'+ event;
  
    if (!this._events) this._events = {};
    if (!this._events[prefix]) this._events[prefix] = listener;
    else {
      if (!this._events[prefix].fn) this._events[prefix].push(listener);
      else this._events[prefix] = [
        this._events[prefix], listener
      ];
    }
  
    return this;
  };
  
  /**
   * Remove event listeners.
   *
   * @param {String} event The event we want to remove.
   * @param {Function} fn The listener that we need to find.
   * @param {Mixed} context Only remove listeners matching this context.
   * @param {Boolean} once Only remove once listeners.
   * @api public
   */
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var prefix = '~'+ event;
  
    if (!this._events || !this._events[prefix]) return this;
  
    var listeners = this._events[prefix]
      , events = [];
  
    if (fn) {
      if (listeners.fn) {
        if (
             listeners.fn !== fn
          || (once && !listeners.once)
          || (context && listeners.context !== context)
        ) {
          events.push(listeners);
        }
      } else {
        for (var i = 0, length = listeners.length; i < length; i++) {
          if (
               listeners[i].fn !== fn
            || (once && !listeners[i].once)
            || (context && listeners[i].context !== context)
          ) {
            events.push(listeners[i]);
          }
        }
      }
    }
  
    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) {
      this._events[prefix] = events.length === 1 ? events[0] : events;
    } else {
      delete this._events[prefix];
    }
  
    return this;
  };
  
  /**
   * Remove all listeners or only the listeners for the specified event.
   *
   * @param {String} event The event want to remove all listeners for.
   * @api public
   */
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    if (!this._events) return this;
  
    if (event) delete this._events['~'+ event];
    else this._events = {};
  
    return this;
  };
  
  //
  // Alias methods names because people roll like that.
  //
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  
  //
  // This function doesn't apply anymore.
  //
  EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
    return this;
  };
  
  //
  // Expose the module.
  //
  module.exports = EventEmitter;
  
});
require.register('cookie#0.1.2', function(module, exports, require) {
  
  /// Serialize the a name value pair into a cookie string suitable for
  /// http headers. An optional options object specified cookie parameters
  ///
  /// serialize('foo', 'bar', { httpOnly: true })
  ///   => "foo=bar; httpOnly"
  ///
  /// @param {String} name
  /// @param {String} val
  /// @param {Object} options
  /// @return {String}
  var serialize = function(name, val, opt){
      opt = opt || {};
      var enc = opt.encode || encode;
      var pairs = [name + '=' + enc(val)];
  
      if (null != opt.maxAge) {
          var maxAge = opt.maxAge - 0;
          if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
          pairs.push('Max-Age=' + maxAge);
      }
  
      if (opt.domain) pairs.push('Domain=' + opt.domain);
      if (opt.path) pairs.push('Path=' + opt.path);
      if (opt.expires) pairs.push('Expires=' + opt.expires.toUTCString());
      if (opt.httpOnly) pairs.push('HttpOnly');
      if (opt.secure) pairs.push('Secure');
  
      return pairs.join('; ');
  };
  
  /// Parse the given cookie header string into an object
  /// The object has the various cookies as keys(names) => values
  /// @param {String} str
  /// @return {Object}
  var parse = function(str, opt) {
      opt = opt || {};
      var obj = {}
      var pairs = str.split(/; */);
      var dec = opt.decode || decode;
  
      pairs.forEach(function(pair) {
          var eq_idx = pair.indexOf('=')
  
          // skip things that don't look like key=value
          if (eq_idx < 0) {
              return;
          }
  
          var key = pair.substr(0, eq_idx).trim()
          var val = pair.substr(++eq_idx, pair.length).trim();
  
          // quoted values
          if ('"' == val[0]) {
              val = val.slice(1, -1);
          }
  
          // only assign once
          if (undefined == obj[key]) {
              try {
                  obj[key] = dec(val);
              } catch (e) {
                  obj[key] = val;
              }
          }
      });
  
      return obj;
  };
  
  var encode = encodeURIComponent;
  var decode = decodeURIComponent;
  
  module.exports.serialize = serialize;
  module.exports.parse = parse;
  
});
require.register('lib/request.js', function(module, exports, require) {
  /**
   * Browser request object
   */
  
  var cookie = require('cookie#0.1.2')
  	, emitter = require('eventemitter3#1.0.1')
  	, merge = require('lib/safeMerge.js')
  	, qsParse = require('query-string#1.0.0').parse
  	, urlUtils = require('@yr/url-utils#1.8.1');
  
  module.exports = Request;
  
  /**
   * Constructor
   * @param {String} url
   * @param {Boolean} bootstrap
   */
  function Request (url, bootstrap) {
  	if (!(this instanceof Request)) {
  		return new Request(url, bootstrap);
  	}
  
  	url = url
  		? urlUtils.encode(url)
  		: urlUtils.getCurrent();
  
  	var path = url.split('?')
  		, qs = path[1] || '';
  
  	this.app;
  	this.cookies = cookie.parse(document.cookie);
  	this.path = urlUtils.sanitize(path[0]);
  	this.query = qsParse(qs);
  	this.querystring = qs;
  	this.search = qs ? '?' + qs : '';
  	this.url = this.originalUrl = url;
  	this.reset(bootstrap);
  
  	merge(this, emitter.prototype);
  }
  
  /**
   * Abort response
   */
  Request.prototype.abort = function () {
  	this.reset();
  	this.emit('close');
  };
  
  /**
   * Reset state
   * @param {Boolean} bootstrap
   */
  Request.prototype.reset = function (bootstrap) {
  	this.baseUrl = '';
  	this.bootstrap = bootstrap || false;
  	this.cached = false;
  	this.path = this.originalUrl;
  	this.params = null;
  };
  
});
require.register('lodash-compat/internal/isIterateeCall.js#3.7.0', function(module, exports, require) {
  var getLength = require('lodash-compat/internal/getLength.js#3.7.0'),
      isIndex = require('lodash-compat/internal/isIndex.js#3.7.0'),
      isLength = require('lodash-compat/internal/isLength.js#3.7.0'),
      isObject = require('lodash-compat/lang/isObject.js#3.7.0');
  
  /**
   * Checks if the provided arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
   */
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number') {
      var length = getLength(object),
          prereq = isLength(length) && isIndex(index, length);
    } else {
      prereq = type == 'string' && index in object;
    }
    if (prereq) {
      var other = object[index];
      return value === value ? (value === other) : (other !== other);
    }
    return false;
  }
  
  module.exports = isIterateeCall;
  
});
require.register('lodash-compat/internal/createAssigner.js#3.7.0', function(module, exports, require) {
  var bindCallback = require('lodash-compat/internal/bindCallback.js#3.7.0'),
      isIterateeCall = require('lodash-compat/internal/isIterateeCall.js#3.7.0'),
      restParam = require('lodash-compat/function/restParam.js#3.7.0');
  
  /**
   * Creates a function that assigns properties of source object(s) to a given
   * destination object.
   *
   * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */
  function createAssigner(assigner) {
    return restParam(function(object, sources) {
      var index = -1,
          length = object == null ? 0 : sources.length,
          customizer = length > 2 && sources[length - 2],
          guard = length > 2 && sources[2],
          thisArg = length > 1 && sources[length - 1];
  
      if (typeof customizer == 'function') {
        customizer = bindCallback(customizer, thisArg, 5);
        length -= 2;
      } else {
        customizer = typeof thisArg == 'function' ? thisArg : null;
        length -= (customizer ? 1 : 0);
      }
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? null : customizer;
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, customizer);
        }
      }
      return object;
    });
  }
  
  module.exports = createAssigner;
  
});
require.register('lodash-compat/internal/getSymbols.js#3.7.0', function(module, exports, require) {
  var constant = require('lodash-compat/utility/constant.js#3.7.0'),
      isNative = require('lodash-compat/lang/isNative.js#3.7.0'),
      toObject = require('lodash-compat/internal/toObject.js#3.7.0');
  
  /** Native method references. */
  var getOwnPropertySymbols = isNative(getOwnPropertySymbols = Object.getOwnPropertySymbols) && getOwnPropertySymbols;
  
  /**
   * Creates an array of the own symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !getOwnPropertySymbols ? constant([]) : function(object) {
    return getOwnPropertySymbols(toObject(object));
  };
  
  module.exports = getSymbols;
  
});
require.register('lodash-compat/internal/baseCopy.js#3.7.0', function(module, exports, require) {
  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property names to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @returns {Object} Returns `object`.
   */
  function baseCopy(source, props, object) {
    object || (object = {});
  
    var index = -1,
        length = props.length;
  
    while (++index < length) {
      var key = props[index];
      object[key] = source[key];
    }
    return object;
  }
  
  module.exports = baseCopy;
  
});
require.register('lodash-compat/lang/toPlainObject.js#3.7.0', function(module, exports, require) {
  var baseCopy = require('lodash-compat/internal/baseCopy.js#3.7.0'),
      keysIn = require('lodash-compat/object/keysIn.js#3.7.0');
  
  /**
   * Converts `value` to a plain object flattening inherited enumerable
   * properties of `value` to own properties of the plain object.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Object} Returns the converted plain object.
   * @example
   *
   * function Foo() {
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.assign({ 'a': 1 }, new Foo);
   * // => { 'a': 1, 'b': 2 }
   *
   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
   * // => { 'a': 1, 'b': 2, 'c': 3 }
   */
  function toPlainObject(value) {
    return baseCopy(value, keysIn(value));
  }
  
  module.exports = toPlainObject;
  
});
require.register('lodash-compat/internal/baseForIn.js#3.7.0', function(module, exports, require) {
  var baseFor = require('lodash-compat/internal/baseFor.js#3.7.0'),
      keysIn = require('lodash-compat/object/keysIn.js#3.7.0');
  
  /**
   * The base implementation of `_.forIn` without support for callback
   * shorthands and `this` binding.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForIn(object, iteratee) {
    return baseFor(object, iteratee, keysIn);
  }
  
  module.exports = baseForIn;
  
});
require.register('lodash-compat/internal/shimIsPlainObject.js#3.7.0', function(module, exports, require) {
  var baseForIn = require('lodash-compat/internal/baseForIn.js#3.7.0'),
      isArguments = require('lodash-compat/lang/isArguments.js#3.7.0'),
      isHostObject = require('lodash-compat/internal/isHostObject.js#3.7.0'),
      isObjectLike = require('lodash-compat/internal/isObjectLike.js#3.7.0'),
      support = require('lodash-compat/support.js#3.7.0');
  
  /** `Object#toString` result references. */
  var objectTag = '[object Object]';
  
  /** Used for native method references. */
  var objectProto = Object.prototype;
  
  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;
  
  /**
   * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
   * of values.
   */
  var objToString = objectProto.toString;
  
  /**
   * A fallback implementation of `_.isPlainObject` which checks if `value`
   * is an object created by the `Object` constructor or has a `[[Prototype]]`
   * of `null`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   */
  function shimIsPlainObject(value) {
    var Ctor;
  
    // Exit early for non `Object` objects.
    if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isHostObject(value)) ||
        (!hasOwnProperty.call(value, 'constructor') &&
          (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor))) ||
        (!support.argsTag && isArguments(value))) {
      return false;
    }
    // IE < 9 iterates inherited properties before own properties. If the first
    // iterated property is an object's own property then there are no inherited
    // enumerable properties.
    var result;
    if (support.ownLast) {
      baseForIn(value, function(subValue, key, object) {
        result = hasOwnProperty.call(object, key);
        return false;
      });
      return result !== false;
    }
    // In most environments an object's own properties are iterated before
    // its inherited properties. If the last iterated property is an object's
    // own property then there are no inherited enumerable properties.
    baseForIn(value, function(subValue, key) {
      result = key;
    });
    return result === undefined || hasOwnProperty.call(value, result);
  }
  
  module.exports = shimIsPlainObject;
  
});
require.register('lodash-compat/lang/isPlainObject.js#3.7.0', function(module, exports, require) {
  var isArguments = require('lodash-compat/lang/isArguments.js#3.7.0'),
      isNative = require('lodash-compat/lang/isNative.js#3.7.0'),
      shimIsPlainObject = require('lodash-compat/internal/shimIsPlainObject.js#3.7.0'),
      support = require('lodash-compat/support.js#3.7.0');
  
  /** `Object#toString` result references. */
  var objectTag = '[object Object]';
  
  /** Used for native method references. */
  var objectProto = Object.prototype;
  
  /**
   * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
   * of values.
   */
  var objToString = objectProto.toString;
  
  /** Native method references. */
  var getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf;
  
  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * **Note:** This method assumes objects created by the `Object` constructor
   * have no inherited enumerable properties.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */
  var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
    if (!(value && objToString.call(value) == objectTag) || (!support.argsTag && isArguments(value))) {
      return false;
    }
    var valueOf = value.valueOf,
        objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
  
    return objProto
      ? (value == objProto || getPrototypeOf(value) == objProto)
      : shimIsPlainObject(value);
  };
  
  module.exports = isPlainObject;
  
});
require.register('lodash-compat/internal/baseMergeDeep.js#3.7.0', function(module, exports, require) {
  var arrayCopy = require('lodash-compat/internal/arrayCopy.js#3.7.0'),
      getLength = require('lodash-compat/internal/getLength.js#3.7.0'),
      isArguments = require('lodash-compat/lang/isArguments.js#3.7.0'),
      isArray = require('lodash-compat/lang/isArray.js#3.7.0'),
      isLength = require('lodash-compat/internal/isLength.js#3.7.0'),
      isPlainObject = require('lodash-compat/lang/isPlainObject.js#3.7.0'),
      isTypedArray = require('lodash-compat/lang/isTypedArray.js#3.7.0'),
      toPlainObject = require('lodash-compat/lang/toPlainObject.js#3.7.0');
  
  /**
   * A specialized version of `baseMerge` for arrays and objects which performs
   * deep merges and tracks traversed objects enabling objects with circular
   * references to be merged.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {string} key The key of the value to merge.
   * @param {Function} mergeFunc The function to merge values.
   * @param {Function} [customizer] The function to customize merging properties.
   * @param {Array} [stackA=[]] Tracks traversed source objects.
   * @param {Array} [stackB=[]] Associates values with source counterparts.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
    var length = stackA.length,
        srcValue = source[key];
  
    while (length--) {
      if (stackA[length] == srcValue) {
        object[key] = stackB[length];
        return;
      }
    }
    var value = object[key],
        result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
        isCommon = result === undefined;
  
    if (isCommon) {
      result = srcValue;
      if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
        result = isArray(value)
          ? value
          : (getLength(value) ? arrayCopy(value) : []);
      }
      else if (isPlainObject(srcValue) || isArguments(srcValue)) {
        result = isArguments(value)
          ? toPlainObject(value)
          : (isPlainObject(value) ? value : {});
      }
      else {
        isCommon = false;
      }
    }
    // Add the source value to the stack of traversed objects and associate
    // it with its merged value.
    stackA.push(srcValue);
    stackB.push(result);
  
    if (isCommon) {
      // Recursively merge objects and arrays (susceptible to call stack limits).
      object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
    } else if (result === result ? (result !== value) : (value === value)) {
      object[key] = result;
    }
  }
  
  module.exports = baseMergeDeep;
  
});
require.register('lodash-compat/internal/baseMerge.js#3.7.0', function(module, exports, require) {
  var arrayEach = require('lodash-compat/internal/arrayEach.js#3.7.0'),
      baseMergeDeep = require('lodash-compat/internal/baseMergeDeep.js#3.7.0'),
      getSymbols = require('lodash-compat/internal/getSymbols.js#3.7.0'),
      isArray = require('lodash-compat/lang/isArray.js#3.7.0'),
      isLength = require('lodash-compat/internal/isLength.js#3.7.0'),
      isObject = require('lodash-compat/lang/isObject.js#3.7.0'),
      isObjectLike = require('lodash-compat/internal/isObjectLike.js#3.7.0'),
      isTypedArray = require('lodash-compat/lang/isTypedArray.js#3.7.0'),
      keys = require('lodash-compat/object/keys.js#3.7.0');
  
  /** Used for native method references. */
  var arrayProto = Array.prototype;
  
  /** Native method references. */
  var push = arrayProto.push;
  
  /**
   * The base implementation of `_.merge` without support for argument juggling,
   * multiple sources, and `this` binding `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {Function} [customizer] The function to customize merging properties.
   * @param {Array} [stackA=[]] Tracks traversed source objects.
   * @param {Array} [stackB=[]] Associates values with source counterparts.
   * @returns {Object} Returns `object`.
   */
  function baseMerge(object, source, customizer, stackA, stackB) {
    if (!isObject(object)) {
      return object;
    }
    var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
    if (!isSrcArr) {
      var props = keys(source);
      push.apply(props, getSymbols(source));
    }
    arrayEach(props || source, function(srcValue, key) {
      if (props) {
        key = srcValue;
        srcValue = source[key];
      }
      if (isObjectLike(srcValue)) {
        stackA || (stackA = []);
        stackB || (stackB = []);
        baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
      }
      else {
        var value = object[key],
            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
            isCommon = result === undefined;
  
        if (isCommon) {
          result = srcValue;
        }
        if ((isSrcArr || result !== undefined) &&
            (isCommon || (result === result ? (result !== value) : (value === value)))) {
          object[key] = result;
        }
      }
    });
    return object;
  }
  
  module.exports = baseMerge;
  
});
require.register('lodash-compat/object/merge.js#3.7.0', function(module, exports, require) {
  var baseMerge = require('lodash-compat/internal/baseMerge.js#3.7.0'),
      createAssigner = require('lodash-compat/internal/createAssigner.js#3.7.0');
  
  /**
   * Recursively merges own enumerable properties of the source object(s), that
   * don't resolve to `undefined` into the destination object. Subsequent sources
   * overwrite property assignments of previous sources. If `customizer` is
   * provided it is invoked to produce the merged values of the destination and
   * source properties. If `customizer` returns `undefined` merging is handled
   * by the method instead. The `customizer` is bound to `thisArg` and invoked
   * with five arguments: (objectValue, sourceValue, key, object, source).
   *
   * @static
   * @memberOf _
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @param {Function} [customizer] The function to customize assigned values.
   * @param {*} [thisArg] The `this` binding of `customizer`.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var users = {
   *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
   * };
   *
   * var ages = {
   *   'data': [{ 'age': 36 }, { 'age': 40 }]
   * };
   *
   * _.merge(users, ages);
   * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
   *
   * // using a customizer callback
   * var object = {
   *   'fruits': ['apple'],
   *   'vegetables': ['beet']
   * };
   *
   * var other = {
   *   'fruits': ['banana'],
   *   'vegetables': ['carrot']
   * };
   *
   * _.merge(object, other, function(a, b) {
   *   if (_.isArray(a)) {
   *     return a.concat(b);
   *   }
   * });
   * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
   */
  var merge = createAssigner(baseMerge);
  
  module.exports = merge;
  
});
require.register('@yr/runtime#0.1.0', function(module, exports, require) {
  var isNode = (typeof process !== 'undefined'
  	&& {}.toString.call(process) === '[object process]');
  
  exports.isServer = isNode;
  exports.isBrowser = !isNode;
});
require.register('lodash-compat/internal/baseMap.js#3.7.0', function(module, exports, require) {
  var baseEach = require('lodash-compat/internal/baseEach.js#3.7.0'),
      getLength = require('lodash-compat/internal/getLength.js#3.7.0'),
      isLength = require('lodash-compat/internal/isLength.js#3.7.0');
  
  /**
   * The base implementation of `_.map` without support for callback shorthands
   * and `this` binding.
   *
   * @private
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function baseMap(collection, iteratee) {
    var index = -1,
        length = getLength(collection),
        result = isLength(length) ? Array(length) : [];
  
    baseEach(collection, function(value, key, collection) {
      result[++index] = iteratee(value, key, collection);
    });
    return result;
  }
  
  module.exports = baseMap;
  
});
require.register('lodash-compat/internal/basePropertyDeep.js#3.7.0', function(module, exports, require) {
  var baseGet = require('lodash-compat/internal/baseGet.js#3.7.0'),
      toPath = require('lodash-compat/internal/toPath.js#3.7.0');
  
  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new function.
   */
  function basePropertyDeep(path) {
    var pathKey = (path + '');
    path = toPath(path);
    return function(object) {
      return baseGet(object, path, pathKey);
    };
  }
  
  module.exports = basePropertyDeep;
  
});
require.register('lodash-compat/utility/property.js#3.7.0', function(module, exports, require) {
  var baseProperty = require('lodash-compat/internal/baseProperty.js#3.7.0'),
      basePropertyDeep = require('lodash-compat/internal/basePropertyDeep.js#3.7.0'),
      isKey = require('lodash-compat/internal/isKey.js#3.7.0');
  
  /**
   * Creates a function which returns the property value at `path` on a
   * given object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': { 'c': 2 } } },
   *   { 'a': { 'b': { 'c': 1 } } }
   * ];
   *
   * _.map(objects, _.property('a.b.c'));
   * // => [2, 1]
   *
   * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
   * // => [1, 2]
   */
  function property(path) {
    return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
  }
  
  module.exports = property;
  
});
require.register('lodash-compat/internal/toPath.js#3.7.0', function(module, exports, require) {
  var baseToString = require('lodash-compat/internal/baseToString.js#3.7.0'),
      isArray = require('lodash-compat/lang/isArray.js#3.7.0');
  
  /** Used to match property names within property paths. */
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
  
  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;
  
  /**
   * Converts `value` to property path array if it is not one.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {Array} Returns the property path array.
   */
  function toPath(value) {
    if (isArray(value)) {
      return value;
    }
    var result = [];
    baseToString(value).replace(rePropName, function(match, number, quote, string) {
      result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
    });
    return result;
  }
  
  module.exports = toPath;
  
});
require.register('lodash-compat/array/last.js#3.7.0', function(module, exports, require) {
  /**
   * Gets the last element of `array`.
   *
   * @static
   * @memberOf _
   * @category Array
   * @param {Array} array The array to query.
   * @returns {*} Returns the last element of `array`.
   * @example
   *
   * _.last([1, 2, 3]);
   * // => 3
   */
  function last(array) {
    var length = array ? array.length : 0;
    return length ? array[length - 1] : undefined;
  }
  
  module.exports = last;
  
});
require.register('lodash-compat/internal/isKey.js#3.7.0', function(module, exports, require) {
  var isArray = require('lodash-compat/lang/isArray.js#3.7.0'),
      toObject = require('lodash-compat/internal/toObject.js#3.7.0');
  
  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]+|(["'])(?:(?!\1)[^\n\\]|\\.)*?)\1\]/,
      reIsPlainProp = /^\w*$/;
  
  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey(value, object) {
    var type = typeof value;
    if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
      return true;
    }
    if (isArray(value)) {
      return false;
    }
    var result = !reIsDeepProp.test(value);
    return result || (object != null && value in toObject(object));
  }
  
  module.exports = isKey;
  
});
require.register('lodash-compat/internal/baseSlice.js#3.7.0', function(module, exports, require) {
  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;
  
    start = start == null ? 0 : (+start || 0);
    if (start < 0) {
      start = -start > length ? 0 : (length + start);
    }
    end = (end === undefined || end > length) ? length : (+end || 0);
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : ((end - start) >>> 0);
    start >>>= 0;
  
    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }
  
  module.exports = baseSlice;
  
});
require.register('lodash-compat/internal/baseGet.js#3.7.0', function(module, exports, require) {
  var toObject = require('lodash-compat/internal/toObject.js#3.7.0');
  
  /**
   * The base implementation of `get` without support for string paths
   * and default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} path The path of the property to get.
   * @param {string} [pathKey] The key representation of path.
   * @returns {*} Returns the resolved value.
   */
  function baseGet(object, path, pathKey) {
    if (object == null) {
      return;
    }
    object = toObject(object);
    if (pathKey !== undefined && pathKey in object) {
      path = [pathKey];
    }
    var index = -1,
        length = path.length;
  
    while (object != null && ++index < length) {
      var result = object = toObject(object)[path[index]];
    }
    return result;
  }
  
  module.exports = baseGet;
  
});
require.register('lodash-compat/internal/baseMatchesProperty.js#3.7.0', function(module, exports, require) {
  var baseGet = require('lodash-compat/internal/baseGet.js#3.7.0'),
      baseIsEqual = require('lodash-compat/internal/baseIsEqual.js#3.7.0'),
      baseSlice = require('lodash-compat/internal/baseSlice.js#3.7.0'),
      isArray = require('lodash-compat/lang/isArray.js#3.7.0'),
      isKey = require('lodash-compat/internal/isKey.js#3.7.0'),
      isStrictComparable = require('lodash-compat/internal/isStrictComparable.js#3.7.0'),
      last = require('lodash-compat/array/last.js#3.7.0'),
      toObject = require('lodash-compat/internal/toObject.js#3.7.0'),
      toPath = require('lodash-compat/internal/toPath.js#3.7.0');
  
  /**
   * The base implementation of `_.matchesProperty` which does not which does
   * not clone `value`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} value The value to compare.
   * @returns {Function} Returns the new function.
   */
  function baseMatchesProperty(path, value) {
    var isArr = isArray(path),
        isCommon = isKey(path) && isStrictComparable(value),
        pathKey = (path + '');
  
    path = toPath(path);
    return function(object) {
      if (object == null) {
        return false;
      }
      var key = pathKey;
      object = toObject(object);
      if ((isArr || !isCommon) && !(key in object)) {
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        if (object == null) {
          return false;
        }
        key = last(path);
        object = toObject(object);
      }
      return object[key] === value
        ? (value !== undefined || (key in object))
        : baseIsEqual(value, object[key], null, true);
    };
  }
  
  module.exports = baseMatchesProperty;
  
});
require.register('lodash-compat/internal/isStrictComparable.js#3.7.0', function(module, exports, require) {
  var isObject = require('lodash-compat/lang/isObject.js#3.7.0');
  
  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */
  function isStrictComparable(value) {
    return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
  }
  
  module.exports = isStrictComparable;
  
});
require.register('lodash-compat/lang/isTypedArray.js#3.7.0', function(module, exports, require) {
  var isLength = require('lodash-compat/internal/isLength.js#3.7.0'),
      isObjectLike = require('lodash-compat/internal/isObjectLike.js#3.7.0');
  
  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';
  
  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  
  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  
  /** Used for native method references. */
  var objectProto = Object.prototype;
  
  /**
   * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
   * of values.
   */
  var objToString = objectProto.toString;
  
  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  function isTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
  }
  
  module.exports = isTypedArray;
  
});
require.register('lodash-compat/internal/equalObjects.js#3.7.0', function(module, exports, require) {
  var keys = require('lodash-compat/object/keys.js#3.7.0');
  
  /** Used for native method references. */
  var objectProto = Object.prototype;
  
  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;
  
  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Function} [customizer] The function to customize comparing values.
   * @param {boolean} [isLoose] Specify performing partial comparisons.
   * @param {Array} [stackA] Tracks traversed `value` objects.
   * @param {Array} [stackB] Tracks traversed `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
    var objProps = keys(object),
        objLength = objProps.length,
        othProps = keys(other),
        othLength = othProps.length;
  
    if (objLength != othLength && !isLoose) {
      return false;
    }
    var skipCtor = isLoose,
        index = -1;
  
    while (++index < objLength) {
      var key = objProps[index],
          result = isLoose ? key in other : hasOwnProperty.call(other, key);
  
      if (result) {
        var objValue = object[key],
            othValue = other[key];
  
        result = undefined;
        if (customizer) {
          result = isLoose
            ? customizer(othValue, objValue, key)
            : customizer(objValue, othValue, key);
        }
        if (result === undefined) {
          // Recursively compare objects (susceptible to call stack limits).
          result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB);
        }
      }
      if (!result) {
        return false;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (!skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;
  
      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        return false;
      }
    }
    return true;
  }
  
  module.exports = equalObjects;
  
});
require.register('lodash-compat/internal/equalByTag.js#3.7.0', function(module, exports, require) {
  /** `Object#toString` result references. */
  var boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      numberTag = '[object Number]',
      regexpTag = '[object RegExp]',
      stringTag = '[object String]';
  
  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} value The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag) {
    switch (tag) {
      case boolTag:
      case dateTag:
        // Coerce dates and booleans to numbers, dates to milliseconds and booleans
        // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
        return +object == +other;
  
      case errorTag:
        return object.name == other.name && object.message == other.message;
  
      case numberTag:
        // Treat `NaN` vs. `NaN` as equal.
        return (object != +object)
          ? other != +other
          // But, treat `-0` vs. `+0` as not equal.
          : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);
  
      case regexpTag:
      case stringTag:
        // Coerce regexes to strings and treat strings primitives and string
        // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
        return object == (other + '');
    }
    return false;
  }
  
  module.exports = equalByTag;
  
});
require.register('lodash-compat/internal/equalArrays.js#3.7.0', function(module, exports, require) {
  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Function} [customizer] The function to customize comparing arrays.
   * @param {boolean} [isLoose] Specify performing partial comparisons.
   * @param {Array} [stackA] Tracks traversed `value` objects.
   * @param {Array} [stackB] Tracks traversed `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
    var index = -1,
        arrLength = array.length,
        othLength = other.length,
        result = true;
  
    if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
      return false;
    }
    // Deep compare the contents, ignoring non-numeric properties.
    while (result && ++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];
  
      result = undefined;
      if (customizer) {
        result = isLoose
          ? customizer(othValue, arrValue, index)
          : customizer(arrValue, othValue, index);
      }
      if (result === undefined) {
        // Recursively compare arrays (susceptible to call stack limits).
        if (isLoose) {
          var othIndex = othLength;
          while (othIndex--) {
            othValue = other[othIndex];
            result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
            if (result) {
              break;
            }
          }
        } else {
          result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
        }
      }
    }
    return !!result;
  }
  
  module.exports = equalArrays;
  
});
require.register('lodash-compat/internal/baseIsEqualDeep.js#3.7.0', function(module, exports, require) {
  var equalArrays = require('lodash-compat/internal/equalArrays.js#3.7.0'),
      equalByTag = require('lodash-compat/internal/equalByTag.js#3.7.0'),
      equalObjects = require('lodash-compat/internal/equalObjects.js#3.7.0'),
      isArray = require('lodash-compat/lang/isArray.js#3.7.0'),
      isHostObject = require('lodash-compat/internal/isHostObject.js#3.7.0'),
      isTypedArray = require('lodash-compat/lang/isTypedArray.js#3.7.0');
  
  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      objectTag = '[object Object]';
  
  /** Used for native method references. */
  var objectProto = Object.prototype;
  
  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;
  
  /**
   * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
   * of values.
   */
  var objToString = objectProto.toString;
  
  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Function} [customizer] The function to customize comparing objects.
   * @param {boolean} [isLoose] Specify performing partial comparisons.
   * @param {Array} [stackA=[]] Tracks traversed `value` objects.
   * @param {Array} [stackB=[]] Tracks traversed `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = arrayTag,
        othTag = arrayTag;
  
    if (!objIsArr) {
      objTag = objToString.call(object);
      if (objTag == argsTag) {
        objTag = objectTag;
      } else if (objTag != objectTag) {
        objIsArr = isTypedArray(object);
      }
    }
    if (!othIsArr) {
      othTag = objToString.call(other);
      if (othTag == argsTag) {
        othTag = objectTag;
      } else if (othTag != objectTag) {
        othIsArr = isTypedArray(other);
      }
    }
    var objIsObj = objTag == objectTag && !isHostObject(object),
        othIsObj = othTag == objectTag && !isHostObject(other),
        isSameTag = objTag == othTag;
  
    if (isSameTag && !(objIsArr || objIsObj)) {
      return equalByTag(object, other, objTag);
    }
    if (!isLoose) {
      var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
  
      if (valWrapped || othWrapped) {
        return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
      }
    }
    if (!isSameTag) {
      return false;
    }
    // Assume cyclic values are equal.
    // For more information on detecting circular references see https://es5.github.io/#JO.
    stackA || (stackA = []);
    stackB || (stackB = []);
  
    var length = stackA.length;
    while (length--) {
      if (stackA[length] == object) {
        return stackB[length] == other;
      }
    }
    // Add `object` and `other` to the stack of traversed objects.
    stackA.push(object);
    stackB.push(other);
  
    var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
  
    stackA.pop();
    stackB.pop();
  
    return result;
  }
  
  module.exports = baseIsEqualDeep;
  
});
require.register('lodash-compat/internal/baseIsEqual.js#3.7.0', function(module, exports, require) {
  var baseIsEqualDeep = require('lodash-compat/internal/baseIsEqualDeep.js#3.7.0');
  
  /**
   * The base implementation of `_.isEqual` without support for `this` binding
   * `customizer` functions.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {Function} [customizer] The function to customize comparing values.
   * @param {boolean} [isLoose] Specify performing partial comparisons.
   * @param {Array} [stackA] Tracks traversed `value` objects.
   * @param {Array} [stackB] Tracks traversed `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
    // Exit early for identical values.
    if (value === other) {
      // Treat `+0` vs. `-0` as not equal.
      return value !== 0 || (1 / value == 1 / other);
    }
    var valType = typeof value,
        othType = typeof other;
  
    // Exit early for unlike primitive values.
    if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
        value == null || other == null) {
      // Return `false` unless both values are `NaN`.
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
  }
  
  module.exports = baseIsEqual;
  
});
require.register('lodash-compat/internal/baseIsMatch.js#3.7.0', function(module, exports, require) {
  var baseIsEqual = require('lodash-compat/internal/baseIsEqual.js#3.7.0');
  
  /**
   * The base implementation of `_.isMatch` without support for callback
   * shorthands and `this` binding.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Array} props The source property names to match.
   * @param {Array} values The source values to match.
   * @param {Array} strictCompareFlags Strict comparison flags for source values.
   * @param {Function} [customizer] The function to customize comparing objects.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */
  function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
    var index = -1,
        length = props.length,
        noCustomizer = !customizer;
  
    while (++index < length) {
      if ((noCustomizer && strictCompareFlags[index])
            ? values[index] !== object[props[index]]
            : !(props[index] in object)
          ) {
        return false;
      }
    }
    index = -1;
    while (++index < length) {
      var key = props[index],
          objValue = object[key],
          srcValue = values[index];
  
      if (noCustomizer && strictCompareFlags[index]) {
        var result = objValue !== undefined || (key in object);
      } else {
        result = customizer ? customizer(objValue, srcValue, key) : undefined;
        if (result === undefined) {
          result = baseIsEqual(srcValue, objValue, customizer, true);
        }
      }
      if (!result) {
        return false;
      }
    }
    return true;
  }
  
  module.exports = baseIsMatch;
  
});
require.register('lodash-compat/internal/baseMatches.js#3.7.0', function(module, exports, require) {
  var baseIsMatch = require('lodash-compat/internal/baseIsMatch.js#3.7.0'),
      constant = require('lodash-compat/utility/constant.js#3.7.0'),
      isStrictComparable = require('lodash-compat/internal/isStrictComparable.js#3.7.0'),
      keys = require('lodash-compat/object/keys.js#3.7.0'),
      toObject = require('lodash-compat/internal/toObject.js#3.7.0');
  
  /**
   * The base implementation of `_.matches` which does not clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new function.
   */
  function baseMatches(source) {
    var props = keys(source),
        length = props.length;
  
    if (!length) {
      return constant(true);
    }
    if (length == 1) {
      var key = props[0],
          value = source[key];
  
      if (isStrictComparable(value)) {
        return function(object) {
          if (object == null) {
            return false;
          }
          object = toObject(object);
          return object[key] === value && (value !== undefined || (key in object));
        };
      }
    }
    var values = Array(length),
        strictCompareFlags = Array(length);
  
    while (length--) {
      value = source[props[length]];
      values[length] = value;
      strictCompareFlags[length] = isStrictComparable(value);
    }
    return function(object) {
      return object != null && baseIsMatch(toObject(object), props, values, strictCompareFlags);
    };
  }
  
  module.exports = baseMatches;
  
});
require.register('lodash-compat/internal/baseCallback.js#3.7.0', function(module, exports, require) {
  var baseMatches = require('lodash-compat/internal/baseMatches.js#3.7.0'),
      baseMatchesProperty = require('lodash-compat/internal/baseMatchesProperty.js#3.7.0'),
      bindCallback = require('lodash-compat/internal/bindCallback.js#3.7.0'),
      identity = require('lodash-compat/utility/identity.js#3.7.0'),
      property = require('lodash-compat/utility/property.js#3.7.0');
  
  /**
   * The base implementation of `_.callback` which supports specifying the
   * number of arguments to provide to `func`.
   *
   * @private
   * @param {*} [func=_.identity] The value to convert to a callback.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {number} [argCount] The number of arguments to provide to `func`.
   * @returns {Function} Returns the callback.
   */
  function baseCallback(func, thisArg, argCount) {
    var type = typeof func;
    if (type == 'function') {
      return thisArg === undefined
        ? func
        : bindCallback(func, thisArg, argCount);
    }
    if (func == null) {
      return identity;
    }
    if (type == 'object') {
      return baseMatches(func);
    }
    return thisArg === undefined
      ? property(func)
      : baseMatchesProperty(func, thisArg);
  }
  
  module.exports = baseCallback;
  
});
require.register('lodash-compat/internal/arrayMap.js#3.7.0', function(module, exports, require) {
  /**
   * A specialized version of `_.map` for arrays without support for callback
   * shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array.length,
        result = Array(length);
  
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  
  module.exports = arrayMap;
  
});
require.register('lodash-compat/collection/map.js#3.7.0', function(module, exports, require) {
  var arrayMap = require('lodash-compat/internal/arrayMap.js#3.7.0'),
      baseCallback = require('lodash-compat/internal/baseCallback.js#3.7.0'),
      baseMap = require('lodash-compat/internal/baseMap.js#3.7.0'),
      isArray = require('lodash-compat/lang/isArray.js#3.7.0');
  
  /**
   * Creates an array of values by running each element in `collection` through
   * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
   * arguments: (value, index|key, collection).
   *
   * If a property name is provided for `iteratee` the created `_.property`
   * style callback returns the property value of the given element.
   *
   * If a value is also provided for `thisArg` the created `_.matchesProperty`
   * style callback returns `true` for elements that have a matching property
   * value, else `false`.
   *
   * If an object is provided for `iteratee` the created `_.matches` style
   * callback returns `true` for elements that have the properties of the given
   * object, else `false`.
   *
   * Many lodash methods are guarded to work as interatees for methods like
   * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
   *
   * The guarded methods are:
   * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`, `drop`,
   * `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`, `parseInt`,
   * `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimLeft`,
   * `trimRight`, `trunc`, `random`, `range`, `sample`, `some`, `uniq`, and `words`
   *
   * @static
   * @memberOf _
   * @alias collect
   * @category Collection
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [iteratee=_.identity] The function invoked
   *  per iteration.
   * @param {*} [thisArg] The `this` binding of `iteratee`.
   * @returns {Array} Returns the new mapped array.
   * @example
   *
   * function timesThree(n) {
   *   return n * 3;
   * }
   *
   * _.map([1, 2], timesThree);
   * // => [3, 6]
   *
   * _.map({ 'a': 1, 'b': 2 }, timesThree);
   * // => [3, 6] (iteration order is not guaranteed)
   *
   * var users = [
   *   { 'user': 'barney' },
   *   { 'user': 'fred' }
   * ];
   *
   * // using the `_.property` callback shorthand
   * _.map(users, 'user');
   * // => ['barney', 'fred']
   */
  function map(collection, iteratee, thisArg) {
    var func = isArray(collection) ? arrayMap : baseMap;
    iteratee = baseCallback(iteratee, thisArg, 3);
    return func(collection, iteratee);
  }
  
  module.exports = map;
  
});
require.register('@yr/url-utils#1.8.1', function(module, exports, require) {
  var map = require('lodash-compat/collection/map.js#3.7.0')
  	, forEach = require('lodash-compat/collection/forEach.js#3.7.0')
  	, isArray = require('lodash-compat/lang/isArray.js#3.7.0')
  	, keys = require('lodash-compat/object/keys.js#3.7.0')
  	, isServer = require('@yr/runtime#0.1.0').isServer
  
  	, RE_TEMPLATE = /\{([0-9a-zA-Z]+)\}/g
  	, RE_URL = /([^:])(\/{2,})/g;
  
  
  /**
   * Join url segments
   * Handles strings or arrays of strings
   * @param {String|Array} ...segments
   * @returns {String}
   */
  exports.join = function join (/* ...segments */) {
  	// Non-leaky conversion of arguments to array
  	var n = arguments.length
  		, segments = new Array(n);
  	for (var i = 0; i < n; i++) { segments[i] = arguments[i]; }
  
  	var path = []
  		, leading = ''
  		, segment;
  
  	function add (seg) {
  		if (seg) {
  			// Handle leading slash
  			if (seg.charAt(0) == '/') {
  				// Keep if first segment
  				if (!path.length) leading = '/';
  				seg = seg.slice(1);
  			}
  			if (seg.length) path.push(exports.sanitize(seg));
  		}
  	}
  
  	if (segments.length) {
  		for (var i = 0, n = segments.length; i < n; i++) {
  			segment = segments[i];
  			// Handle array
  			if (isArray(segment)) {
  				forEach(segment, add);
  			} else {
  				add(segment);
  			}
  		}
  
  		return leading + path.join('/');
  	}
  
  	return '';
  };
  
  /**
   * Add query parameters to url in alphabetical order
   * Handles undefined query parameters
   * @param {String} url
   * @param {Object} query
   * @returns {String}
   */
  exports.query = function query (url, query) {
  	var delimit = '?'
  		, sorted = [];
  
  	function append (q) {
  		if (url.charAt(url.length - 1) != delimit) url += '&';
  		url += q + '=' + query[q];
  	}
  
  	if (url && query) {
  		url = exports.sanitize(url);
  		sorted = keys(query).sort();
  		if (!sorted.length) return '';
  		// Add delimiter
  		url += delimit;
  		// Append queries
  		forEach(sorted, function (q) {
  			if (query[q] != null) append(q);
  		});
  
  		return exports.encode(url);
  	}
  
  	return '';
  };
  
  /**
   * Remove trailing '/' from 'url'
   * @param {String} url
   * @returns {String}
   */
  exports.sanitize = function sanitize (url) {
  	if (url && url != '/') {
  		url = url.replace(RE_URL, '$1/');
  		if (url.charAt(url.length - 1) == '/') url = url.slice(0, -1);
  	}
  
  	return url || '';
  };
  
  /**
   * Decode 'url'
   * @param {String} url
   * @returns {String}
   */
  exports.decode = function decode (url) {
  	try {
  		url = decodeURIComponent(url);
  		return url;
  	} catch (err) {
  		throw new Error('failed to decode "' + url + '"');
  	}
  };
  
  /**
   * Encode 'url', and replace slash hex code with /
   * @param {String} url
   * @returns {String}
   */
  exports.encode = function encode (url) {
  	try {
  		if (!~url.indexOf('%')) return encodeURI(url);
  		return url;
  	} catch (err) {
  		throw new Error('failed to encode"' + url + '"');
  	}
  };
  
  /**
   * Retrieve current browser path
   * @returns {String}
   */
  exports.getCurrent = function getCurrent () {
  	return (!isServer)
  		? exports.encode(window.location.pathname + window.location.search)
  		: '';
  };
  
  /**
   * Substitute 'data' values in 'str' template
   * @param {String} str
   * @param {Object} data
   * @params {Object} options
   * @returns {String}
   */
  exports.template = function template (str, data, options) {
  	options = options || {};
  	var str = String(str).replace(RE_TEMPLATE, function (match, prop, idx) {
  		return (data && data[prop] != null)
  			? data[prop]
  			: (options.loose) ? match : '';
  	});
  
  	return exports.sanitize(str);
  };
});
require.register('lib/history.js', function(module, exports, require) {
  /**
   * Manager for browser history.
   * Generates/stores request/response context for current url,
   * and responds to changes to state via History API.
   */
  
  var bind = require('lodash-compat/function/bind.js#3.7.0')
  	, debug = require('debug#2.1.2')('express:history')
  	, urlUtils = require('@yr/url-utils#1.8.1')
  	, bootstrap = true;
  
  module.exports = History;
  
  /**
   * Constructor
   * @param {Function} request(url)
   * @param {Function} response
   * @param {Function} fn(req, res)
   */
  function History (request, response, fn) {
  	if (!(this instanceof History)) {
  		return new History(request, response, fn);
  	}
  
  	this.cache = {};
  	this.current = '';
  	this.running = false;
  	this.request = request;
  	this.response = response;
  	this.fn = fn;
  	this.onClick = bind(this.onClick, this);
  	this.onPopstate = bind(this.onPopstate, this);
  	this.navigateTo = bind(this.navigateTo, this);
  	this.redirectTo = bind(this.redirectTo, this);
  	this.getCurrentContext = bind(this.getCurrentContext, this);
  }
  
  /**
   * Notify on current context,
   * and begin listening for history changes
   * @returns {History}
   */
  History.prototype.listen = function () {
  	// Handle current history state (triggers notification)
  	var ctx = this.handle();
  
  	if (!this.running && ctx) {
  		// Test History API availability
  		if (hasHistory()) {
  			var self = this;
  			// Delay to prevent premature trigger when navigating back from nothing
  			setTimeout(function () {
  				window.addEventListener('click', self.onClick, false);
  				window.addEventListener('popstate', self.onPopstate, false);
  				self.running = true;
  			}, 500);
  
  			// Update so that popstate will trigger for this route
  			window.history.replaceState({}, document.title);
  
  			debug('listening with history API');
  		}
  	}
  
  	return this;
  };
  
  /**
   * Create a new or updated history state at 'url' with 'title'
   * @param {String} url
   * @param {String} title
   * @param {Boolean} isUpdate
   */
  History.prototype.navigateTo = function (url, title, isUpdate) {
  	// Only navigate if not same as current
  	if (url != urlUtils.getCurrent()) {
  		if (this.running) {
  			// Will throw if malformed
  			url = urlUtils.encode(url);
  
  			debug('navigate to: %s', url);
  
  			window.history[isUpdate ? 'replaceState' : 'pushState']({}, title, url);
  			if (title) document.title = title;
  			this.handle(url);
  		} else {
  			this.redirectTo(url);
  		}
  	}
  };
  
  /**
   * Stop history management by redirecting to 'url'
   * @param {String} url
   */
  History.prototype.redirectTo = function (url) {
  	this.destroy();
  	window.location = urlUtils.encode(url);
  };
  
  /**
   * Force a re-handle of current context
   */
  History.prototype.refresh = function () {
  	var ctx = this.getCurrentContext();
  	// Undo pipeline modifications
  	ctx.req.reset();
  	ctx.res.reset();
  	this.fn(ctx.req, ctx.res);
  };
  
  /**
   * Retrieve current context
   * @returns {Object}
   */
  History.prototype.getCurrentContext = function () {
  	return this.cache[this.current];
  };
  
  /**
   * Stop listening for history updates
   */
  History.prototype.destroy = function () {
  	if (this.running) {
  		window.removeEventListener('click', this.onClick, false);
  		window.removeEventListener('popstate', this.onPopstate, false);
  		this.cache = null;
  		this.running = false;
  	}
  };
  
  /**
   * Handle history change and notify
   * @param {String} [url]
   * @param {State} [state]
   * @returns {Object}
   */
  History.prototype.handle = function (url) {
  	var ctx = {}
  		, req, res;
  
  	try {
  		url = url
  			? urlUtils.encode(url)
  			: urlUtils.getCurrent();
  	} catch (err) {
  		// Error encoding url
  		return this.redirectTo(url);
  	}
  
  	// Do nothing if current url is the same
  	if (this.current && this.current === url) return;
  
  	if (this.cache[url]) {
  		ctx = this.cache[url];
  		req = ctx.req;
  		res = ctx.res;
  		// Always reset in order to undo pipeline modifications
  		req.reset();
  		res.reset();
  		// Set flag for use downstream
  		req.cached = res.cached = true;
  		debug('context retrieved from cache: %s', url);
  	} else {
  		req = this.request(url, bootstrap);
  		res = this.response();
  		debug('generating new context: %s', url);
  	}
  	res.req = req;
  	ctx.req = req;
  	ctx.res = res;
  	this.cache[url] = ctx;
  
  	// Make sure only first request flagged as bootstrap
  	bootstrap = false;
  
  	// Abort if current request/response is not finished
  	if (this.current && !this.cache[this.current].res.finished) {
  		this.cache[this.current].req.abort();
  		this.cache[this.current].res.reset();
  	}
  
  	// Store reference to current
  	this.current = url;
  
  	this.fn(req, res);
  
  	return ctx;
  };
  
  /**
   * Handle history change via 'popstate' event
   * @param {Object} evt
   */
  History.prototype.onPopstate = function (evt) {
  	// Prevent initial page load from triggering on some platforms when no state
  	if (evt.state && this.running) {
  		this.handle();
  	}
  };
  
  /**
   * Handle click event
   * @param {Object} evt
   */
  History.prototype.onClick = function (evt) {
  	var which = (null == evt.which)
  			? evt.button
  			: evt.which
  		, el = evt.target;
  
  	// Modifiers present
  	if (which != 1) return;
  	if (evt.metaKey || evt.ctrlKey || evt.shiftKey) return;
  	if (evt.defaultPrevented) return;
  
  	// Find anchor
  	// svg elements on some platforms don't have nodeNames
  	while (el && (el.nodeName == null || 'A' != el.nodeName.toUpperCase())) {
  		el = el.parentNode;
  	}
  
  	// Anchor not found
  	if (!el || 'A' != el.nodeName.toUpperCase()) return;
  
  	// Cross origin
  	if (!sameOrigin(el.href)) return;
  
  	var path = el.pathname + el.search;
  
  	evt.preventDefault();
  
  	// Same as current
  	if (path == urlUtils.getCurrent()) return;
  
  	debug('click event intercepted from %s', el);
  	// TODO: what about title?
  	this.navigateTo(path);
  };
  
  /**
   * Test for history API (Modernizr)
   * @returns {Boolean}
   */
  function hasHistory () {
  	var ua = navigator.userAgent;
  
  	// Stock android browser 2.2 & 2.3 & 4.0.x are buggy, ignore
  	if ((ua.indexOf('Android 2.') !== -1
  		|| (ua.indexOf('Android 4.0') !== -1))
  		// Chrome identifies itself as 'Mobile Safari'
  		&& ua.indexOf('Mobile Safari') !== -1
  		&& ua.indexOf('Chrome') === -1) {
  			return false;
  	}
  
  	// Usual test
  	return (window.history && 'pushState' in window.history);
  }
  
  /**
   * Check if 'url' is from same origin
   * @param {String} url
   * @returns {Boolean}
   */
  function sameOrigin (url) {
  	var origin = location.protocol + '//' + location.hostname;
  	if (location.port) origin += ':' + location.port;
  	return (url && (url.indexOf(origin) == 0));
  }
});
require.register('lodash-compat/internal/bindCallback.js#3.7.0', function(module, exports, require) {
  var identity = require('lodash-compat/utility/identity.js#3.7.0');
  
  /**
   * A specialized version of `baseCallback` which only supports `this` binding
   * and specifying the number of arguments to provide to `func`.
   *
   * @private
   * @param {Function} func The function to bind.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {number} [argCount] The number of arguments to provide to `func`.
   * @returns {Function} Returns the callback.
   */
  function bindCallback(func, thisArg, argCount) {
    if (typeof func != 'function') {
      return identity;
    }
    if (thisArg === undefined) {
      return func;
    }
    switch (argCount) {
      case 1: return function(value) {
        return func.call(thisArg, value);
      };
      case 3: return function(value, index, collection) {
        return func.call(thisArg, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(thisArg, accumulator, value, index, collection);
      };
      case 5: return function(value, other, key, object, source) {
        return func.call(thisArg, value, other, key, object, source);
      };
    }
    return function() {
      return func.apply(thisArg, arguments);
    };
  }
  
  module.exports = bindCallback;
  
});
require.register('lodash-compat/internal/createForEach.js#3.7.0', function(module, exports, require) {
  var bindCallback = require('lodash-compat/internal/bindCallback.js#3.7.0'),
      isArray = require('lodash-compat/lang/isArray.js#3.7.0');
  
  /**
   * Creates a function for `_.forEach` or `_.forEachRight`.
   *
   * @private
   * @param {Function} arrayFunc The function to iterate over an array.
   * @param {Function} eachFunc The function to iterate over a collection.
   * @returns {Function} Returns the new each function.
   */
  function createForEach(arrayFunc, eachFunc) {
    return function(collection, iteratee, thisArg) {
      return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
        ? arrayFunc(collection, iteratee)
        : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
    };
  }
  
  module.exports = createForEach;
  
});
require.register('lodash-compat/internal/getLength.js#3.7.0', function(module, exports, require) {
  var baseProperty = require('lodash-compat/internal/baseProperty.js#3.7.0');
  
  /**
   * Gets the "length" property value of `object`.
   *
   * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
   * in Safari on iOS 8.1 ARM64.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {*} Returns the "length" value.
   */
  var getLength = baseProperty('length');
  
  module.exports = getLength;
  
});
require.register('lodash-compat/internal/createBaseEach.js#3.7.0', function(module, exports, require) {
  var getLength = require('lodash-compat/internal/getLength.js#3.7.0'),
      isLength = require('lodash-compat/internal/isLength.js#3.7.0'),
      toObject = require('lodash-compat/internal/toObject.js#3.7.0');
  
  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      var length = collection ? getLength(collection) : 0;
      if (!isLength(length)) {
        return eachFunc(collection, iteratee);
      }
      var index = fromRight ? length : -1,
          iterable = toObject(collection);
  
      while ((fromRight ? index-- : ++index < length)) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  
  module.exports = createBaseEach;
  
});
require.register('lodash-compat/internal/baseIsFunction.js#3.7.0', function(module, exports, require) {
  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }
  
  module.exports = baseIsFunction;
  
});
require.register('lodash-compat/lang/isFunction.js#3.7.0', function(module, exports, require) {
  var baseIsFunction = require('lodash-compat/internal/baseIsFunction.js#3.7.0'),
      isNative = require('lodash-compat/lang/isNative.js#3.7.0');
  
  /** `Object#toString` result references. */
  var funcTag = '[object Function]';
  
  /** Used for native method references. */
  var objectProto = Object.prototype;
  
  /**
   * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
   * of values.
   */
  var objToString = objectProto.toString;
  
  /** Native method references. */
  var Uint8Array = isNative(Uint8Array = global.Uint8Array) && Uint8Array;
  
  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in older versions of Chrome and Safari which return 'function' for regexes
    // and Safari 8 equivalents which return 'object' for typed array constructors.
    return objToString.call(value) == funcTag;
  };
  
  module.exports = isFunction;
  
});
require.register('lodash-compat/object/keysIn.js#3.7.0', function(module, exports, require) {
  var arrayEach = require('lodash-compat/internal/arrayEach.js#3.7.0'),
      isArguments = require('lodash-compat/lang/isArguments.js#3.7.0'),
      isArray = require('lodash-compat/lang/isArray.js#3.7.0'),
      isFunction = require('lodash-compat/lang/isFunction.js#3.7.0'),
      isIndex = require('lodash-compat/internal/isIndex.js#3.7.0'),
      isLength = require('lodash-compat/internal/isLength.js#3.7.0'),
      isObject = require('lodash-compat/lang/isObject.js#3.7.0'),
      isString = require('lodash-compat/lang/isString.js#3.7.0'),
      support = require('lodash-compat/support.js#3.7.0');
  
  /** `Object#toString` result references. */
  var arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      stringTag = '[object String]';
  
  /** Used to fix the JScript `[[DontEnum]]` bug. */
  var shadowProps = [
    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
    'toLocaleString', 'toString', 'valueOf'
  ];
  
  /** Used for native method references. */
  var errorProto = Error.prototype,
      objectProto = Object.prototype,
      stringProto = String.prototype;
  
  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;
  
  /**
   * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
   * of values.
   */
  var objToString = objectProto.toString;
  
  /** Used to avoid iterating over non-enumerable properties in IE < 9. */
  var nonEnumProps = {};
  nonEnumProps[arrayTag] = nonEnumProps[dateTag] = nonEnumProps[numberTag] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
  nonEnumProps[boolTag] = nonEnumProps[stringTag] = { 'constructor': true, 'toString': true, 'valueOf': true };
  nonEnumProps[errorTag] = nonEnumProps[funcTag] = nonEnumProps[regexpTag] = { 'constructor': true, 'toString': true };
  nonEnumProps[objectTag] = { 'constructor': true };
  
  arrayEach(shadowProps, function(key) {
    for (var tag in nonEnumProps) {
      if (hasOwnProperty.call(nonEnumProps, tag)) {
        var props = nonEnumProps[tag];
        props[key] = hasOwnProperty.call(props, key);
      }
    }
  });
  
  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn(object) {
    if (object == null) {
      return [];
    }
    if (!isObject(object)) {
      object = Object(object);
    }
    var length = object.length;
  
    length = (length && isLength(length) &&
      (isArray(object) || (support.nonEnumStrings && isString(object)) ||
        (support.nonEnumArgs && isArguments(object))) && length) || 0;
  
    var Ctor = object.constructor,
        index = -1,
        proto = (isFunction(Ctor) && Ctor.prototype) || objectProto,
        isProto = proto === object,
        result = Array(length),
        skipIndexes = length > 0,
        skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error),
        skipProto = support.enumPrototypes && isFunction(object);
  
    while (++index < length) {
      result[index] = (index + '');
    }
    // lodash skips the `constructor` property when it infers it is iterating
    // over a `prototype` object because IE < 9 can't set the `[[Enumerable]]`
    // attribute of an existing property and the `constructor` property of a
    // prototype defaults to non-enumerable.
    for (var key in object) {
      if (!(skipProto && key == 'prototype') &&
          !(skipErrorProps && (key == 'message' || key == 'name')) &&
          !(skipIndexes && isIndex(key, length)) &&
          !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }
    if (support.nonEnumShadows && object !== objectProto) {
      var tag = object === stringProto ? stringTag : (object === errorProto ? errorTag : objToString.call(object)),
          nonEnums = nonEnumProps[tag] || nonEnumProps[objectTag];
  
      if (tag == objectTag) {
        proto = objectProto;
      }
      length = shadowProps.length;
      while (length--) {
        key = shadowProps[length];
        var nonEnum = nonEnums[key];
        if (!(isProto && nonEnum) &&
            (nonEnum ? hasOwnProperty.call(object, key) : object[key] !== proto[key])) {
          result.push(key);
        }
      }
    }
    return result;
  }
  
  module.exports = keysIn;
  
});
require.register('lodash-compat/lang/isArguments.js#3.7.0', function(module, exports, require) {
  var isLength = require('lodash-compat/internal/isLength.js#3.7.0'),
      isObjectLike = require('lodash-compat/internal/isObjectLike.js#3.7.0'),
      support = require('lodash-compat/support.js#3.7.0');
  
  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]';
  
  /** Used for native method references. */
  var objectProto = Object.prototype;
  
  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;
  
  /**
   * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
   * of values.
   */
  var objToString = objectProto.toString;
  
  /** Native method references. */
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  
  /**
   * Checks if `value` is classified as an `arguments` object.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  function isArguments(value) {
    var length = isObjectLike(value) ? value.length : undefined;
    return isLength(length) && objToString.call(value) == argsTag;
  }
  // Fallback for environments without a `toStringTag` for `arguments` objects.
  if (!support.argsTag) {
    isArguments = function(value) {
      var length = isObjectLike(value) ? value.length : undefined;
      return isLength(length) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };
  }
  
  module.exports = isArguments;
  
});
require.register('lodash-compat/internal/shimKeys.js#3.7.0', function(module, exports, require) {
  var isArguments = require('lodash-compat/lang/isArguments.js#3.7.0'),
      isArray = require('lodash-compat/lang/isArray.js#3.7.0'),
      isIndex = require('lodash-compat/internal/isIndex.js#3.7.0'),
      isLength = require('lodash-compat/internal/isLength.js#3.7.0'),
      isString = require('lodash-compat/lang/isString.js#3.7.0'),
      keysIn = require('lodash-compat/object/keysIn.js#3.7.0'),
      support = require('lodash-compat/support.js#3.7.0');
  
  /** Used for native method references. */
  var objectProto = Object.prototype;
  
  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;
  
  /**
   * A fallback implementation of `Object.keys` which creates an array of the
   * own enumerable property names of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function shimKeys(object) {
    var props = keysIn(object),
        propsLength = props.length,
        length = propsLength && object.length;
  
    var allowIndexes = length && isLength(length) &&
      (isArray(object) || (support.nonEnumStrings && isString(object)) ||
        (support.nonEnumArgs && isArguments(object)));
  
    var index = -1,
        result = [];
  
    while (++index < propsLength) {
      var key = props[index];
      if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
        result.push(key);
      }
    }
    return result;
  }
  
  module.exports = shimKeys;
  
});
require.register('lodash-compat/object/keys.js#3.7.0', function(module, exports, require) {
  var isLength = require('lodash-compat/internal/isLength.js#3.7.0'),
      isNative = require('lodash-compat/lang/isNative.js#3.7.0'),
      isObject = require('lodash-compat/lang/isObject.js#3.7.0'),
      shimKeys = require('lodash-compat/internal/shimKeys.js#3.7.0'),
      support = require('lodash-compat/support.js#3.7.0');
  
  /* Native method references for those with the same name as other `lodash` methods. */
  var nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;
  
  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
   * for more details.
   *
   * @static
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  var keys = !nativeKeys ? shimKeys : function(object) {
    if (object) {
      var Ctor = object.constructor,
          length = object.length;
    }
    if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
        (typeof object == 'function' ? support.enumPrototypes : isLength(length))) {
      return shimKeys(object);
    }
    return isObject(object) ? nativeKeys(object) : [];
  };
  
  module.exports = keys;
  
});
require.register('lodash-compat/internal/createBaseFor.js#3.7.0', function(module, exports, require) {
  var toObject = require('lodash-compat/internal/toObject.js#3.7.0');
  
  /**
   * Creates a base function for `_.forIn` or `_.forInRight`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var iterable = toObject(object),
          props = keysFunc(object),
          length = props.length,
          index = fromRight ? length : -1;
  
      while ((fromRight ? index-- : ++index < length)) {
        var key = props[index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  
  module.exports = createBaseFor;
  
});
require.register('lodash-compat/internal/baseFor.js#3.7.0', function(module, exports, require) {
  var createBaseFor = require('lodash-compat/internal/createBaseFor.js#3.7.0');
  
  /**
   * The base implementation of `baseForIn` and `baseForOwn` which iterates
   * over `object` properties returned by `keysFunc` invoking `iteratee` for
   * each property. Iteratee functions may exit iteration early by explicitly
   * returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = createBaseFor();
  
  module.exports = baseFor;
  
});
require.register('lodash-compat/internal/baseForOwn.js#3.7.0', function(module, exports, require) {
  var baseFor = require('lodash-compat/internal/baseFor.js#3.7.0'),
      keys = require('lodash-compat/object/keys.js#3.7.0');
  
  /**
   * The base implementation of `_.forOwn` without support for callback
   * shorthands and `this` binding.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForOwn(object, iteratee) {
    return baseFor(object, iteratee, keys);
  }
  
  module.exports = baseForOwn;
  
});
require.register('lodash-compat/internal/baseEach.js#3.7.0', function(module, exports, require) {
  var baseForOwn = require('lodash-compat/internal/baseForOwn.js#3.7.0'),
      createBaseEach = require('lodash-compat/internal/createBaseEach.js#3.7.0');
  
  /**
   * The base implementation of `_.forEach` without support for callback
   * shorthands and `this` binding.
   *
   * @private
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object|string} Returns `collection`.
   */
  var baseEach = createBaseEach(baseForOwn);
  
  module.exports = baseEach;
  
});
require.register('lodash-compat/internal/arrayEach.js#3.7.0', function(module, exports, require) {
  /**
   * A specialized version of `_.forEach` for arrays without support for callback
   * shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array.length;
  
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  
  module.exports = arrayEach;
  
});
require.register('lodash-compat/collection/forEach.js#3.7.0', function(module, exports, require) {
  var arrayEach = require('lodash-compat/internal/arrayEach.js#3.7.0'),
      baseEach = require('lodash-compat/internal/baseEach.js#3.7.0'),
      createForEach = require('lodash-compat/internal/createForEach.js#3.7.0');
  
  /**
   * Iterates over elements of `collection` invoking `iteratee` for each element.
   * The `iteratee` is bound to `thisArg` and invoked with three arguments:
   * (value, index|key, collection). Iteratee functions may exit iteration early
   * by explicitly returning `false`.
   *
   * **Note:** As with other "Collections" methods, objects with a "length" property
   * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
   * may be used for object iteration.
   *
   * @static
   * @memberOf _
   * @alias each
   * @category Collection
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @param {*} [thisArg] The `this` binding of `iteratee`.
   * @returns {Array|Object|string} Returns `collection`.
   * @example
   *
   * _([1, 2]).forEach(function(n) {
   *   console.log(n);
   * }).value();
   * // => logs each value from left to right and returns the array
   *
   * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
   *   console.log(n, key);
   * });
   * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
   */
  var forEach = createForEach(arrayEach, baseEach);
  
  module.exports = forEach;
  
});
require.register('ms#0.7.0', function(module, exports, require) {
  /**
   * Helpers.
   */
  
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  
  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} options
   * @return {String|Number}
   * @api public
   */
  
  module.exports = function(val, options){
    options = options || {};
    if ('string' == typeof val) return parse(val);
    return options.long
      ? long(val)
      : short(val);
  };
  
  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */
  
  function parse(str) {
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) return;
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
    }
  }
  
  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */
  
  function short(ms) {
    if (ms >= d) return Math.round(ms / d) + 'd';
    if (ms >= h) return Math.round(ms / h) + 'h';
    if (ms >= m) return Math.round(ms / m) + 'm';
    if (ms >= s) return Math.round(ms / s) + 's';
    return ms + 'ms';
  }
  
  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */
  
  function long(ms) {
    return plural(ms, d, 'day')
      || plural(ms, h, 'hour')
      || plural(ms, m, 'minute')
      || plural(ms, s, 'second')
      || ms + ' ms';
  }
  
  /**
   * Pluralization helper.
   */
  
  function plural(ms, n, name) {
    if (ms < n) return;
    if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
    return Math.ceil(ms / n) + ' ' + name + 's';
  }
  
});
require.register('debug/debug.js#2.1.2', function(module, exports, require) {
  
  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   *
   * Expose `debug()` as the module.
   */
  
  exports = module.exports = debug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = require('ms#0.7.0');
  
  /**
   * The currently active debug mode names, and names to skip.
   */
  
  exports.names = [];
  exports.skips = [];
  
  /**
   * Map of special "%n" handling functions, for the debug "format" argument.
   *
   * Valid key names are a single, lowercased letter, i.e. "n".
   */
  
  exports.formatters = {};
  
  /**
   * Previously assigned color.
   */
  
  var prevColor = 0;
  
  /**
   * Previous log timestamp.
   */
  
  var prevTime;
  
  /**
   * Select a color.
   *
   * @return {Number}
   * @api private
   */
  
  function selectColor() {
    return exports.colors[prevColor++ % exports.colors.length];
  }
  
  /**
   * Create a debugger with the given `namespace`.
   *
   * @param {String} namespace
   * @return {Function}
   * @api public
   */
  
  function debug(namespace) {
  
    // define the `disabled` version
    function disabled() {
    }
    disabled.enabled = false;
  
    // define the `enabled` version
    function enabled() {
  
      var self = enabled;
  
      // set `diff` timestamp
      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
  
      // add the `color` if not set
      if (null == self.useColors) self.useColors = exports.useColors();
      if (null == self.color && self.useColors) self.color = selectColor();
  
      var args = Array.prototype.slice.call(arguments);
  
      args[0] = exports.coerce(args[0]);
  
      if ('string' !== typeof args[0]) {
        // anything else let's inspect with %o
        args = ['%o'].concat(args);
      }
  
      // apply any `formatters` transformations
      var index = 0;
      args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
        // if we encounter an escaped % then don't increase the array index
        if (match === '%%') return match;
        index++;
        var formatter = exports.formatters[format];
        if ('function' === typeof formatter) {
          var val = args[index];
          match = formatter.call(self, val);
  
          // now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });
  
      if ('function' === typeof exports.formatArgs) {
        args = exports.formatArgs.apply(self, args);
      }
      var logFn = enabled.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }
    enabled.enabled = true;
  
    var fn = exports.enabled(namespace) ? enabled : disabled;
  
    fn.namespace = namespace;
  
    return fn;
  }
  
  /**
   * Enables a debug mode by namespaces. This can include modes
   * separated by a colon and wildcards.
   *
   * @param {String} namespaces
   * @api public
   */
  
  function enable(namespaces) {
    exports.save(namespaces);
  
    var split = (namespaces || '').split(/[\s,]+/);
    var len = split.length;
  
    for (var i = 0; i < len; i++) {
      if (!split[i]) continue; // ignore empty strings
      namespaces = split[i].replace(/\*/g, '.*?');
      if (namespaces[0] === '-') {
        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        exports.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  
  /**
   * Disable debug output.
   *
   * @api public
   */
  
  function disable() {
    exports.enable('');
  }
  
  /**
   * Returns true if the given mode name is enabled, false otherwise.
   *
   * @param {String} name
   * @return {Boolean}
   * @api public
   */
  
  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length; i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length; i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  
  /**
   * Coerce `val`.
   *
   * @param {Mixed} val
   * @return {Mixed}
   * @api private
   */
  
  function coerce(val) {
    if (val instanceof Error) return val.stack || val.message;
    return val;
  }
  
});
require.register('debug#2.1.2', function(module, exports, require) {
  
  /**
   * This is the web browser implementation of `debug()`.
   *
   * Expose `debug()` as the module.
   */
  
  exports = module.exports = require('debug/debug.js#2.1.2');
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  
  /**
   * Use chrome.storage.local if we are in an app
   */
  
  var storage;
  
  if (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')
    storage = chrome.storage.local;
  else
    storage = localstorage();
  
  /**
   * Colors.
   */
  
  exports.colors = [
    'lightseagreen',
    'forestgreen',
    'goldenrod',
    'dodgerblue',
    'darkorchid',
    'crimson'
  ];
  
  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */
  
  function useColors() {
    // is webkit? http://stackoverflow.com/a/16459606/376773
    return ('WebkitAppearance' in document.documentElement.style) ||
      // is firebug? http://stackoverflow.com/a/398120/376773
      (window.console && (console.firebug || (console.exception && console.table))) ||
      // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
  }
  
  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */
  
  exports.formatters.j = function(v) {
    return JSON.stringify(v);
  };
  
  
  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */
  
  function formatArgs() {
    var args = arguments;
    var useColors = this.useColors;
  
    args[0] = (useColors ? '%c' : '')
      + this.namespace
      + (useColors ? ' %c' : ' ')
      + args[0]
      + (useColors ? '%c ' : ' ')
      + '+' + exports.humanize(this.diff);
  
    if (!useColors) return args;
  
    var c = 'color: ' + this.color;
    args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
  
    // the final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-z%]/g, function(match) {
      if ('%%' === match) return;
      index++;
      if ('%c' === match) {
        // we only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });
  
    args.splice(lastC, 0, c);
    return args;
  }
  
  /**
   * Invokes `console.log()` when available.
   * No-op when `console.log` is not a "function".
   *
   * @api public
   */
  
  function log() {
    // this hackery is required for IE8/9, where
    // the `console.log` function doesn't have 'apply'
    return 'object' === typeof console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }
  
  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */
  
  function save(namespaces) {
    try {
      if (null == namespaces) {
        storage.removeItem('debug');
      } else {
        storage.debug = namespaces;
      }
    } catch(e) {}
  }
  
  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */
  
  function load() {
    var r;
    try {
      r = storage.debug;
    } catch(e) {}
    return r;
  }
  
  /**
   * Enable namespaces listed in `localStorage.debug` initially.
   */
  
  exports.enable(load());
  
  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */
  
  function localstorage(){
    try {
      return window.localStorage;
    } catch (e) {}
  }
  
});
require.register('lodash-compat/function/restParam.js#3.7.0', function(module, exports, require) {
  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';
  
  /* Native method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max;
  
  /**
   * Creates a function that invokes `func` with the `this` binding of the
   * created function and arguments from `start` and beyond provided as an array.
   *
   * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
   *
   * @static
   * @memberOf _
   * @category Function
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   * @example
   *
   * var say = _.restParam(function(what, names) {
   *   return what + ' ' + _.initial(names).join(', ') +
   *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
   * });
   *
   * say('hello', 'fred', 'barney', 'pebbles');
   * // => 'hello fred, barney, & pebbles'
   */
  function restParam(func, start) {
    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          rest = Array(length);
  
      while (++index < length) {
        rest[index] = args[start + index];
      }
      switch (start) {
        case 0: return func.call(this, rest);
        case 1: return func.call(this, args[0], rest);
        case 2: return func.call(this, args[0], args[1], rest);
      }
      var otherArgs = Array(start + 1);
      index = -1;
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = rest;
      return func.apply(this, otherArgs);
    };
  }
  
  module.exports = restParam;
  
});
require.register('lodash-compat/internal/mergeData.js#3.7.0', function(module, exports, require) {
  var arrayCopy = require('lodash-compat/internal/arrayCopy.js#3.7.0'),
      composeArgs = require('lodash-compat/internal/composeArgs.js#3.7.0'),
      composeArgsRight = require('lodash-compat/internal/composeArgsRight.js#3.7.0'),
      replaceHolders = require('lodash-compat/internal/replaceHolders.js#3.7.0');
  
  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      ARY_FLAG = 128,
      REARG_FLAG = 256;
  
  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';
  
  /* Native method references for those with the same name as other `lodash` methods. */
  var nativeMin = Math.min;
  
  /**
   * Merges the function metadata of `source` into `data`.
   *
   * Merging metadata reduces the number of wrappers required to invoke a function.
   * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
   * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
   * augment function arguments, making the order in which they are executed important,
   * preventing the merging of metadata. However, we make an exception for a safe
   * common case where curried functions have `_.ary` and or `_.rearg` applied.
   *
   * @private
   * @param {Array} data The destination metadata.
   * @param {Array} source The source metadata.
   * @returns {Array} Returns `data`.
   */
  function mergeData(data, source) {
    var bitmask = data[1],
        srcBitmask = source[1],
        newBitmask = bitmask | srcBitmask,
        isCommon = newBitmask < ARY_FLAG;
  
    var isCombo =
      (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
      (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
      (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);
  
    // Exit early if metadata can't be merged.
    if (!(isCommon || isCombo)) {
      return data;
    }
    // Use source `thisArg` if available.
    if (srcBitmask & BIND_FLAG) {
      data[2] = source[2];
      // Set when currying a bound function.
      newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
    }
    // Compose partial arguments.
    var value = source[3];
    if (value) {
      var partials = data[3];
      data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
      data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
    }
    // Compose partial right arguments.
    value = source[5];
    if (value) {
      partials = data[5];
      data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
      data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
    }
    // Use source `argPos` if available.
    value = source[7];
    if (value) {
      data[7] = arrayCopy(value);
    }
    // Use source `ary` if it's smaller.
    if (srcBitmask & ARY_FLAG) {
      data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
    }
    // Use source `arity` if one is not provided.
    if (data[9] == null) {
      data[9] = source[9];
    }
    // Use source `func` and merge bitmasks.
    data[0] = source[0];
    data[1] = newBitmask;
  
    return data;
  }
  
  module.exports = mergeData;
  
});
require.register('lodash-compat/utility/noop.js#3.7.0', function(module, exports, require) {
  /**
   * A no-operation function which returns `undefined` regardless of the
   * arguments it receives.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @example
   *
   * var object = { 'user': 'fred' };
   *
   * _.noop(object) === undefined;
   * // => true
   */
  function noop() {
    // No operation performed.
  }
  
  module.exports = noop;
  
});
require.register('lodash-compat/internal/getData.js#3.7.0', function(module, exports, require) {
  var metaMap = require('lodash-compat/internal/metaMap.js#3.7.0'),
      noop = require('lodash-compat/utility/noop.js#3.7.0');
  
  /**
   * Gets metadata for `func`.
   *
   * @private
   * @param {Function} func The function to query.
   * @returns {*} Returns the metadata for `func`.
   */
  var getData = !metaMap ? noop : function(func) {
    return metaMap.get(func);
  };
  
  module.exports = getData;
  
});
require.register('lodash-compat/internal/createPartialWrapper.js#3.7.0', function(module, exports, require) {
  var createCtorWrapper = require('lodash-compat/internal/createCtorWrapper.js#3.7.0');
  
  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1;
  
  /**
   * Creates a function that wraps `func` and invokes it with the optional `this`
   * binding of `thisArg` and the `partials` prepended to those provided to
   * the wrapper.
   *
   * @private
   * @param {Function} func The function to partially apply arguments to.
   * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} partials The arguments to prepend to those provided to the new function.
   * @returns {Function} Returns the new bound function.
   */
  function createPartialWrapper(func, bitmask, thisArg, partials) {
    var isBind = bitmask & BIND_FLAG,
        Ctor = createCtorWrapper(func);
  
    function wrapper() {
      // Avoid `arguments` object use disqualifying optimizations by
      // converting it to an array before providing it `func`.
      var argsIndex = -1,
          argsLength = arguments.length,
          leftIndex = -1,
          leftLength = partials.length,
          args = Array(argsLength + leftLength);
  
      while (++leftIndex < leftLength) {
        args[leftIndex] = partials[leftIndex];
      }
      while (argsLength--) {
        args[leftIndex++] = arguments[++argsIndex];
      }
      var fn = (this && this !== global && this instanceof wrapper) ? Ctor : func;
      return fn.apply(isBind ? thisArg : this, args);
    }
    return wrapper;
  }
  
  module.exports = createPartialWrapper;
  
});
require.register('lodash-compat/date/now.js#3.7.0', function(module, exports, require) {
  var isNative = require('lodash-compat/lang/isNative.js#3.7.0');
  
  /* Native method references for those with the same name as other `lodash` methods. */
  var nativeNow = isNative(nativeNow = Date.now) && nativeNow;
  
  /**
   * Gets the number of milliseconds that have elapsed since the Unix epoch
   * (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @category Date
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => logs the number of milliseconds it took for the deferred function to be invoked
   */
  var now = nativeNow || function() {
    return new Date().getTime();
  };
  
  module.exports = now;
  
});
require.register('lodash-compat/internal/setData.js#3.7.0', function(module, exports, require) {
  var baseSetData = require('lodash-compat/internal/baseSetData.js#3.7.0'),
      now = require('lodash-compat/date/now.js#3.7.0');
  
  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;
  
  /**
   * Sets metadata for `func`.
   *
   * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
   * period of time, it will trip its breaker and transition to an identity function
   * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
   * for more details.
   *
   * @private
   * @param {Function} func The function to associate metadata with.
   * @param {*} data The metadata.
   * @returns {Function} Returns `func`.
   */
  var setData = (function() {
    var count = 0,
        lastCalled = 0;
  
    return function(key, value) {
      var stamp = now(),
          remaining = HOT_SPAN - (stamp - lastCalled);
  
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return key;
        }
      } else {
        count = 0;
      }
      return baseSetData(key, value);
    };
  }());
  
  module.exports = setData;
  
});
require.register('lodash-compat/internal/replaceHolders.js#3.7.0', function(module, exports, require) {
  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';
  
  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];
  
    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }
  
  module.exports = replaceHolders;
  
});
require.register('lodash-compat/internal/isIndex.js#3.7.0', function(module, exports, require) {
  /**
   * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
   * of an array-like value.
   */
  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
  
  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    value = +value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return value > -1 && value % 1 == 0 && value < length;
  }
  
  module.exports = isIndex;
  
});
require.register('lodash-compat/internal/reorder.js#3.7.0', function(module, exports, require) {
  var arrayCopy = require('lodash-compat/internal/arrayCopy.js#3.7.0'),
      isIndex = require('lodash-compat/internal/isIndex.js#3.7.0');
  
  /* Native method references for those with the same name as other `lodash` methods. */
  var nativeMin = Math.min;
  
  /**
   * Reorder `array` according to the specified indexes where the element at
   * the first index is assigned as the first element, the element at
   * the second index is assigned as the second element, and so on.
   *
   * @private
   * @param {Array} array The array to reorder.
   * @param {Array} indexes The arranged array indexes.
   * @returns {Array} Returns `array`.
   */
  function reorder(array, indexes) {
    var arrLength = array.length,
        length = nativeMin(indexes.length, arrLength),
        oldArray = arrayCopy(array);
  
    while (length--) {
      var index = indexes[length];
      array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
    }
    return array;
  }
  
  module.exports = reorder;
  
});
require.register('lodash-compat/internal/wrapperClone.js#3.7.0', function(module, exports, require) {
  var LazyWrapper = require('lodash-compat/internal/LazyWrapper.js#3.7.0'),
      LodashWrapper = require('lodash-compat/internal/LodashWrapper.js#3.7.0'),
      arrayCopy = require('lodash-compat/internal/arrayCopy.js#3.7.0');
  
  /**
   * Creates a clone of `wrapper`.
   *
   * @private
   * @param {Object} wrapper The wrapper to clone.
   * @returns {Object} Returns the cloned wrapper.
   */
  function wrapperClone(wrapper) {
    return wrapper instanceof LazyWrapper
      ? wrapper.clone()
      : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
  }
  
  module.exports = wrapperClone;
  
});
require.register('lodash-compat/internal/isLength.js#3.7.0', function(module, exports, require) {
  /**
   * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
   * of an array-like value.
   */
  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
  
  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   */
  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  
  module.exports = isLength;
  
});
require.register('lodash-compat/lang/isArray.js#3.7.0', function(module, exports, require) {
  var isLength = require('lodash-compat/internal/isLength.js#3.7.0'),
      isNative = require('lodash-compat/lang/isNative.js#3.7.0'),
      isObjectLike = require('lodash-compat/internal/isObjectLike.js#3.7.0');
  
  /** `Object#toString` result references. */
  var arrayTag = '[object Array]';
  
  /** Used for native method references. */
  var objectProto = Object.prototype;
  
  /**
   * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
   * of values.
   */
  var objToString = objectProto.toString;
  
  /* Native method references for those with the same name as other `lodash` methods. */
  var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray;
  
  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(function() { return arguments; }());
   * // => false
   */
  var isArray = nativeIsArray || function(value) {
    return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
  };
  
  module.exports = isArray;
  
});
require.register('lodash-compat/internal/LodashWrapper.js#3.7.0', function(module, exports, require) {
  var baseCreate = require('lodash-compat/internal/baseCreate.js#3.7.0'),
      baseLodash = require('lodash-compat/internal/baseLodash.js#3.7.0');
  
  /**
   * The base constructor for creating `lodash` wrapper objects.
   *
   * @private
   * @param {*} value The value to wrap.
   * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
   * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
   */
  function LodashWrapper(value, chainAll, actions) {
    this.__wrapped__ = value;
    this.__actions__ = actions || [];
    this.__chain__ = !!chainAll;
  }
  
  LodashWrapper.prototype = baseCreate(baseLodash.prototype);
  LodashWrapper.prototype.constructor = LodashWrapper;
  
  module.exports = LodashWrapper;
  
});
require.register('lodash-compat/chain/lodash.js#3.7.0', function(module, exports, require) {
  var LazyWrapper = require('lodash-compat/internal/LazyWrapper.js#3.7.0'),
      LodashWrapper = require('lodash-compat/internal/LodashWrapper.js#3.7.0'),
      baseLodash = require('lodash-compat/internal/baseLodash.js#3.7.0'),
      isArray = require('lodash-compat/lang/isArray.js#3.7.0'),
      isObjectLike = require('lodash-compat/internal/isObjectLike.js#3.7.0'),
      wrapperClone = require('lodash-compat/internal/wrapperClone.js#3.7.0');
  
  /** Used for native method references. */
  var objectProto = Object.prototype;
  
  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;
  
  /**
   * Creates a `lodash` object which wraps `value` to enable implicit chaining.
   * Methods that operate on and return arrays, collections, and functions can
   * be chained together. Methods that return a boolean or single value will
   * automatically end the chain returning the unwrapped value. Explicit chaining
   * may be enabled using `_.chain`. The execution of chained methods is lazy,
   * that is, execution is deferred until `_#value` is implicitly or explicitly
   * called.
   *
   * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
   * fusion is an optimization that merges iteratees to avoid creating intermediate
   * arrays and reduce the number of iteratee executions.
   *
   * Chaining is supported in custom builds as long as the `_#value` method is
   * directly or indirectly included in the build.
   *
   * In addition to lodash methods, wrappers have `Array` and `String` methods.
   *
   * The wrapper `Array` methods are:
   * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
   * `splice`, and `unshift`
   *
   * The wrapper `String` methods are:
   * `replace` and `split`
   *
   * The wrapper methods that support shortcut fusion are:
   * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
   * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
   * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
   * and `where`
   *
   * The chainable wrapper methods are:
   * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
   * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
   * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defer`, `delay`,
   * `difference`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `fill`,
   * `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`, `forEach`,
   * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,
   * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,
   * `keysIn`, `map`, `mapValues`, `matches`, `matchesProperty`, `memoize`,
   * `merge`, `mixin`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
   * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
   * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `reverse`,
   * `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`, `sortByOrder`, `splice`,
   * `spread`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `tap`,
   * `throttle`, `thru`, `times`, `toArray`, `toPlainObject`, `transform`,
   * `union`, `uniq`, `unshift`, `unzip`, `values`, `valuesIn`, `where`,
   * `without`, `wrap`, `xor`, `zip`, and `zipObject`
   *
   * The wrapper methods that are **not** chainable by default are:
   * `add`, `attempt`, `camelCase`, `capitalize`, `clone`, `cloneDeep`, `deburr`,
   * `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,
   * `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`, `has`,
   * `identity`, `includes`, `indexOf`, `inRange`, `isArguments`, `isArray`,
   * `isBoolean`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isError`, `isFinite`
   * `isFunction`, `isMatch`, `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`,
   * `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `isTypedArray`,
   * `join`, `kebabCase`, `last`, `lastIndexOf`, `max`, `min`, `noConflict`,
   * `noop`, `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`,
   * `reduce`, `reduceRight`, `repeat`, `result`, `runInContext`, `shift`, `size`,
   * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`, `startsWith`,
   * `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`, `unescape`,
   * `uniqueId`, `value`, and `words`
   *
   * The wrapper method `sample` will return a wrapped value when `n` is provided,
   * otherwise an unwrapped value is returned.
   *
   * @name _
   * @constructor
   * @category Chain
   * @param {*} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * var wrapped = _([1, 2, 3]);
   *
   * // returns an unwrapped value
   * wrapped.reduce(function(total, n) {
   *   return total + n;
   * });
   * // => 6
   *
   * // returns a wrapped value
   * var squares = wrapped.map(function(n) {
   *   return n * n;
   * });
   *
   * _.isArray(squares);
   * // => false
   *
   * _.isArray(squares.value());
   * // => true
   */
  function lodash(value) {
    if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
      if (value instanceof LodashWrapper) {
        return value;
      }
      if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
        return wrapperClone(value);
      }
    }
    return new LodashWrapper(value);
  }
  
  // Ensure wrappers are instances of `baseLodash`.
  lodash.prototype = baseLodash.prototype;
  
  module.exports = lodash;
  
});
require.register('lodash-compat/internal/realNames.js#3.7.0', function(module, exports, require) {
  /** Used to lookup unminified function names. */
  var realNames = {};
  
  module.exports = realNames;
  
});
require.register('lodash-compat/utility/constant.js#3.7.0', function(module, exports, require) {
  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new function.
   * @example
   *
   * var object = { 'user': 'fred' };
   * var getter = _.constant(object);
   *
   * getter() === object;
   * // => true
   */
  function constant(value) {
    return function() {
      return value;
    };
  }
  
  module.exports = constant;
  
});
require.register('lodash-compat/support.js#3.7.0', function(module, exports, require) {
  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      objectTag = '[object Object]';
  
  /** Used for native method references. */
  var arrayProto = Array.prototype,
      errorProto = Error.prototype,
      objectProto = Object.prototype;
  
  /** Used to detect DOM support. */
  var document = (document = global.window) && document.document;
  
  /**
   * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
   * of values.
   */
  var objToString = objectProto.toString;
  
  /** Native method references. */
  var propertyIsEnumerable = objectProto.propertyIsEnumerable,
      splice = arrayProto.splice;
  
  /**
   * An object environment feature flags.
   *
   * @static
   * @memberOf _
   * @type Object
   */
  var support = {};
  
  (function(x) {
    var Ctor = function() { this.x = x; },
        object = { '0': x, 'length': x },
        props = [];
  
    Ctor.prototype = { 'valueOf': x, 'y': x };
    for (var key in new Ctor) { props.push(key); }
  
    /**
     * Detect if the `toStringTag` of `arguments` objects is resolvable
     * (all but Firefox < 4, IE < 9).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.argsTag = objToString.call(arguments) == argsTag;
  
    /**
     * Detect if `name` or `message` properties of `Error.prototype` are
     * enumerable by default (IE < 9, Safari < 5.1).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') ||
      propertyIsEnumerable.call(errorProto, 'name');
  
    /**
     * Detect if `prototype` properties are enumerable by default.
     *
     * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
     * (if the prototype or a property on the prototype has been set)
     * incorrectly set the `[[Enumerable]]` value of a function's `prototype`
     * property to `true`.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.enumPrototypes = propertyIsEnumerable.call(Ctor, 'prototype');
  
    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but Firefox OS certified apps, older Opera mobile browsers, and
     * the PlayStation 3; forced `false` for Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = /\bthis\b/.test(function() { return this; });
  
    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';
  
    /**
     * Detect if the `toStringTag` of DOM nodes is resolvable (all but IE < 9).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.nodeTag = objToString.call(document) != objectTag;
  
    /**
     * Detect if string indexes are non-enumerable (IE < 9, RingoJS, Rhino, Narwhal).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.nonEnumStrings = !propertyIsEnumerable.call('x', 0);
  
    /**
     * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
     *
     * In IE < 9 an object's own properties, shadowing non-enumerable ones,
     * are made non-enumerable as well (a.k.a the JScript `[[DontEnum]]` bug).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.nonEnumShadows = !/valueOf/.test(props);
  
    /**
     * Detect if own properties are iterated after inherited properties (IE < 9).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.ownLast = props[0] != 'x';
  
    /**
     * Detect if `Array#shift` and `Array#splice` augment array-like objects
     * correctly.
     *
     * Firefox < 10, compatibility modes of IE 8, and IE < 9 have buggy Array
     * `shift()` and `splice()` functions that fail to remove the last element,
     * `value[0]`, of array-like objects even though the "length" property is
     * set to `0`. The `shift()` method is buggy in compatibility modes of IE 8,
     * while `splice()` is buggy regardless of mode in IE < 9.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.spliceObjects = (splice.call(object, 0, 1), !object[0]);
  
    /**
     * Detect lack of support for accessing string characters by index.
     *
     * IE < 8 can't access characters by index. IE 8 can only access characters
     * by index on string literals, not string objects.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';
  
    /**
     * Detect if the DOM is supported.
     *
     * @memberOf _.support
     * @type boolean
     */
    try {
      support.dom = document.createDocumentFragment().nodeType === 11;
    } catch(e) {
      support.dom = false;
    }
  
    /**
     * Detect if `arguments` object indexes are non-enumerable.
     *
     * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
     * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
     * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
     * checks for indexes that exceed the number of function parameters and
     * whose associated argument values are `0`.
     *
     * @memberOf _.support
     * @type boolean
     */
    try {
      support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
    } catch(e) {
      support.nonEnumArgs = true;
    }
  }(1, 0));
  
  module.exports = support;
  
});
require.register('lodash-compat/lang/isString.js#3.7.0', function(module, exports, require) {
  var isObjectLike = require('lodash-compat/internal/isObjectLike.js#3.7.0');
  
  /** `Object#toString` result references. */
  var stringTag = '[object String]';
  
  /** Used for native method references. */
  var objectProto = Object.prototype;
  
  /**
   * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
   * of values.
   */
  var objToString = objectProto.toString;
  
  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */
  function isString(value) {
    return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
  }
  
  module.exports = isString;
  
});
require.register('lodash-compat/internal/toObject.js#3.7.0', function(module, exports, require) {
  var isObject = require('lodash-compat/lang/isObject.js#3.7.0'),
      isString = require('lodash-compat/lang/isString.js#3.7.0'),
      support = require('lodash-compat/support.js#3.7.0');
  
  /**
   * Converts `value` to an object if it is not one.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {Object} Returns the object.
   */
  function toObject(value) {
    if (support.unindexedChars && isString(value)) {
      var index = -1,
          length = value.length,
          result = Object(value);
  
      while (++index < length) {
        result[index] = value.charAt(index);
      }
      return result;
    }
    return isObject(value) ? value : Object(value);
  }
  
  module.exports = toObject;
  
});
require.register('lodash-compat/internal/baseProperty.js#3.7.0', function(module, exports, require) {
  var toObject = require('lodash-compat/internal/toObject.js#3.7.0');
  
  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : toObject(object)[key];
    };
  }
  
  module.exports = baseProperty;
  
});
require.register('lodash-compat/internal/getFuncName.js#3.7.0', function(module, exports, require) {
  var baseProperty = require('lodash-compat/internal/baseProperty.js#3.7.0'),
      constant = require('lodash-compat/utility/constant.js#3.7.0'),
      realNames = require('lodash-compat/internal/realNames.js#3.7.0'),
      support = require('lodash-compat/support.js#3.7.0');
  
  /**
   * Gets the name of `func`.
   *
   * @private
   * @param {Function} func The function to query.
   * @returns {string} Returns the function name.
   */
  var getFuncName = (function() {
    if (!support.funcNames) {
      return constant('');
    }
    if (constant.name == 'constant') {
      return baseProperty('name');
    }
    return function(func) {
      var result = func.name,
          array = realNames[result],
          length = array ? array.length : 0;
  
      while (length--) {
        var data = array[length],
            otherFunc = data.func;
  
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    };
  }());
  
  module.exports = getFuncName;
  
});
require.register('lodash-compat/internal/baseLodash.js#3.7.0', function(module, exports, require) {
  /**
   * The function whose prototype all chaining wrappers inherit from.
   *
   * @private
   */
  function baseLodash() {
    // No operation performed.
  }
  
  module.exports = baseLodash;
  
});
require.register('lodash-compat/internal/LazyWrapper.js#3.7.0', function(module, exports, require) {
  var baseCreate = require('lodash-compat/internal/baseCreate.js#3.7.0'),
      baseLodash = require('lodash-compat/internal/baseLodash.js#3.7.0');
  
  /** Used as references for `-Infinity` and `Infinity`. */
  var POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
  
  /**
   * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
   *
   * @private
   * @param {*} value The value to wrap.
   */
  function LazyWrapper(value) {
    this.__wrapped__ = value;
    this.__actions__ = null;
    this.__dir__ = 1;
    this.__dropCount__ = 0;
    this.__filtered__ = false;
    this.__iteratees__ = null;
    this.__takeCount__ = POSITIVE_INFINITY;
    this.__views__ = null;
  }
  
  LazyWrapper.prototype = baseCreate(baseLodash.prototype);
  LazyWrapper.prototype.constructor = LazyWrapper;
  
  module.exports = LazyWrapper;
  
});
require.register('lodash-compat/internal/isLaziable.js#3.7.0', function(module, exports, require) {
  var LazyWrapper = require('lodash-compat/internal/LazyWrapper.js#3.7.0'),
      getFuncName = require('lodash-compat/internal/getFuncName.js#3.7.0'),
      lodash = require('lodash-compat/chain/lodash.js#3.7.0');
  
  /**
   * Checks if `func` has a lazy counterpart.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
   */
  function isLaziable(func) {
    var funcName = getFuncName(func);
    return !!funcName && func === lodash[funcName] && funcName in LazyWrapper.prototype;
  }
  
  module.exports = isLaziable;
  
});
require.register('lodash-compat/internal/composeArgsRight.js#3.7.0', function(module, exports, require) {
  /* Native method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max;
  
  /**
   * This function is like `composeArgs` except that the arguments composition
   * is tailored for `_.partialRight`.
   *
   * @private
   * @param {Array|Object} args The provided arguments.
   * @param {Array} partials The arguments to append to those provided.
   * @param {Array} holders The `partials` placeholder indexes.
   * @returns {Array} Returns the new array of composed arguments.
   */
  function composeArgsRight(args, partials, holders) {
    var holdersIndex = -1,
        holdersLength = holders.length,
        argsIndex = -1,
        argsLength = nativeMax(args.length - holdersLength, 0),
        rightIndex = -1,
        rightLength = partials.length,
        result = Array(argsLength + rightLength);
  
    while (++argsIndex < argsLength) {
      result[argsIndex] = args[argsIndex];
    }
    var pad = argsIndex;
    while (++rightIndex < rightLength) {
      result[pad + rightIndex] = partials[rightIndex];
    }
    while (++holdersIndex < holdersLength) {
      result[pad + holders[holdersIndex]] = args[argsIndex++];
    }
    return result;
  }
  
  module.exports = composeArgsRight;
  
});
require.register('lodash-compat/internal/composeArgs.js#3.7.0', function(module, exports, require) {
  /* Native method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max;
  
  /**
   * Creates an array that is the composition of partially applied arguments,
   * placeholders, and provided arguments into a single array of arguments.
   *
   * @private
   * @param {Array|Object} args The provided arguments.
   * @param {Array} partials The arguments to prepend to those provided.
   * @param {Array} holders The `partials` placeholder indexes.
   * @returns {Array} Returns the new array of composed arguments.
   */
  function composeArgs(args, partials, holders) {
    var holdersLength = holders.length,
        argsIndex = -1,
        argsLength = nativeMax(args.length - holdersLength, 0),
        leftIndex = -1,
        leftLength = partials.length,
        result = Array(argsLength + leftLength);
  
    while (++leftIndex < leftLength) {
      result[leftIndex] = partials[leftIndex];
    }
    while (++argsIndex < holdersLength) {
      result[holders[argsIndex]] = args[argsIndex];
    }
    while (argsLength--) {
      result[leftIndex++] = args[argsIndex++];
    }
    return result;
  }
  
  module.exports = composeArgs;
  
});
require.register('lodash-compat/internal/arrayCopy.js#3.7.0', function(module, exports, require) {
  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function arrayCopy(source, array) {
    var index = -1,
        length = source.length;
  
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }
  
  module.exports = arrayCopy;
  
});
require.register('lodash-compat/internal/createHybridWrapper.js#3.7.0', function(module, exports, require) {
  var arrayCopy = require('lodash-compat/internal/arrayCopy.js#3.7.0'),
      composeArgs = require('lodash-compat/internal/composeArgs.js#3.7.0'),
      composeArgsRight = require('lodash-compat/internal/composeArgsRight.js#3.7.0'),
      createCtorWrapper = require('lodash-compat/internal/createCtorWrapper.js#3.7.0'),
      isLaziable = require('lodash-compat/internal/isLaziable.js#3.7.0'),
      reorder = require('lodash-compat/internal/reorder.js#3.7.0'),
      replaceHolders = require('lodash-compat/internal/replaceHolders.js#3.7.0'),
      setData = require('lodash-compat/internal/setData.js#3.7.0');
  
  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      ARY_FLAG = 128;
  
  /* Native method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max;
  
  /**
   * Creates a function that wraps `func` and invokes it with optional `this`
   * binding of, partial application, and currying.
   *
   * @private
   * @param {Function|string} func The function or method name to reference.
   * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {Array} [partials] The arguments to prepend to those provided to the new function.
   * @param {Array} [holders] The `partials` placeholder indexes.
   * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
   * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
   * @param {Array} [argPos] The argument positions of the new function.
   * @param {number} [ary] The arity cap of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new wrapped function.
   */
  function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
    var isAry = bitmask & ARY_FLAG,
        isBind = bitmask & BIND_FLAG,
        isBindKey = bitmask & BIND_KEY_FLAG,
        isCurry = bitmask & CURRY_FLAG,
        isCurryBound = bitmask & CURRY_BOUND_FLAG,
        isCurryRight = bitmask & CURRY_RIGHT_FLAG;
  
    var Ctor = !isBindKey && createCtorWrapper(func),
        key = func;
  
    function wrapper() {
      // Avoid `arguments` object use disqualifying optimizations by
      // converting it to an array before providing it to other functions.
      var length = arguments.length,
          index = length,
          args = Array(length);
  
      while (index--) {
        args[index] = arguments[index];
      }
      if (partials) {
        args = composeArgs(args, partials, holders);
      }
      if (partialsRight) {
        args = composeArgsRight(args, partialsRight, holdersRight);
      }
      if (isCurry || isCurryRight) {
        var placeholder = wrapper.placeholder,
            argsHolders = replaceHolders(args, placeholder);
  
        length -= argsHolders.length;
        if (length < arity) {
          var newArgPos = argPos ? arrayCopy(argPos) : null,
              newArity = nativeMax(arity - length, 0),
              newsHolders = isCurry ? argsHolders : null,
              newHoldersRight = isCurry ? null : argsHolders,
              newPartials = isCurry ? args : null,
              newPartialsRight = isCurry ? null : args;
  
          bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
          bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
  
          if (!isCurryBound) {
            bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
          }
          var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
              result = createHybridWrapper.apply(undefined, newData);
  
          if (isLaziable(func)) {
            setData(result, newData);
          }
          result.placeholder = placeholder;
          return result;
        }
      }
      var thisBinding = isBind ? thisArg : this;
      if (isBindKey) {
        func = thisBinding[key];
      }
      if (argPos) {
        args = reorder(args, argPos);
      }
      if (isAry && ary < args.length) {
        args.length = ary;
      }
      var fn = (this && this !== global && this instanceof wrapper) ? (Ctor || createCtorWrapper(func)) : func;
      return fn.apply(thisBinding, args);
    }
    return wrapper;
  }
  
  module.exports = createHybridWrapper;
  
});
require.register('lodash-compat/lang/isObject.js#3.7.0', function(module, exports, require) {
  /**
   * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(1);
   * // => false
   */
  function isObject(value) {
    // Avoid a V8 JIT bug in Chrome 19-20.
    // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
    var type = typeof value;
    return type == 'function' || (!!value && type == 'object');
  }
  
  module.exports = isObject;
  
});
require.register('lodash-compat/internal/baseCreate.js#3.7.0', function(module, exports, require) {
  var isObject = require('lodash-compat/lang/isObject.js#3.7.0');
  
  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} prototype The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function Object() {}
    return function(prototype) {
      if (isObject(prototype)) {
        Object.prototype = prototype;
        var result = new Object;
        Object.prototype = null;
      }
      return result || global.Object();
    };
  }());
  
  module.exports = baseCreate;
  
});
require.register('lodash-compat/internal/createCtorWrapper.js#3.7.0', function(module, exports, require) {
  var baseCreate = require('lodash-compat/internal/baseCreate.js#3.7.0'),
      isObject = require('lodash-compat/lang/isObject.js#3.7.0');
  
  /**
   * Creates a function that produces an instance of `Ctor` regardless of
   * whether it was invoked as part of a `new` expression or by `call` or `apply`.
   *
   * @private
   * @param {Function} Ctor The constructor to wrap.
   * @returns {Function} Returns the new wrapped function.
   */
  function createCtorWrapper(Ctor) {
    return function() {
      var thisBinding = baseCreate(Ctor.prototype),
          result = Ctor.apply(thisBinding, arguments);
  
      // Mimic the constructor's `return` behavior.
      // See https://es5.github.io/#x13.2.2 for more details.
      return isObject(result) ? result : thisBinding;
    };
  }
  
  module.exports = createCtorWrapper;
  
});
require.register('lodash-compat/internal/createBindWrapper.js#3.7.0', function(module, exports, require) {
  var createCtorWrapper = require('lodash-compat/internal/createCtorWrapper.js#3.7.0');
  
  /**
   * Creates a function that wraps `func` and invokes it with the `this`
   * binding of `thisArg`.
   *
   * @private
   * @param {Function} func The function to bind.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @returns {Function} Returns the new bound function.
   */
  function createBindWrapper(func, thisArg) {
    var Ctor = createCtorWrapper(func);
  
    function wrapper() {
      var fn = (this && this !== global && this instanceof wrapper) ? Ctor : func;
      return fn.apply(thisArg, arguments);
    }
    return wrapper;
  }
  
  module.exports = createBindWrapper;
  
});
require.register('lodash-compat/internal/isObjectLike.js#3.7.0', function(module, exports, require) {
  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  
  module.exports = isObjectLike;
  
});
require.register('lodash-compat/internal/isHostObject.js#3.7.0', function(module, exports, require) {
  /**
   * Checks if `value` is a host object in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
   */
  var isHostObject = (function() {
    try {
      Object({ 'toString': 0 } + '');
    } catch(e) {
      return function() { return false; };
    }
    return function(value) {
      // IE < 9 presents many host objects as `Object` objects that can coerce
      // to strings despite having improperly defined `toString` methods.
      return typeof value.toString != 'function' && typeof (value + '') == 'string';
    };
  }());
  
  module.exports = isHostObject;
  
});
require.register('lodash-compat/internal/baseToString.js#3.7.0', function(module, exports, require) {
  /**
   * Converts `value` to a string if it is not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }
    return value == null ? '' : (value + '');
  }
  
  module.exports = baseToString;
  
});
require.register('lodash-compat/string/escapeRegExp.js#3.7.0', function(module, exports, require) {
  var baseToString = require('lodash-compat/internal/baseToString.js#3.7.0');
  
  /**
   * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).
   * In addition to special characters the forward slash is escaped to allow for
   * easier `eval` use and `Function` compilation.
   */
  var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);
  
  /**
   * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
   * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
   *
   * @static
   * @memberOf _
   * @category String
   * @param {string} [string=''] The string to escape.
   * @returns {string} Returns the escaped string.
   * @example
   *
   * _.escapeRegExp('[lodash](https://lodash.com/)');
   * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
   */
  function escapeRegExp(string) {
    string = baseToString(string);
    return (string && reHasRegExpChars.test(string))
      ? string.replace(reRegExpChars, '\\$&')
      : string;
  }
  
  module.exports = escapeRegExp;
  
});
require.register('lodash-compat/lang/isNative.js#3.7.0', function(module, exports, require) {
  var escapeRegExp = require('lodash-compat/string/escapeRegExp.js#3.7.0'),
      isHostObject = require('lodash-compat/internal/isHostObject.js#3.7.0'),
      isObjectLike = require('lodash-compat/internal/isObjectLike.js#3.7.0');
  
  /** `Object#toString` result references. */
  var funcTag = '[object Function]';
  
  /** Used to detect host constructors (Safari > 5). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  
  /** Used for native method references. */
  var objectProto = Object.prototype;
  
  /** Used to resolve the decompiled source of functions. */
  var fnToString = Function.prototype.toString;
  
  /**
   * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
   * of values.
   */
  var objToString = objectProto.toString;
  
  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    escapeRegExp(objToString)
    .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );
  
  /**
   * Checks if `value` is a native function.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
   * @example
   *
   * _.isNative(Array.prototype.push);
   * // => true
   *
   * _.isNative(_);
   * // => false
   */
  function isNative(value) {
    if (value == null) {
      return false;
    }
    if (objToString.call(value) == funcTag) {
      return reIsNative.test(fnToString.call(value));
    }
    return isObjectLike(value) && (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);
  }
  
  module.exports = isNative;
  
});
require.register('lodash-compat/internal/metaMap.js#3.7.0', function(module, exports, require) {
  var isNative = require('lodash-compat/lang/isNative.js#3.7.0');
  
  /** Native method references. */
  var WeakMap = isNative(WeakMap = global.WeakMap) && WeakMap;
  
  /** Used to store function metadata. */
  var metaMap = WeakMap && new WeakMap;
  
  module.exports = metaMap;
  
});
require.register('lodash-compat/utility/identity.js#3.7.0', function(module, exports, require) {
  /**
   * This method returns the first argument provided to it.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'user': 'fred' };
   *
   * _.identity(object) === object;
   * // => true
   */
  function identity(value) {
    return value;
  }
  
  module.exports = identity;
  
});
require.register('lodash-compat/internal/baseSetData.js#3.7.0', function(module, exports, require) {
  var identity = require('lodash-compat/utility/identity.js#3.7.0'),
      metaMap = require('lodash-compat/internal/metaMap.js#3.7.0');
  
  /**
   * The base implementation of `setData` without support for hot loop detection.
   *
   * @private
   * @param {Function} func The function to associate metadata with.
   * @param {*} data The metadata.
   * @returns {Function} Returns `func`.
   */
  var baseSetData = !metaMap ? identity : function(func, data) {
    metaMap.set(func, data);
    return func;
  };
  
  module.exports = baseSetData;
  
});
require.register('lodash-compat/internal/createWrapper.js#3.7.0', function(module, exports, require) {
  var baseSetData = require('lodash-compat/internal/baseSetData.js#3.7.0'),
      createBindWrapper = require('lodash-compat/internal/createBindWrapper.js#3.7.0'),
      createHybridWrapper = require('lodash-compat/internal/createHybridWrapper.js#3.7.0'),
      createPartialWrapper = require('lodash-compat/internal/createPartialWrapper.js#3.7.0'),
      getData = require('lodash-compat/internal/getData.js#3.7.0'),
      mergeData = require('lodash-compat/internal/mergeData.js#3.7.0'),
      setData = require('lodash-compat/internal/setData.js#3.7.0');
  
  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64;
  
  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';
  
  /* Native method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max;
  
  /**
   * Creates a function that either curries or invokes `func` with optional
   * `this` binding and partially applied arguments.
   *
   * @private
   * @param {Function|string} func The function or method name to reference.
   * @param {number} bitmask The bitmask of flags.
   *  The bitmask may be composed of the following flags:
   *     1 - `_.bind`
   *     2 - `_.bindKey`
   *     4 - `_.curry` or `_.curryRight` of a bound function
   *     8 - `_.curry`
   *    16 - `_.curryRight`
   *    32 - `_.partial`
   *    64 - `_.partialRight`
   *   128 - `_.rearg`
   *   256 - `_.ary`
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {Array} [partials] The arguments to be partially applied.
   * @param {Array} [holders] The `partials` placeholder indexes.
   * @param {Array} [argPos] The argument positions of the new function.
   * @param {number} [ary] The arity cap of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new wrapped function.
   */
  function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
    var isBindKey = bitmask & BIND_KEY_FLAG;
    if (!isBindKey && typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var length = partials ? partials.length : 0;
    if (!length) {
      bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
      partials = holders = null;
    }
    length -= (holders ? holders.length : 0);
    if (bitmask & PARTIAL_RIGHT_FLAG) {
      var partialsRight = partials,
          holdersRight = holders;
  
      partials = holders = null;
    }
    var data = isBindKey ? null : getData(func),
        newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
  
    if (data) {
      mergeData(newData, data);
      bitmask = newData[1];
      arity = newData[9];
    }
    newData[9] = arity == null
      ? (isBindKey ? 0 : func.length)
      : (nativeMax(arity - length, 0) || 0);
  
    if (bitmask == BIND_FLAG) {
      var result = createBindWrapper(newData[0], newData[2]);
    } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
      result = createPartialWrapper.apply(undefined, newData);
    } else {
      result = createHybridWrapper.apply(undefined, newData);
    }
    var setter = data ? baseSetData : setData;
    return setter(result, newData);
  }
  
  module.exports = createWrapper;
  
});
require.register('lodash-compat/function/bind.js#3.7.0', function(module, exports, require) {
  var createWrapper = require('lodash-compat/internal/createWrapper.js#3.7.0'),
      replaceHolders = require('lodash-compat/internal/replaceHolders.js#3.7.0'),
      restParam = require('lodash-compat/function/restParam.js#3.7.0');
  
  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      PARTIAL_FLAG = 32;
  
  /**
   * Creates a function that invokes `func` with the `this` binding of `thisArg`
   * and prepends any additional `_.bind` arguments to those provided to the
   * bound function.
   *
   * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
   * may be used as a placeholder for partially applied arguments.
   *
   * **Note:** Unlike native `Function#bind` this method does not set the "length"
   * property of bound functions.
   *
   * @static
   * @memberOf _
   * @category Function
   * @param {Function} func The function to bind.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {...*} [partials] The arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   * @example
   *
   * var greet = function(greeting, punctuation) {
   *   return greeting + ' ' + this.user + punctuation;
   * };
   *
   * var object = { 'user': 'fred' };
   *
   * var bound = _.bind(greet, object, 'hi');
   * bound('!');
   * // => 'hi fred!'
   *
   * // using placeholders
   * var bound = _.bind(greet, object, _, '!');
   * bound('hi');
   * // => 'hi fred!'
   */
  var bind = restParam(function(func, thisArg, partials) {
    var bitmask = BIND_FLAG;
    if (partials.length) {
      var holders = replaceHolders(partials, bind.placeholder);
      bitmask |= PARTIAL_FLAG;
    }
    return createWrapper(func, bitmask, thisArg, partials, holders);
  });
  
  // Assign default placeholders.
  bind.placeholder = {};
  
  module.exports = bind;
  
});
require.register('lib/application.js', function(module, exports, require) {
  /**
   * Browser application
   */
  
  var bind = require('lodash-compat/function/bind.js#3.7.0')
  	, debug = require('debug#2.1.2')('express:application')
  	, forEach = require('lodash-compat/collection/forEach.js#3.7.0')
  	, history = require('lib/history.js')
  	, merge = require('lodash-compat/object/merge.js#3.7.0')
  	, request = require('lib/request.js')
  	, response = require('lib/response.js')
  	, router = require('lib/router.js')
  
  	, METHODS = ['get', 'post', 'all'];
  
  module.exports = Application;
  
  /**
   * Constructor
   */
  function Application () {
  	if (!(this instanceof Application)) {
  		return new Application();
  	}
  
  	this.settings = {
  		env: undefined || 'development'
  	};
  	this.cache = {};
  	this.locals = {};
  	this.mountpath = '/';
  	this._router = router({
  		caseSensitive: false,
  		strict: false,
  		mergeParams: true
  	});
  	this.parent;
  
  	this.handle = bind(this.handle, this);
  	this.finalhandler = bind(this.finalhandler, this);
  	this.navigateTo = bind(this.navigateTo, this);
  	this.redirectTo = bind(this.redirectTo, this);
  	this.getCurrentContext = bind(this.getCurrentContext, this);
  	this.refresh = bind(this.refresh, this);
  
  	// Create request/response factories
  	var app = this
  		, req = function (url, bootstrap) {
  				var req = request(url, bootstrap);
  				req.app = app;
  				return req;
  			}
  		, res = function () {
  				var res = response();
  				res.app = app;
  				return res;
  			};
  
  	this.history = history(req, res, this.handle);
  }
  
  /**
   * Store 'value' for 'key'
   * @param {String} key
   * @param {Object} value
   */
  Application.prototype.set = function (key, value) {
  	// get()
  	if (arguments.length == 1) return this.settings[key];
  
  	this.settings[key] = value;
  };
  
  /**
   * Add one or more 'fn' to middleware pipeline at optional 'path'
   * @param {Function} fn(req, res, next)
   */
  Application.prototype.use = function (/* path, */ fn /* ...fn */) {
  	var offset = 0
  		, path = '/'
  		, fns, path;
  
  	if ('string' == typeof fn) {
  		offset = 1;
  		path = fn;
  	}
  
  	fns = Array.prototype.slice.call(arguments, offset);
  
  	forEach(fns, function (fn) {
  		if (fn instanceof Application) {
  			var app = fn
  				, handler = app.handle;
  			app.mountpath = path;
  			app.parent = this;
  			fn = function mounted_app (req, res, next) {
  				// Change app reference to mounted
  				var orig = req.app;
  				req.app = res.app = app;
  				handler(req, res, function (err) {
  					// Restore app reference when done
  					req.app = res.app = orig;
  					next(err);
  				});
  			};
  		}
  
  		debug('adding application middleware layer with path %s', path);
  		this._router.use(path, fn);
  	}, this);
  };
  
  /**
   * Handle param 'name' with 'fn'
   * @param {String} name
   * @param {Function} fn(req, res, next, value)
   */
  Application.prototype.param = function (name, fn) {
  	this._router.param(name, fn);
  };
  
  /**
   * Add one or more VERB fns at 'path' with strict matching of path
   * @param {String} path
   */
  forEach(METHODS, function (method) {
  	Application.prototype[method] = function (path) {
  		// get/set version
  		if (method == 'get' && arguments.length == 1) return this.set(path);
  
  		this._router[method].apply(this._router, Array.prototype.slice.call(arguments));
  
  		return this;
  	};
  });
  
  /**
   * Start listening for requests
   */
  Application.prototype.listen = function () {
  	if (!this.parent) this.history.listen();
  };
  
  /**
   * Run request/response through router's middleware pipline
   * @param {Request} req
   * @param {Response} res
   * @param {Function} done
   */
  Application.prototype.handle = function (req, res, done) {
  	this._router.handle(req, res, done || this.finalhandler);
  };
  
  /**
   *
   */
  Application.prototype.finalhandler = function (err) {
  };
  
  /**
   * Render view with given 'name', 'options' and callback 'fn'
   * @param {String} name
   * @param {Object} [options]
   * @param {Function} fn(err, html)
   */
  Application.prototype.render = function (name, options, fn) {
  	var opts = {}
  		, view;
  
  	if ('function' == typeof options) {
  		fn = options;
  		options = {};
  	}
  
  	// Merge global, response, and passed locals
  	merge(opts, this.locals, options._locals, options);
  
  	view = this.cache[name];
  
  	if (!view) {
  		view = new (this.get('view'))(name, {
  			//
  		});
  
  		if (!view) {
  			var err = new Error('Failed to lookup view ' + name);
  			return fn(err);
  		}
  
  		// Store
  		this.cache[name] = view;
  	}
  
  	try {
  		view.render(opts, fn);
  	} catch (err) {
  		err.statusCode = err.status = 500;
  		fn(err);
  	}
  };
  
  /**
   * Change/update browser history state
   * @param {String} url
   * @param {String} title
   * @param {Boolean} isUpdate
   */
  Application.prototype.navigateTo = function (url, title, isUpdate) {
  	this[this.parent ? 'parent' : 'history'].navigateTo(url, title, isUpdate);
  };
  
  /**
   * Force browser location change
   * @param {String} url
   * @param {String} title
   */
  Application.prototype.redirectTo = function (url) {
  	this[this.parent ? 'parent' : 'history'].redirectTo(url);
  };
  
  /**
   * Retrieve current context
   * @returns {Object}
   */
  Application.prototype.getCurrentContext = function () {
  	return this[this.parent ? 'parent' : 'history'].getCurrentContext();
  };
  
  /**
   * Refresh current location
   * @returns {Object}
   */
  Application.prototype.refresh = function () {
   	this[this.parent ? 'parent' : 'history'].refresh();
   };
});
require.register('express-client/index.js', function(module, exports, require) {
  var application = require('lib/application.js')
  	, Router = require('lib/router.js');
  
  module.exports = createApplication;
  
  /**
   * Application factory
   */
  function createApplication () {
  	return application();
  };
  
  /**
   * Expose
   */
  module.exports.Router = Router;
});
require.register('lib.js', function(module, exports, require) {
  // lodash
  window.global = window;
  require('express-client/index.js');
});
require('lib.js');